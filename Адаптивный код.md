# Адаптивный код

### Table of Contents

1.	**[Введение в скрам](#1.Введениескрам)**<br>
	1.1. **[Роли](#2.Роли)**<br>
	1.2. **[Артефакты](#2.Артефакты)**<br>
	1.3. **[Технический ](#2.Технический)**<br>
	1.4. **[Определение законченности](#2.Определениезаконченности)**<br>
	1.5. **[Скорость](#2.Скорость)**<br>
	1.6. **[Беклог](#2.Беклог)**<br>
	1.7. **[Спринт](#2.Спринт)**<br>
2.	**[Введение в канбан](#1.Введениеканбан)**<br>
	2.1. **[Две задачи в завершении разработки](#2.Двезадачивзавершении)**<br>
3.	**[Зависимости](#1.Зависимости)**<br>
	3.1. **[Управление зависимостями](#2.Управлениезависимостями)**<br>
		3.1.1. **[Распознавание сборок](#3.Распознавание)**<br>
		3.1.2. **[Службы](#3.Службы)**<br>
		3.1.3. **[Управление зависимостями через nuget](#3.УправлениезависимостямиNuget)**<br>
	3.2. **[Разделение на уровни](#2.Разделениенауровни)**<br>
		3.2.1. **[Паттерны разделения на уровни](#3.Паттерныразделения)**<br>
		3.2.2. **[Два уровня (UI -> доступ к данным)](#3.Двауровня)**<br>
			3.2.2.1.**[Пользовательский интерфейс](#4.Пользовательскийинтерфейс)**<br>
			3.2.2.2.**[Доступ к данным](#4.Доступданным)**<br>
		3.2.3. **[Три уровня](#3.Триуровня)**<br>
		3.2.4. **[Слабые обязанности](#3.Слабыеобязанности)**<br>
		3.2.5. **[Отделение команд от запросов](#3.Отделениекомандзапросов)**<br>
4.	**[Интерфейсы и паттерны проектирования](#1.Интерфейсыпаттерныпроектирования)**<br>
	4.1. **[Полиморфизм](#2.Полиморфизм)**<br>
	4.2. **[Адаптивные паттерны](#2.Адаптивныепаттерны)**<br>
		4.2.1. **[Паттерн null-object](#3.Паттернnull)**<br>
		4.2.2. **[Антипаттерн IsNull](#3.АнтипаттернIsNull)**<br>
		4.2.3. **[Адаптер паттерн](#3.Адаптерпаттерн)**<br>
			4.2.3.1. **[Адаптер класса](#4.Адаптеркласса)**<br>
			4.2.3.2. **[Адаптер объекта](#4.Адаптеробъекта)**<br>
	4.3. **[Паттерн стратегия](#3.стратегия)**<br>
	4.4. **[Утиная типизация](#3.Утинаятипизация)**<br>
	4.5. **[Примеси](#3.Примеси)**<br>
	4.6. **[Текучие интерфейсы](#3.Текучие)**<br>
5.	**[Тестирование](#1.Тестирование)**<br>
	5.1. **[Модульное тестирование](#2.Модульноетестирование)**<br>
	5.2. **[Разработка через тестирование](#2.Разработкачерезтестирование)**<br>
		5.2.1. **[Красный зеленый рефакторинг](#3.Красныйзеленыйрефакторинг)**<br>
		5.2.2. **[Тестовые дублеры](#3.Дублеры)**<br>
		5.2.3. **[Настройка тестов](#3.Настройкатестов)**<br>
	5.3. **[Паттерны модульного тестирования](#2.модульное)**<br>
		5.3.1. **[Паттерн строитель](#3.строитель)**<br>
	5.4. **[TDD (testing driving development)](#2.TDD)**<br>
		5.4.1. **[Добавочное тестирование](#3.Добавочное)**<br>
		5.4.2. **[Тестирование для профилактики проблем](#3.Профилактика)**<br>
6.	**[Рефакторинг](#1.Рефакторинг)**<br>
	6.1. **[Из рефакторинга к перепроектирвоанию](#2.Перепроектирвоаниe)**<br>
		6.1.3. **[Превращение унаследованного кода в адаптивный](#3.Превращение)**<br>
7.	**[SOLID](#1.SOLID)**<br>
	7.1. **[Принцип единичной ответственности(SRP)](#2.SRP)**<br>
		7.1.1 **[Рефакторинг для абстрагирования](#3.Рефакторингдляабстрагирования)**<br>
		7.1.2 **[SPR и декоратор](#3.декоратор)**<br>
		7.1.3 **[SPR и компоновщик](#3.компоновщик)**<br>
		7.1.4 **[Предикатный декоратор](#3.Предикатный)**<br>
		7.1.5 **[Разветвляющий декоратор](#3.Разветвляющий)**<br>
		7.1.6 **[Ленивые декораторы](#3.Ленивые)**<br>
		7.1.7 **[Регистрирующие декораторы](#3.Регистрирующие)**<br>
		7.1.8 **[Профилирующие декораторы](#3.Профилирующие)**<br>
		7.1.9 **[Декорирование свойств и событий](#3.Декорирование)**<br>
	7.2. **[Принцип открытости-закрытости (OCP)](#2.OCP)**<br>
		7.2.1. **[Открыты для расширения](#3.Открытыдлярасширения)**<br>
		7.2.2. **[Виртуальные методы](#3.Виртуальныеметоды)**<br>
		7.2.3. **[Абстрактные методы](#3.Абстрактныеметоды)**<br>
		7.2.4. **[Интерфейс](#3.Интерфейс)**<br>
	7.3. **[Закрытость к модификации](#2.Закрытостькмодификации)**<br>
	7.4. **[Принцип подстановки лисков (LSP liskovs ubstitution principe)](#1.LSP)**<br>
		7.4.1. **[Ковариантность и контрвариантность](#2.)**<br>
	7.5. **[Разделение интерфейса](#1.Разделениеинтерфейса)**<br>
	7.6. **[Инверсия зависимостей](#1.Инверсиязависимостей)**<br>
	7.7. **[Применение адаптивного кода](#1.Применение)**<br>
	7.8. **[Внедрение зависимостей](#2.Внедрениезависимостей)**<br>
	7.9. **[Инверсия управления](#2.Инверсияуправления)**<br>
	7.10. **[Паттерн RRR(Register, Resolve, Release)](#2.RRR)**<br>
	7.11. **[Императивная и декларативная регистрация](#2.регистрация)**<br>
	7.12. **[Время жизни](#2.Времяжизни)**<br>
	7.13. **[Антипаттерны внедрения зависимостей](#2.Антипаттерны)**<br>
	7.14. **[Связность, сцепление и соразвитие](#2.Связность)**<br>

# Введение в скрам <a name="1.Введениескрам"></a>
Scrum - это гибкая методология управления проектами, ценность которой в итеративности
**Гибкая методология разработки требует гибкого кода, иначе вносимые изменения будет всем сложнее и медленнее**

Водопад не подразумевает движения в обратном направлении, т.е если завершили разработку и споткнулись на тестировании - путей обратно нет и получается комок грязи из исполнителей. Водопад не предполагает изменений или изменения избегаются

Скрам подразумевает, что изменения неизбежны и процесс построен так, чтобы учитывать адаптивность к изменениям

**Цель:** Писать код адаптивный к изменениям

В водопаде акцент на документацию, в скраме на ПО

## Роли <a name="2.Роли"></a>
* владелец продукта (связь с заказчиком, приоритеты, оценка следования требованиям)
* скрам-мастер (организация работы по скраму, защита от изменения спринта сверху)
* разработчики (специалисты, реализующие цели спринта)

## Артефакты <a name="2.Артефакты"></a>
* Доска Scrum (реальная доска)
* карточки для разных задач с разным цветом
* зеленые - функциональные средства
* белые - истории
* желтые - задачи
* красные - баги
* фиолетовые - тех.долг
* иерархия композиции - связи между карточками
* продукт - что должно быть сделано
* релиз - версия
* функциональное средство. могут быть обязательные, предпочтительные, желательные
* пользовательская история (формируется так (как, что, что сделать, когда)) анализируется, разбивается на задачи
* задача - часть истории на конкретном разработчике
* техдолг
* баг
* беклог - упорядочен по приоритету
* тестирование
Горизонтальные дорожки для группирования по функциональному средству(истории с самого верха, может быть дорожка для самых важных задач)

## Технический  <a name="2.Технический"></a>
Квадрат технической задолженность
|опрометчивая|благоразумная|
|------------|-------------|
|нет время на проектирование|выполним поставку, потом займется последствиями|

|неумышленная|благоразумная|
|------------|-------------|
|мы не знаем, что это такое, если бы мы знали, что это такое. ООП| мы знаем как должны были сделать

## Определение законченности <a name="2.Определениезаконченности"></a>
Признаки:
* прошли модульные тесты
* прошло интеграционное тестирование
* корректное поведение по тест-кейсам
* прошло

## Скорость <a name="2.Скорость"></a>
Скорость команды можно вычислить после нескольких спринтов. Измерить в сторипоинтах. В дальнейшем скорость можно анализировать для оценки качества планирования

## Беклог <a name="2.Беклог"></a>
Беклог продукта: приоритет - это ценность задачи (функционального средства)
Беклог спинта - стори, который должен реализовать в спринте. Оценивается командой

## Спринт <a name="2.Спринт"></a>
Лучший запуск - середина недели
Планирование:
* определяется дата, приоритеты, функциональные средства
* покер (оценка стори в масштабе - числа Фибоначчи)
* митинги - что делал, что буду делать, какие проблемы
* демонстрация спринта (если нечего - смотрим на графики, где что-то пошло не так)
* ретроспектива спринта (начать с положительного, потом к отрицательному). Может быть переоценить стори, которые ошибочно оценены

Проект должен быть адаптивен, как и процесс разработки.
Мешают гибкости проекта
* жесткость
* нехватка абстракции
* слишком много абстракции
* смешанная обязанность
* неприспособленность к тестированию

# Введение в канбан <a name="1.Введениеканбан"></a>
Канбан по-японски - вывеска
доска канбан - что делать | выполняется | закончено
сбор данных о процессе -
|ждать | анализировать | реализовывать | проверить | поставить|
|------|---------------|---------------|-----------|----------|
|упорядочены по приоритету|добавление деталей к задаче, что надо сделать| реализация|тестирование|результат|
* каждая колонка может быть разбита на две части (написана документация | заверено)
* каждая колонка имеет лимит

## Две задачи в завершении разработки <a name="2.Двезадачивзавершении"></a>
* защита против изменений: не менять постановку в момент реализации
* определение законченности
* каждый последующий этап говорит о законченности предыдущего
* законченность спецификации
* размер работ
* ожидаемая функциональность
* ситуации сбоя
* законченность кода
* тесты 80%
* существующие тесты не уменьшили покрытие
* ревью
* законченность тестирования
* автоматические проходят
* нет багов
* соответствует спецификации
* регресс проходит
* совещания: если колонка выполняется пустая или пустой беклог. необходимо собрать ответственных, имеющих отношение к проблеме
* введение класса обслуживания - эти карточки должны разделяться на доске(баги, новый функционал)
* соглашение об уровне обслуживания: выделить количество дней на карточку + уровень доверия (50%). Нестрогий срок, но повод стремиться
* лимиты классов обслуживания: например, для задач рефакторинга
* время выполнения и время цикла -метрики работы команды
**время цикла** - время потраченное на выполнение задачи
**время выполнения** - время ожидания в беклоге + время

Канбан лучше подходит для непрерывной поставки
**Скрам для новой команды, канбан для зрелой**

# Зависимости <a name="1.Зависимости"></a>
В начале проекта скорость разработки может быть высокой, но если неправильный подход к зависимостям, то скорость начинает падать
**Зависимость** - соотношение между сущностями, при условии что одна не может выполнять действия без второй.
A зависит от B, но B не зависит от A - тип зависимости **Клиент-служба**(Основная зависимость)

Если зависимость не вызывается(используется какой-то метод), а просто есть(загружена), то исполняемая среда CLR ее не загружает. using в начале файла не генерирует инструкции для CLR и служат лишь синтаксическим сахаром

**Зависимости от инфраструктуры** (сборки Netcore, Framework) При загрузке инфраструктурной сборки она загружается в память раз для всех. Ссылка на инфраструктурную сборку всегда вызывает загрузку при запуске приложения, если сборка еще не загружена
**Сторонние зависимости** - зависимости внешних поставщиков.

Для моделирования зависимостей кода, хороши графы (стрелка от зависимого). Есть возможность обойти граф по ребрам. Если идти по одному из ребер и приходишь к себе же - это циклическая зависимость. Если зависишь сам от себя, получается петля, которая свидетельствует от рекурсии

## Управление зависимостями <a name="2.Управлениезависимостями"></a>
* отказ от программирования на реализации в пользу интерфейсов в защиту сокрытия реализации
* new - признак плохого кода - это опускание в реализацию(конструктор):
* получаем сложности модульного тестирования
* невозможность улучшения реализаций (для клиентов нужно будет оставлять классы неизменяемыми)
* цепочка зависимостей (зависимости от внутренних реализаций)
* Решение: использование интерфейса, созданного в другой сборке, внедрение зависимостей

### Распознавание сборок <a name="3.Распознавание"></a>
CLR - исполняющая среда, которая представляет собой виртуальную машину для выполнения кода. Процесс распознавания сборок в Net Framework - Это процесс покрывающий разрыв между добавлением ссылки на сборку в проекте и обеспечение работы с запущенной сборкой.
* применение JIT(just in time) для распознавания сборок в момент задействования функций сборок
* сборка имеет идентичность (имя, версия, культура, маркер, открытого ключа)
* когда установлена идентичность, CLR выясняет были ли попытки распознавания в текущем выполнении
* если была, то используем загруженную сборку(если грузили, но получили ошибку, то даже не пытаемся загрузить)
* если первая попытка:
* проверяется GAG - глобальный кэш сборок(хранилище сборок на уровне машины). если в нем нашли, что загружаем оттуда
* если нет GAC просматриваются каталоги(app.config, codebase), если и тут нет, то bin
* если нет значит распознавание потерпело неудачу

### Службы <a name="3.Службы"></a>
Службы добавляют меньшую связность
Два способа создания службы
* Если адрес известен. Возможно добавление ссылки на службу с генерацией классов (WCF), которая создает прокси-класс службы. ну или написать прокси класс самому
* Если адрес службы не известен. Возможно обращение через прокси к одному узлу, который перенаправляет запросы (UDP). Минус - единственная точка точка отказа, не гарантирует доставку сообщений
* служба **REST**. Очень низкие требования зависимости. HTTP запрос + правильная инструкция. Получается зависимость только инфраструктурная

### Управление зависимостями через nuget <a name="3.УправлениезависимостямиNuget"></a>
если пользуемся собственными и внешними пакетами, лучше использовать Nuget, так как помимо удобства получаем информацию, о внутренних зависимостях пакета

## Разделение на уровни <a name="2.Разделениенауровни"></a>
**Компонент** - группа из двух или более связных сборок.
**Разделение на уровни** - паттерн, который способствует восприятию компонентов, как горизонтальных уровней функциональности, основанных друг на друге с целью формирования полного приложения. Нижний уровень не имеет зависимостей, а верхний зависит от нижнего, но не сквозная зависимость от нижнего, только -1

### Паттерны разделения на уровни <a name="3.Паттерныразделения"></a>
Чем больше сложность, тем больше уровней
Разница между уровнями и звеньями - это разница между логическим разделением и физическим развертыванием кода. Каждое новое звено - это пересечение границ сети(влечет издержки), но дает возможность к горизонтальному масштабированию
### Два уровня (UI -> доступ к данным) <a name="3.Двауровня"></a>
#### Пользовательский интерфейс <a name="4.Пользовательскийинтерфейс"></a>
Это способ взаимодействия с приложением
* отображение данных
* получение пользовательских требований
* проверка достоверности пользовательского ввода (JS, WPF, набор служб)
* пользовательский интерфейс должен обращаться к интерфейсам доступа к данным, но это по-прежнему два уровня

**Утечка абстракции - ссылка из верхнего уровня на реализацию нижнего уровня**

#### Доступ к данным <a name="4.Доступданным"></a>
* Обслуживание запросов к данным
* сериализация и десериализация объектных моделей в и из доменной модели

Имеем источник хранения данных и слой доступа к ним (могут быть просто хранимки)
**Минусы** очевидны (смешение логики, сложность тестирования, сложность переиспользования)
**Плюсы** быстро

### Три уровня <a name="3.Триуровня"></a>
Пользовательский интерфейс ->(вниз)бизнес-логика-> доступ к данным
**Бизнес-логика**
* предоставляет интерфейсы доступа к нижнему слою
* обрабатывает команды UI
* моделирует предметную область для сбора бизнес-процессов, правил
* не должно быть зависимости от реализации (ORM, UI и т.д)

### Слабые обязанности <a name="3.Слабыеобязанности"></a>
**Аспекты** - это применение сквозных обязанностей к множеству уровней кода. Например, аттрибуты логгирования и валидации

### Отделение команд от запросов <a name="3.Отделениекомандзапросов"></a>
**CQRS (Command QUERY RESPONSIBILITY DEGREGATION)**
**CQS**- разделение команд и запросов
**Команды** требуют от кода сделать что-нибудь. Они могут менять состояние системы. Команда не возвращает значения
**Запросы** заявки на данные, требующие получить что-нибудь

**Отделение обязанностей команд и запросов.**
CQRS предполагает, что для наилучшей обработки команды или запросы могут нуждаться в следовании разным путям через уровни. Например три уровня для команд и два для запросов. Для команд нужно обеспечивать acid (атомарность, согласованность, изоляцию, постоянство)

# Интерфейсы и паттерны проектирования <a name="1.Интерфейсыпаттерныпроектирования"></a>
Помимо известного факта, определяющего интерфейс, как "определитель поведения", интерфейс определяется характеристиками, концепциями, которые он воплощает.
Сколько интерфейсов имеет смысл реализовывать классу, ведь количество неограниченно

**Множественное наследование было запрещено, потому что если один класс наследует больше одного класса, и они содержат идентичные методы, то какой должен применяться**

**Неявная реализация интерфейса** - это когда интерфейс определяется через член класса
**Явная реализация** - определение методов в классе

Пример: IListCopyTo
```
public void CopyTo // явно реализовали метод
ICollection.CopyTo() // неявно
```
Явная реализация нужна, если несколько интерфейсов реализуемых классом имеют одинаковую сигнатуру. Для разделения каждого случая можно использовать для различения
```
void Interface1.Run()
void Interface2.Run()
```
В явной реализации методы приватны и доступны только после приведения к соответствующему интерфейсу, т.е после приведения к определенному типу вызовется нужное поведение для разных интерфейсов

## Полиморфизм <a name="2.Полиморфизм"></a>
Механизм заставить объект одного типа неявно вести себя так же, как если бы относился к другому типу
Самое частое использование - единый интерфейс для разного типа классов (по поведению). Например, разные типы машин, но все должны уметь двигать колеса. Везде будет использоваться общий интерфейс , клиенту на надо знать деталей реализации.

## Адаптивные паттерны <a name="2.Адаптивныепаттерны"></a>
### Паттерн null-object <a name="3.Паттернnull"></a>
Защита от nullReferenceException
* Подход позволяет убрать проверки на null. Вводим два класса null И стандартный, каждый из которых реализует интерфейс с общей логикой, только в null в некоторых местах общая логика пропущена и не вызывает ошибки. Возвращает объект общего интерфейса и для вызывающего метода и мы не получаем ошибки. Подход частично заменен на T?, когда при null вызывается default(T), но не всегда удовлетворяем стандартным значениям

### Антипаттерн IsNull <a name="3.АнтипаттернIsNull"></a>
Добавление в интерфейс метода bool IsNUll.
Проблема: выход логики за пределы объектов, в вызывающем объекте появляются if. Проблема исправляется паттерном выше

### Адаптер паттерн <a name="3.Адаптерпаттерн"></a>
Паттерн позволяет предоставить клиенту экземпляр класса, имеющего зависимость от интерфейса, который класс не реализует. Класс адаптер соответствует определенному интерфейсу, реализует эти методы за счет делегирования разным методам другого объекта

#### Адаптер класса <a name="4.Адаптеркласса"></a>
Подкласс(наследник) класса, адаптируется под нужды клиентов. Минус - зависимость от реализации, видна реализация (белый ящик)
```
public class Adaptee
{
public void MethodB()
{
}
}

public class Adapter: Adaptee
{
public void MethodA()
{
MethodB()
}
}
```

#### Адаптер объекта <a name="4.Адаптеробъекта"></a>
Применение композиции, чтобы делегировать вызовы методов интерфейса, методом содержащегося в нем инкапсулированного объекта. Через конструктор внедрить другой класс. Внедренный класс выполняет все действия
```
static Interface dependency = new Adapter(new TargetClass())
```
### Паттерн стратегия <a name="3.стратегия"></a>
Паттерн демонстрирует разное повеление в зависимости от состояния объекта. Два класса реализуют один интерфейс. В вспомогательном классе на основе входного объекта вызывается нужная реализация. После во внешнем классе просто вызывается метод. Способ выбора стратегии - это дискуссионная деталь реализации

### Утиная типизация <a name="3.Утинаятипизация"></a>
Задействует "утиный тест". когда вижу птицу, которая плавает как утка, крякает как утка, то это утка.
**Правило** пока объект демонстрирует поведение определенного интерфейса, он должен трактоваться как этот интерфейс
Для c# CLR, если методы совпадают с интерфейсом(класса), то объект не может считаться реализующим интерфейс.

Поддержка утиной типизации в CLR работает в foreach. Если объект для foreach будет иметь GetEnumerator + возвращает объект, который имеет MoveNext и Current, тогда foreach пройдет.

### Примеси <a name="3.Примеси"></a>
**Примесь** - это класс, который содержит реализации множества других классов, не применяя наследование реализации
Расширяющие классы, как пример примеси
Минусы:
* сложность модульного тестирования
* не хранит состояние экземпляра, связанного с объектом (из-за static)

Re-motion Re-miх, как пример примеси
Библиотека позволяет генерировать новый тип на лету, который удовлетворяет требованиям всех интерфейсов, присутствующих в запрошенных примесях, причем каждый экземпляр данного типа в случае вызова метода интерфейса делегирует работу экземпляру примеси

### Текучие интерфейсы <a name="3.Текучие"></a>
Это интерфейс, который возвращает себя из одного (или больше) методов. Это позволяет связывать вызовы в цепочки. Улучшает читабельность и позволяет реализовывать конфигурации или конечные автоматы. Любая цепочка обращений к методам останавливается вызовом метода, который не является текучим

**Интерфейсы - катализаторы полиморфизма. Корень паттернов**

# Тестирование <a name="1.Тестирование"></a>
## Модульное тестирование <a name="2.Модульноетестирование"></a>
Составные части теста Паттерн AAA || Given When Then
* предусловие теста
* тестируемое действие
* утверждение о том, что ожидаемое поведение было продемонстрировано

**Организация(Given)** - инициализация нужного класса
**Действие(When)** - должно состоять из одного действия (метода, обращения к средству извлечения или установки свойства)
**Утверждение(Then)** - сравнение действительного и ожидаемого значения

## Разработка через тестирование <a name="2.Разработкачерезтестирование"></a>
Тест формулирует через утверждения то, что производственный код должен действовать определенным образом. В идеале сначала тесты, потому код(реализация)

### Красный зеленый рефакторинг <a name="3.Красныйзеленыйрефакторинг"></a>
* пишем отказывающий тест
* пишем метод, чтобы код проходил
* рефакторинг, если нужно
* помимо метода можно тестировать начальное состояние объекта (до выполнения метода)
* нужно думать есть ли еще тесты, способные сломать логику реализованную.
* необходимо действовать из заложенной логики "в жизни" к тесту, к модулям

### Тестовые дублеры <a name="3.Дублеры"></a>
* макеты(dummy) для создания списков параметров без специального поведения
* шпионы(spy) записывает вызовы, которые делались к методам. утверждения гарантируют, что метод был вызван
* заглушки(stub) заглушки для зависимостей, например, заглушки возвращают фиктивные данные
* подделки(fake) ручная имитация, близка я к реальному ответу(фейковый класс от коренного интерфейса). можно подсовывать как зависимость в нужный класс
* имитации(mock) тестовые дублеры зависимостей, имеющих непрямые команды.

**Проблема. Чрезмерное определение тестов** - если у класса много зависимостей и он зависим от них, получаем зависимость теста от реализации, и тестируется не определенное поведение, а реализация. Тест чрезмерен, когда тесту известна реализация, а не ожидаемое поведение
**Решение**
* тестировать только поведение. Лучший пример такого теста, тест основанный на состоянии. Если метод принимает данные и возвращает измененные данные, то для тестирования это черный ящик. Позже метод может быть подвергнут рефакторингу, не нарушая прохождения модульных тестов
* тестировать и писать мелкие тесты и реализации
* принять как факт связку теста и реализации и исправлять параллельно

**Обработку исключений нужно прокидывать на новый уровень. И для каждого уровня свой тип исключения, иначе может быть зависимость между уровнями**

В тесте можно отлавливать исключения через catch, если исключение происходит на другом уровне - проверить тип exception

### Настройка тестов <a name="3.Настройкатестов"></a>
Выделение ожиданий установок в специальные методы инициализации и завершения, которые вызываются соответственно в начале и конце каждого теста. Метод должен быть помечен [TestInitialize]

## Паттерны модульного тестирования <a name="2.модульное"></a>
* первостепенное внимание согласованности (все в одном стиле)
* разумное соотношение между тестовыми остнастками и классами (1 тестовый класс - 1 класс)
* именование тестируемой системы (понятные имена свойств, методов, классов)

### Паттерн строитель <a name="3.строитель"></a>
Порождающий паттерн (полезен для инкапсуляции и абстрагирования создания объектов). Отличается от фабрики методом настройки объекта
```
interface IBuilder {void buildPart();}

class ConcreteBuilder : IBuilder {
void buildPart()
Product create()
}
```
Можно использовать этот паттерн для создания цепочки инструкций. Каждый из методов в классе-сборке для тестирования, реализующем строитель,возвращает реализацию IBuilder, т.е this. Поэтому в итоговом модульном тесте можно конфигурировать проверки. Порождает продукты для любых или всех поддерживаемых объектов
```
var unitclass = BuilderClass();
unitClass
.setup()
.adddatf()
.result()
```
## TDD (testing driving development) <a name="2.TDD"></a>
**Идеальное** разработчики подходят к клавиатуре без обдумывания решения. Вместо этого готовят реализацию по мере движения. Движение направляется написанием отказывающих контрольных тестов.
**Прагматичное** просто пишем тесты по придуманной в голове реализации(или уже готовой) **TFD**(test first development)

**TDD**
* пишем неработающий тест (без целевых работающих методов) - отталкиваясь от задачи
* чиним тест (реализованные методы)
* проводим рефакторинг, если необходим (новый абстракции, декомпозиция, извлечение методов)
* создать класс
* написать новый тест

**TFD**
Все уже спроектировано на бумаге(в голове). Поведение нужно просто реализовать

**TDD порождает достаточный проект**
**TDD порождает любой проект, который возникает в голове разработчика**

### Добавочное тестирование <a name="3.Добавочное"></a>
**Пирамида тестирования**

```
                      /\  РУЧНОЕ
                    /    \
                  / ______ \
                / ПРИЕМОЧНЫЕ \ автотесты, повторение действий пользователей (на стенде) 
              /  _________     \
            /   ИНТЕГРАЦИОННЫЕ   \ тесты API интерфейса, где служба, как черный ящик
          / _________________      \
        /          МОДУЛЬНЫЕ         \
        --------------------------  
```        
Каждый уровень пирамиды указывает, что один ярус должен быть меньше другого

**Антипаттерны**
* песочные часы МОДУЛЬНЫЕ - интеграционные(мало) - ПРИЕМОЧНЫЕ
* рожок модульные - интеграционные - ПРИЕМОЧНЫЕ - признак спутанного нетестируемого кода, поэтому покрыты внешними

### Тестирование для профилактики проблем <a name="3.Профилактика"></a>
Доверие - в нем ценность тестов
Неудача - лучший учитель
Нужно сместить внимание со средней наработки на отказ (Mein Tain Before failure) в сторону среднего времени восстановления (Mein Time ToRecovery). MTTR - не только допускает отказ, но и готов к нему

# Рефакторинг <a name="1.Рефакторинг"></a>
**Рефаторинг** - это процесс улучшения текущего кода, рефакторинг меняет организацию кода, а не его исход
* замена магических чисел на константу (понятное имя). Значение 0 и 1 необязательно заменять
* замена условного выражения полиморфизмом (switch можно заменить состоянием, стратегией, и т.д), ну или наследованием
* замена конструктора фабричным методом
Через Switch в методе базового класса Create(Type type) - выбираем нужную реализацию через new. Фабричный метод статический. Запрет классам создавать экземпляры классов
* замена логики конструктора фабричным классом
* сделать фабрику с методом create
* внедрим фабрику в нужный класс
* передаем фабрике тип нужного экземпляра
* замена реализации New в методе фабрики через рефлексию и создание экземпляра на основании названия. Activator.CreateInstance. Минус - должны быть выполнены соглашения
* плохой код "отказ от наследства" - стандартное поведение реализует родительский класс. Лучше создать специальный класс без поведения.
* замена наследования делегированием
Передача полномочий выходящих за пределы класса другим классам, в внутрь себя внедрять через конструктор

## Из рефакторинга к перепроектирвоанию <a name="2.Перепроектирвоаниe"></a>
**Перепроектирование** - это рефаторинг с учетом новых требований и функционала. В итоге перепроектирования будут меняться и модульные тесты. Сначала меняет тесты, котом код

### Превращение унаследованного кода в адаптивный <a name="3.Превращение"></a>
Унаследованный код (легаси) - это код без тестов. Как работать с таким кодом.
* тесты характеристики. Цель сбор данных об особенностях выполнения кода(журналы). Журналы - это основа для утверждения тестов
* золотой мастер - сравнивает результаты тестов с тем, что выдают характеристики. Обрабатывает выходной файл характеристик и применяет их в качестве утверждений. Файл характеристик может сгенерировать и как консольное выражение, и как подробные логи с выходными и входными параметрами

# SOLID <a name="1.SOLID"></a>
## Принцип единичной ответственности(SRP) <a name="2.SRP"></a>
Этапы разделения большого класса (с многими обязанностями)
* разделение на методы меньших размеров, каждый из которых основан на единичной обязанности
* делегирование внутри метода. Рефакторинг для ясности обязанностей других методов

### Рефакторинг для абстрагирования <a name="3.Рефакторингдляабстрагирования"></a>
* выделение интерфейсов для общей цели
* у одного класса не должно быть прямых зависимостей от реализации класса, а вместо этого нужно работать с интерфейсами
* **класс, который будет обрабатывать все вызовы от интерфейсов тоже будет иметь одну обязанность - изолирование процесса**
* моделирование процесса вокруг одной сущности

Все интерфейсы должны находиться в одной сборке, а значит будет существовать клиентская сборка и сборка реализаций, которые не будут ссылаться друг на друга

Помимо стандартного IClass и Class - реализующий интерфейс, можно назвать класс BookClass, как бы указывая специфику реализации

Все классы, которые зависят от какой-то сборки(внутренней) или стали зависеть - должны быть выделены в отдельную сборку.

Процесс такого рефакторнга рекурсивен. В процессе инспектирования класса устанавливаются обязанности и выделяются, пока обязанность не останется одна.

**В процессе рефакторинга золотой тест должен проходить**

### SPR и декоратор <a name="3.декоратор"></a>
Предпосылка использования: каждый класс декоратора удовлетворяет контракту типа и принимает один или более типов в качестве параметров конструктора
```
interface IClass{
void Doing ();
}

class Class1: ICLass {
condtructor(IClass class) {}
void Doing() {
action();
class.Doing()
}
}
```

### SPR и компоновщик <a name="3.компоновщик"></a>
Это специализация паттерна Декоратор и одно из частых употреблений паттерна декоратор.
**цель паттерна** трактовать множество экземпляров реализации интерфейса, как если бы они были одним экземпляром
```
interface IClass {
void Doing();
}
class Class1: IClass {Doing();}
class Class2: IClass {Doing();}

class CompositeComponent: IClass {
public CompositeComponent() {
children = new List()
}
void Add(Iclass class) {
children.add(class)
}
void Remove(Iclass class) {
children.Remove(class)
}

void Doing() {
foreach (var child in children){
child.Doing()
}
}
}

class Program {
void Main() {
var composite = new CompositeComponent();
composite.Add(new Class1())
composite.Add(new Class2())
composite.Doing()
}
}
```
### Предикатный декоратор <a name="3.Предикатный"></a>
Конструкция для сокрытия условного выполнения кода от клиентов. Условное выражение выносится в отдельный интерфейс и внедряется через конструктор. Остается только вызвать метод (проверка, например)

### Разветвляющий декоратор <a name="3.Разветвляющий"></a>
Это возможность использовать разные варианты выполнения (например для true false) и проверки для разных веток. Два внедренных алгоритма для двух условий

### Ленивые декораторы <a name="3.Ленивые"></a>
через конструктор внедряется Lazy и возвращает при выполнении действия doing(). Это обертка вокруг компонента IClass/

### Регистрирующие декораторы <a name="3.Регистрирующие"></a>
Использование обертки вокруг исходного интерфейса для записи в логи. Передача исходного класса через конструктор

### Профилирующие декораторы <a name="3.Профилирующие"></a>
Внедряем внутрь через конструктор экземпляр интегрирующий и обернуть таймером. Таймер можно вынести в отдельный класс.

### Декорирование свойств и событий <a name="3.Декорирование"></a>
Вызов внутри свойства исходного класса значения внедренного класса

## Принцип открытости-закрытости (OCP) <a name="2.OCP"></a>
Первое определение(Мейер): сущности открыты для расширения, но закрыты для модификации
Определение Фаулера: определение модулей соответствующих принципам OCP
* **открыто для расширения** - поведение может быть расширено. При изменении требований модуль может быть расширен новыми линиями поведения, удовлетворяющие необходимым изменениям. Иначе, возможность добавить новое то, что делает модуль
* **закрыты для модификации** - расширение модуля не ведет к изменениями в исходном коде или двоичном коде модуля. Конечная версия модуля остается нетронутой (dll, jar)

Пункт закрыты для модификации не работает в двух случаях
* исправление дефектов (если про чистоту - создается новый класс)
* осведомленность клиентов (если клиентам не нужно менять код, то менять, модифицировать модуль можно)

### Открыты для расширения <a name="3.Открытыдлярасширения"></a>
Варианты точек расширения:
* код без точек расширения. если class1 зависит от class2 и появляется новое требование, в результате которых нужно внести изменения в class2. не имея возможности поменять class1, создается class3, а значит в class1 меняем только ссылку на используемый метод(если разрешаем вносить изменения без изменения клиентов,то можно менять). Это получается из-за сильной связности

### Виртуальные методы <a name="3.Виртуальныеметоды"></a>
Если метод в class2 является виртуальным, то он открыт для расширения через наследование реализации. Тогда class1 в изменении может не нуждаться, т.к можно создать в классе class 2 подкласс и изменить в нем необходимый метод. можно снабдить class1 новой версией class2 клиента и подсунуть реализацию подкласса.
**Минусы** имеется доступ к базовому классу class1.method1(), но изменять отдельные строчки метода нельзя. Код вызывается целиком с добавлением новой функциональности до или после вызова, либо реализуется заново.

**Подклассы могут обращаться только к тем членам базового класса, которые помечены как protected**

### Абстрактные методы <a name="3.Абстрактныеметоды"></a>
Class2 абстрактный класс. Клиент зависит от абстрактного класса, поэтому может вызывать любой из реализующих классов. class4(старая реализация) или class5(новая). Помогает в этом шаблонный метод: моделируется алгоритм, шаги которого допускают настройку благодаря делегированию абстрактным методам.

### Интерфейс <a name="3.Интерфейс"></a>
Наследование от класса заменяется делегированием интерфейсу. При наследовании реализации все подклассы - клиенты абстрактного класса, что мешает модификации. Значит клиенты всегда нуждаются в изменении реализации. Изменение в одном звене иерархии влияет на всех участников. Интерфейсы можно декорировать, легче строить композицию.

**Проектируйте наследование, если оно точка расширения или запретите его**
**sealed - запрет на наследование**

## Закрытость к модификации <a name="2.Закрытостькмодификации"></a>
Принцип для помощи в поиске границ принципа открытости-закрытости
* идентифицируйте места предсказуемых изменений и создайте вокруг них стабильный интерфейс
* **предсказуемые изменения**: необходимо выяснить у заказчика о возможных изменениях проектируемого и реализуемого функционала.
* **стабильный интерфейс**: вероятность и частота изменения интерфейса должна быть минимальной, иначе придется вносить изменения во все клиенты
* только достаточная степень адаптации.
* избегать божественных объектов
* Точка расширения, просто, как точка расширения. Этот пункт о разумности повсеместного выделения интерфейсов и поиск компромиссов
* предсказуемые изменения (добавление предположительных методов расширения) или гипотетическое обобщение (избегать попыток придумывания, что будет делать класс). Истина где-то посередине

# Принцип подстановки лисков (LSP liskovs ubstitution principe) <a name="1.LSP"></a>
Это набор указаний для создания иерархии наследования, в которых клиент может надежно пользоваться любым классом или подклассом.
* если не соблюдаются правила, то расширение иерархии классов может повлечь изменения в любом клиенте базового класса или интерфейса

Определение если S подтип Т, тогда объекты типа T могут быть заменены объектами типа S? yt yfheifz hf,jns ghjuhfvvs
**Базовый тип** - это тип, на который клиенты имеют ссылку
**Подтип** - любое возможное семейство классов, унаследованное от базового
**Контекст** - способ взаимодействия клиента с подтипом

**Правила LSP**
* предусловия не могут быть усилены в подтипах
* постусловия не могут быть ослаблены в подтипе
* инварианты супертипа (условия, которые должны оставаться истинными) должны быть сохранены в подтипе

**Правила вариантности**(вариантность аргументов и выходных типов)
* в подтипе должна существовать контрвариантность аргументов методов
* в подтипе должна существовать ковариантность возвращаемых типов
* в подтипе нельзя генерировать новые исключения, если они не принадлежат существующей иерархии исключений

Программисты должны программировать на основе интерфейсов(программировать на основе контрактов)
Со стороны сигнатуры методов контракты должны иметь понятные имена, понятные параметры. Если на парметр накладываются условия(например > 0) тогда в методе должно существовать предусловие

**Предусловия** - можно реализовать за счет замкнутой конструкции в начале метода и вернуть исключение в случае ошибки. Предусловие должно быть очевидным и зависеть от того, что передал клиент.

**Постусловия** - проверяют остался ли объект после выполнения метода в допустимом состоянии. Проверка в конце метода.

**Инварианты данных** - предикат, который остается истинным для всего времени жизни объекта. Он становится истинным в момент конструирования объекта и неизменяем до конца жизни. Например, установка значения через конструктор.

**Предусловия не могут быть усилены**
Когда в подклассе переопределяется существующий метод, который содержит предусловия, никогда нельзя усиливать предусловия. Это может нарушить работу клиентов, которые существуют с текущим условием. Например, в дочернем классе появляется правило для параметра, что он не должен быть null. Мы переопределяем метод и в не записываем условие, получаем: для базового класса можно передавать null, а в дочерний нет. Клиент не должен быть осведомлен, какую из реализаций он использует

**Постусловия не могут быть ослаблены**
Та же история, но клиент уже зависит от результата и может ожидать одного поведения, а получить другое (например не ожидает Null, а пришел null)

**Инварианты должны быть сохранены**
Инварианты должны быть неизменны во всей иерархии. Вариант использования: наследуется в конструкторе через base(value) -> расширяем класс свойством, имеющим доступ к переменной. Можно попробовать предохранить инвариант, запретив изменять через свойство в исходном классе.

**Контракты кода**
* предусловия через Contract.Requires
* постусловия Contract.Ensures - принимает предикат, который должен быть истинным
* инварианты вместо условия в свойстве

Перехват исключения не должен делать клиент, т.к это значит, что они могут восстановиться после перехвата

## Ковариантность и контрвариантность <a name="2."></a>
**Вариантность** - ожидаемое поведение подтипов и иерархии классов.
ко - "C" взаимосвязь друг с другом
контр - "против" подтипы идут друг против друга

**Ковариантность**
Полиморфизм - это способность типа трактоваться так, если бы он был экземпляром супертипа
В C# любой тип принимающий
```
SuperType {field1, field2, Method1(), Method2()}
```
способен принять
```
SubType {field1, field2, field3, Method1(), Method2(), Method3()}
```
без приведения, требуемого со стороны клиента или службы.
Для обобщенных типов ICovariant, поэтому если нужен супертип, можно подсунуть SubType - это совместное функционирование полиморфизма и ковариантности.

При отсутствии обобщенных типов не поддерживается ковариантность для возвращаемых типов метода.

**Проверить вернуть override не тип, который возвращает в virtual**

**Контрвариантность**
Контрвариантность касается типов на вход, тогда как ковариантность на выход IContrVariant.
Примером служит обратная иерархия наследования.
```IContrVariant -> над -> IContrVariant```
Без контрвариантности: метод ```Equals(User1 user1, User2 user2)``` не может быть выполнен при вызове ```Equals(Entity1 user1, Entity2 user2)```. Никакого преобразования Entity в User не может, так как User это подтип, но подключая контрвариантность (in) мы может инвертировать иерархию.

**Инвариантные типы(не вариантные)**
Нет возможности манипулировать с преобразованием типов
Вернемся к принципам лисков
* контрвариантность аргументов
* ковариантность возвращаемых типов

новые исключения не разрешены: исключения нужны для определения ошибки от обработки. Обработка ошибок и их сообщения деляются в разных классах с разными целями и контекстами

любой код может генерировать исключения, перехватывать и делегировать.
Правило:
* перехватываем там, где можно сделать что-то значимое(откат транзакции, отправка сообщения об ошибке)
* нежелательно перехватывать исключение общего типа exception или ничего не делать
* нежелательно перехватывать и осмыслять исключения всех типов. Можно улучшить дело созданием собственных исключений. Но это препятствует единственному блоку catch и клиенту надо знать обо всех типах исключений, но нельзя прибегать к Exception. Вместо этого можно создать базовый класс исключения с необходимой информацией об ошибке.

**Любое нарушение LSP - технический долг**

# Разделение интерфейса <a name="1.Разделениеинтерфейса"></a>
Все члены интерфейса должны быть реализованы, но если каждый клиент не должен этого делать, не нужно навязывать эту зависимость
Рассмотрим пример сервиса с GRUD операциями(обобщенный интерфейс и реализация).
* при использовании декораторов, например, нужно проверить согласие(или кэшировать) в какой-то операции, а все остальные методы вызываются "сквозным методом"(просто вызываются). Имеет смысл выделить сложную операцию в отдельный интерфейс
* объединить отдельный интерфейс с операцией сохранения(получения)

**Декодирование множества интерфейсов**
Необходимо использовать паттерн адаптер и декоратор, чтобы создавать множество декораторов, сводя к минимуму объем кода. Одиночный класс может быть реализацией для множества декораторов, но если контекст декоратора используется совместно(одно действие в каждой реализации "функциональное")

**Построение клиентов**
* Множество реализаций, множество экземпляров. Один клиент зависит от нескольких обобщенных интерфейсов. Можно сделать этот клиент(контроллер, хендлер) обобщенным, если это необходимо(например использоваться только одна базовая сущность)
* единственная реализация, единственный экземпляр.
Объединить все интерфейсы в один класс. Даже объединив их есть плюсы: контроллер будет создавать реализацию класса, не зная, что внутри. контроллер будет строиться как new controller(crud1, crud2, crud3). Это антипаттерн каша из интерфейсов. Объединение всех интерфейсов сводит на нет, все преимущества интерфейсов.

**Разделение интерфейсов**
* потребность клиента, клиент создает только то, что нужно
* функциональность. Защитить части от неправильного использования, например для CQR
* авторизация. Разделения для авторизованного и неавторизованного пользователя
* архитектурная потребность. Например, определенные требования предъявляет CQRS(чтение -mongo, запись - sql store)
* интервейсы часто выделяют как крупные фасады, за которыми крупные подсистемы, которые в последствии теряют способность к адаптации

# Инверсия зависимостей <a name="1.Инверсиязависимостей"></a>
Принципы инверсии зависимостей
* высокоуровневые модули не должны зависеть от низкоуровеных
* модули обоих видов должны зависеть от абстракций
* абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций

**Структурирование зависимостей** - разделение интерфейсов и классов по проектам

**Антипаттерн антураж** - просим одну вещь, получаем все сопутствующее. Все реализации и интерфейсы в одной сборке

**Паттерн лестница** - реализации и интерфейсы в разных сборках. Интерфейсы не должны иметь внешних зависимостей. Необходимо избегать ссылок на инфраструктурные сущности. Можно попробовать написать свой интерфейс, скрывающий стороннюю зависимость за основной зависимостью (Адаптер)

# Применение адаптивного кода <a name="1.Применение"></a>
## Внедрение зависимостей <a name="2.Внедрениезависимостей"></a>
Минусы без внедрения:
* сложность модульного тестирования
* сложность понимания того, какие зависимости есть внутри
* отсутствие гибкости в предоставлении альтернативных реализаций
* если класс внутри создает экземпляры других классов, то нельзя повлиять извне на функционирование, изменение поведения.

Классы замещаемы, если их свойства и методы помечены как virtual

Черный ящик зависимостей

**Внедрение зависимостей для бедняков**????
Для функционирования паттерн не требует внешних зависимостей: построение объектного графа заблаговременно. В точке входа в приложение определить контроллер(например) и передать созданные экземпляры объектов через new.
```
partial class App: Application {
private void OnApplicationStartup(object sender, StartupEventArgs e)
{
var controller = new TaskController(new class1(), new class2() )
MainWindow = new TaskListView(controller);
controller.OnLoad();
}
}
```
Минусы: разрастание в момент разрастания графа
Плюс: очевидность построенного графа

**Внедрение через методы**
Плюс: единственный метод требует зависимость
Минус: клиентам нужно знать и меняться в зависимости от новой зависимости

**Внедрение через свойства**
* можно без последствий для клиента менять свойства
* если добавить сложную логику, клиент не поймет, что поменялось(искусственное требование)

## Инверсия управления <a name="2.Инверсияуправления"></a>
Больше всего известна как IOC контейнеры при связи реализации и интерфейса.
При начальной загрузке всегда ссылается на сборку реализаций.

## Паттерн RRR(Register, Resolve, Release) <a name="2.RRR"></a>
Register - при инициализации приложения
Resolve - при использовании. Обязанность делать Resolve - это инфраструктурная задача. Во время выполнения приложения(при старте) корень композиции.
Realease - освобождение ресурсов

Большинство контейнеров реализуют IDisposable, т.е лучше делать Dispose

## Императивная и декларативная регистрация <a name="2.регистрация"></a>
* Императивная (в коде) + легко читать, проверка при компиляции
- привязка к реализации на этапе компиляции
* Декларативная(в конфигурационном файле) + динамическая привязка
- сложность, многословность, возможность ошибки
- нет возможности применить фабрики внедрения

## Время жизни <a name="2.Времяжизни"></a>
Это время уничтожения в определенный момент

* Объект, который внедрен в конструктор другого объекта имеет то его время жизни, что и тот куда внедрен.
* Если класс получает зависимость через конструктор, то ее не нужно освобождать
* если сделать регистрировать с new или через фабрику, то зависимость будет существовать в течение жизни приложения

**Фабрика полномочий** - Способ замены ручного создания объектов делегированием выполнения работы классу, который предназначен для такой цели.

**Ответственный владелец** - использование вместо using для освобождения конструкции try finally, где освободить ресурсы можно в блоке finally

**Изолированная фабрика** - позволяет детерминированным образом освобождать сложные объектные графы. Нужен, если целевой класс не реализует IDisposable: применение паттернов ответственный владелец и изолированная фабрика принимает лямбда-функцию, получающую продукт фабрики, как параметр. Преимущество в том, что время жизни продукта фабрики привязывается к области действия лямбда функции.

**Корень композиции** - только тут информация о внедрении зависимостей. Корень распознавания - тип, образующий корень абстрактного графа.

**Контроллер можно создавать через фабрику контроллеров**

**Соглашение по конфигурации**
Инструкции контейнеру, как отображать интерфейсы при реализации. Инструкции формируют входные даннык для контейнера вместо регистрации. Например правило IBookService - регистрируем автоматом BookService. Необходимо определить правило, по которому сопоставлять и регистрировать

## Антипаттерны внедрения зависимостей <a name="2.Антипаттерны"></a>
**"Сервис-локатор"**
* Концепция внешнего контейнера подразумевает утечку данных о существовании контейнера. Локатор служб должен применяться только в корне композиции
* локатор служб заставляет думать, что в классе нет зависимостей, но они есть.
* сложность тестирования
* Нельзя узнать, какие зависимости есть у класса, так как эти зависимости внутри реализации. Исчезает гибкость. * Единственное место для локатора WinForm и WPF, т.к это лучше чем не внедрять зависимости

**Внедрение контейнера**
Это внедрение контейнера непосредственно в класс через конструктор
* слишком много обязанностей
* ссылка на сборку контейнера

**Незаконное внедрение**
Внутри конструктора создана зависимость в обход DI. Получаем потенциальный антураж
**Иногда можно делать приватные методы для тестирования**

# Связность, сцепление и соразвитие <a name="2.Связность"></a>
Качества хорошего кода:
* высокое сцепление
* низкая связность

**Связность** - сила взаимной зависимости между програничными элементами(методы, сборки, классы, компоненты). Если элементы слабо связаны то, они могут независимо меняться.

**Сцепление** - сила контекстного отношения между программными элементами: методами в классе, классами в модуле, модули в сборке, между подсистемами. Если два класса в модуле, но между ними нет ссылки, то у них слабое сцепление, если имеют связь, то сильное сцепление.

**Допустимые отношения между классами**
* один уровень архитектуры приложения
* относятся к ограниченному контексту
* классы, относящиеся к разным архитектурным уровням, должны быть разделены как минимум модулями
* классы относящиеся к разным ограниченным контекстам, должны быть разделены как минимум границей модуля

Нарушение принципов - признак плохого кода

**Соразвитие** - сложность зависимостей в системе(метрика установления качества кода)
Уровни соразвития от худших к лучшим:
имя->тип->смысл->алгоритм->позиция(порядок выполнения)->синхронизация->значение->идентичность

* **имя** минимум для существования зависимости. Коду должно быть известно имя переменной для использования
* **тип** для взаимодействия с объектом нужно знать его тип. Например, если изменится тип класса, то нужно менять вызывающий код
* **смысл** интерпретация специальныx значений в коде.
* **алгоритм** согласие от клиента и службы для достижения согласия относительно шагов, используемых в алгоритме
* **позиция** порядок следования параметров. Хорошо спроектированный класс должен упрощать
* **синхронизация** временная зависимость между кодом. например, многопоточный код
* **значение** когда специальное значение зависит от двух фрагментов кода, то они имеют соразвитие значения
* **идентичность** - если два фрагмента зависят от наличия специфического экземпляра сущности

**Правила соразвития**
Оценивается в сочетании с местонахождением компонентов. Если клиент и служба в одном проекте - поддержание соразвития менее важно. Если разделены границами специализированных служб, то нужно снижать соразвитие между ними. Например, при обращении к сервису HTTP в WCF, то обновление порядка параметров запроса требует обновления клиентов(клиент создан)

**Неофициальное соразвитие**
Можно ввести уровень между именем и типом(интерфес), ведь при зависимости от интерфейса не нужно знать тип

**Статическое и динамическое соразвитие**: первые пять типов статические, остальные - динамические. Статическое соразвитие может быть определено при чтении кода. Статическое соразвитие слабее динамического, так как его легче распознать или улучшить.
