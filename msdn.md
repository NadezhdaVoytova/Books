# Сборка мусора

* управляет выделением памяти (CLR): 
	* При создании объекта среда CLR выделяет память для объекта из управляемой кучи. 
	* Пока в управляемой куче есть доступное адресное пространство
* управляет освобождением памяти:
	* определяет наилучшее время для сбора
	* выполняет сбор, 
* выполняет сборку:
	* проверяет наличие неиспользуемых объектов
	* выполняет операции для освобождения памяти.
	
## Преимущества
* не нужно освобождать память вручную.
* эффективное выделение памяти для объектов в управляемой куче.
* уничтожает неиспользуемые объекты
* очищает память и сохраняет память доступной для будущих распределений. 
* управляемые объекты автоматически получают чистое содержимое
* обеспечивает безопасность памяти, гарантируя, что объект не сможет использовать содержимое другого объекта.
		
## Основы работы с памятью
* Каждый процесс имеет свое собственное отдельное виртуальное адресное пространство. 
* Все процессы на одном компьютере совместно используют одну и ту же физическую память и один файл подкачки, если он есть.
* По умолчанию на 32-разрядных компьютерах каждому процессу выделяется 2 Гбайт виртуального адресного пространства в пользовательском режиме.
* Разработчики приложений работают только с виртуальным адресным пространством и никогда не управляют физической памятью напрямую.
	* Сборщик мусора выделяет  и освобождает виртуальную память для разработчика в управляемой куче.
	* При написании машинного кода для работы с виртуальным адресным пространством используются функции Windows. 
	* Три состояния виртуальной памяти:
		* **Free**				Ссылки на блок памяти отсутствуют, и он доступен для выделения.
		* **Зарезервированное**	Блок памяти доступен для использования разработчиком и не может использоваться на выделение. Сохранение данных в этот блок памяти невозможно, пока он не будет выделен.
		* **Фиксация**			Блок памяти назначен физическому хранилищу.
			
**Фрагментированное виртуальное адресное пространство** - находятся свободные блоки(пропуски). 

### Этапы выделения виртуальной памяти:
* диспетчер виртуальной памяти  ищет один свободный блок достаточного размера для выполнения этого запроса на выделение.
* пространство необходимое для выделения должно находиться в одном адресном блоке
* память закончивается, если недостаточно виртуального(или физического) адресного простанства
* используется файл покачки если нехватка памяти невелика
* первая нехватка физической памяти ОС
	* освобождает пространство в физической памяти для хранения данных 
	* производит резервное копирование некоторых данных, находящихся в физической памяти, в файл подкачки. 
	* данные не выгружаются, пока в этом нет необходимости
	
	
### Управляемая куча
* **Управляемой куча** - сегмент памяти для хранения объектов и управления ими. 
* Эта память называется управляемой кучей в отличие от собственной кучи операционной системы.
* Управляемая куча создается для каждого управляемого процесса. 
* Все потоки в процессе выделяют память для объектов в одной и той же куче.
	
### Выделение памяти 
При инициализации нового процесса  среда выполнения резервирует непрерывную область адресного пространства.

**Управляемая куча** - зарезервированное адресное пространство:
* куча содержит указатель адреса, с которого будет выделена память для следующего объекта в куче. 
* этот указатель устанавливается в базовый адрес управляемой кучи. 

* Все ссылочные типы размещаются в управляемой куче. 
	* При создании первого ссылочного типа, память выделяется, начиная с базового адреса управляемой кучи. 
	* При создании следующего объекта выделяетcя  память в адресном пространстве, непосредственно следующем за первым объектом.
* Выделение памяти из управляемой кучи происходит быстрее, чем неуправляемое выделение памяти, т.к выделяется последовательно (быстро, как выделение памяти из стека), т.к выделяемые последовательно новые объекты располагаются в управляемой куче непрерывно, приложение может быстро получать доступ к ним.	
	
### Освобождение памяти
Механизм оптимизации сборщика мусора определяет наилучшее время для выполнения сбора, основываясь на произведенных выделениях памяти. 

#### Очистка памяти сборщиком мусора
* освобождает память, выделенную для неиспользуемых объектов
* определяет, какие объекты больше не используются, анализируя **корни приложения**. 

**Корни приложения** содержат статические поля, локальные переменные и параметры стека потока, а также регистры процессора. 
Каждый корень либо 
* ссылается на объект, находящийся в управляемой куче, либо имеет значение NULL.  
* проверяет корни приложения и при этом создает граф, содержащий все объекты, к которым можно получить доступ из этих корней.
* освобождает память для объектов вне графа 
* использует функцию копирования памяти для уплотнения достижимых объектов в памяти, освобождая блоки адресного пространства, выделенные под недостижимые объекты. 
* вносит необходимые поправки в указатель, чтобы корни приложения указывали на новые расположения объектов.
* устанавливает указатель управляемой кучи в положение после последнего достижимого объекта.

Память уплотняется, только если при очистке обнаруживается значительное число недостижимых объектов.
Для повышения производительности среда выполнения выделяет память для больших объектов в отдельной куче. 
Сборщик мусора автоматически освобождает память, выделенную для больших объектов. 
				
#### Условия для сборки мусора
* Недостаточно физической памяти в системе. 
* Объем памяти, используемой объектами, выделенными в управляемой куче, превышает допустимый порог. Этот порог непрерывно корректируется во время выполнения процесса.
* вызывается метод GC.Collecе (для тестирования и отладки)
				

### Поколения
Алгоритм сборки мусора учитывает следующее:
* Уплотнять память для части управляемой кучи быстрее, чем для всей кучи.
* У новых объектов время жизни меньше, а старых больше.
* Новые объекты теснее связаны друг с другом, и приложение обращается к ним приблизительно в одно и то же время.

Сборка мусора в основном сводится к уничтожению короткоживущих объектов с небольшим временем жизни. 
Для оптимизации производительности сборщика мусора управляемая куча делится на **три поколения: 0, 1 -(эфемерные поколения) и 2.**  

Поколения обеспечивают логическое представление кучи сборки мусора

#### Поколение 0. 
Это самое молодое поколение содержит короткоживущие объекты. 
* Примером короткоживущего объекта является временная переменная. 
* Сборка мусора чаще всего выполняется в этом поколении.
* Вновь распределенные объекты образуют новое поколение объектов и неявно являются сборками поколения 0.
* Большинство объектов уничтожается при сборке мусора для поколения 0 и не доживает до следующего поколения.

#### Поколение 1.
Это поколение содержит коротко живущие объекты и служит буфером между короткоживущими и долгоживущими объектами.
* После сборки мусора в поколении 0, отсавшиеся объекты перемещаются в поколение 1
* Если сборка поколения 0 не освобождает достаточно памяти, то преходит к сборке поколения 1 и 2
* Объекты в поколении 1, оставшиеся после сборок, продвигаются в поколение 2.
* служит буфером между областями молодых объектов и областями долгоживущих объектов.

#### Поколение 2. 
Это поколение содержит долгоживущие объекты. 
Примером долгоживущих объектов служит объект в серверном приложении, содержащий статические данные, которые существуют в течение длительности процесса.
* Объекты в поколении 2, оставшиеся после сборки, остаются в поколении 2.
* могут занимать несколько сегментов

**Пороговое значение** является свойством поколения.
Пороговое значение для поколения задается, когда сборщик мусора распределяет в него объекты. 
* При превышении порогового значения для этого поколения происходит сборка мусора. 
* При распределении маленьких или больших объектов учитываются пороговые значения для поколения 0, 1, 2 или кучи больших объектов. 
* Динамически настраиваются в ходе работы программы.
		
				
## Процесс сборки мусора
Сборка мусора состоит из следующих этапов:
* **Этап маркировки** - поиск всех используемых объектов и составляющий их перечень.
* **Этап перемещения** - обновляет ссылки на сжимаемые объекты.
* **Этап сжатия** - освобождает пространство, занятое неиспользуемыми объектами и сжимающий выжившие объекты. 
* пережившие сборку мусора, перемещаются к более старому концу сегмента.

Как правило, куча больших объектов (LOH) не сжимается, так как копирование больших объектов приводит к снижению производительности. 

```LargeObjectHeapCompactionMode``` для сжатия большой кучи объектов по требованию. 

Проверка являются ли объекты используемыми:
* Корни стека. Переменные стека, предоставленные JIT-компилятором и средством обхода стека.
* Дескрипторы сборки мусора. Дескрипторы, которые указывают на управляемые объекты и которые могут быть выделены пользовательским кодом или средой CLR.
* Статические данные. Статические объекты в доменах приложений, которые могут ссылаться на другие объекты. Каждый домен приложения следит за своими статическими объектами.
* Перед запуском сборки мусора все управляемые потоки, кроме потока, запустившего сборку мусора, приостанавливаются.
		
### Неуправляемые ресурсы
* Для большинства объектов управление памяти происходит автоматически. 
* Для неуправляемых ресурсов требуется явная очистка. 
* 
**Неуправляемые ресурсы** - объекты, образующие упаковку для ресурсов операционной системы(дескриптор файлов, дескриптор окна или сетевое подключение) сборщик мусора не может освобождать ресурсы, но знает о времени жизни объектов, в которые упакованы эти русурсы

#### Рекомендации	
* При создании объекта, инкапсулирующего неуправляемый ресурс, рекомендуется предоставлять необходимый код для очистки неуправляемого ресурса в общем методе Dispose. 
* 	позволит явно освобождать память при завершении работы с объектом.
* Нужно предусмотреть способ освобождения неуправляемых ресурсов в случае без Dispose. 
* Переопредлить Finalize
		
### Сборка мусора рабочей станции и сборка мусора сервера
Сборщик мусора является самонастраивающимся и может работать в широком диапазоне сценариев.

Среда CLR предоставляет следующие виды сборки мусора.
* Сборка мусора на рабочей станции выполняется для клиентских приложений. 
  * Это вариант по умолчанию для автономных приложений. Для размещенных приложений, например размещаемых в ASP.NET, 
  * разновидность сборки мусора по умолчанию определяется узлом.
  * Сборка мусора рабочей станции может быть **параллельной** или **непараллельной**.
	* Параллельная (или фоновая) сборка мусора позволяет управляемым потокам продолжать операции во время этого процесса. 
	* В 4 и более поздних версиях фоновая сборка мусора заменяет параллельную сборку мусора.
* Сборка мусора сервера, предназначенная для серверных приложений, которым нужны высокое быстродействие и масштабируемость.
	* В 4.5, Core серверная сборка мусора может быть непараллельной или фоновой.
	* В 4 и более ранних версиях серверная сборка мусора является непараллельной.
					
#### Сборщик мусора рабочей станции
* Сборка выполняется для пользовательского потока, запустившего сборку мусора с тем же приоритетом
* Сборщик мусора для потока с обычным приоритетом должен конкурировать с другими потоками за время процессора. 
* Для компьютера с одним процессором всегда используется сборка мусора рабочей станции
			
#### Сборщик мусора сервера
* Сборка выполняется в нескольких выделенных потоках, выполняемых с приоритетом THREAD_PRIORITY_HIGHEST
* Для каждого процессора предоставляется куча и выделенный поток, выполняющий сборку мусора, и сборка куч выполняется одновременно.
* Каждая куча содержит кучу небольших объектов и кучу больших объектов, и все кучи доступны из пользовательского кода.
* Объекты из различных куч могут ссылаться друг на друга.
* В сборке мусора сервера часто используются сегменты большего размера.
* Сборка мусора сервера может оказаться ресурсоемкой операцией. 
* Выделения памяти, связанные с каждым запросом, должны исчезнуть после завершения запроса.
* Пример
	* на компьютере с 4 процессорами выполняются 12 процессов, использующих сборку мусора на сервере. 
      * все процессы осуществляют сбор мусора одновременно, они мешают друг другу
      * при активности процесса серверную сборку мусора не рекомендуется.
      * При запуске сотен экземпляров приложения использовать отключенную параллельную сборку мусора(не будут перелючаться контексты)
									
#### Фоновая сборка мусора							
* выполняется в ходе выполнения сборки поколения 2(по надобности выполняет(0-1) поколения)
* выполняется в одном или нескольких выделенных потоках
* включена по умолчанию(можно отключить)			
* заменяет параллельную сборку мусора и доступна в .NET Framework 4 и более поздних версиях. 			
					
Сборка для эфемерных поколений во время фоновой сборки мусора называется **высокоприоритетной сборкой мусора**. 
* Во время выполнения высокоприоритетных сборок мусора все управляемые потоки приостанавливаются.

Фоновая сборка мусора 
* удаляет ограничения на распределение, наложенные параллельной сборкой мусора, так как эфемерные сборки мусора могут выполняться во время фоновой сборки мусора. 
*  может удалить неиспользуемые объекты в эфемерных поколениях. 
*  может увеличить кучу во время сборки мусора поколения 1.
					
##### Фоновая сборка мусора на рабочих станциях и серверах
функционирует аналогично фоновой сборке мусора рабочей станции, но с некоторыми отличиями.
			
* для рабочей станции используется один выделенной поток фоновой сборки мусора. время ожидания истекает.
* для серверной сборки мусора используется несколько потоков. время ожидания не истекает. Как правило, имеется по одному выделенному потоку для каждого логического процессора.		
	
## Куча больших объектов Windows
Сборщик мусора .NET разделяет объекты на две категории — **большие и маленькие**. 

Пример: для сжатия объекта—копирования его в другое место в куче—требуется много ресурсов. Поэтому сборщик мусора помещает большие объекты в кучу больших объектов (LOH).
	
Как объект оказывается в куче больших объектов
* Объект > 85 000 байт помещается в кучу больших объектов LOH.
* Если объект меньше 85 000 байтов, он будет помещен в сегмент SOH. 
* Память из сегментов выделяется (блоками) по мере того, как в них помещается все больше объектов.

- Пользовательский код может размещать объекты только в поколении 0 или в куче больших объектов. 
- Только сборщик мусора может помещать объекты в поколение 1 и поколение 2
	- Процесс распрeделения
		* При запуске отслеживаются живые объекты и сжимает их.
		* 	Сжатие требует большого количества ресурсов
		* Сборщик мусора составляет в куче свободный список из мертвых объектов для повторного использования
		* Смежные мертвые объекты превращаются в один свободный объект.
			
.NET Core и .NET Framework 4.5.1 можно указать необходимость сжатия кучи больших объектов при следующей полной блокирующей сборке мусора.
		
Если нет свободного пространства на выделение памяти для больших объектов:
* сборщик мусора пытается получить дополнительные сегменты от ОС. 
* Если это не удается, он инициирует сборку мусора поколения 2 


* В ходе сборки мусора поколения 1 или 2 сборщик мусора отдает ОС сегменты, в которых нет живых объектов. 
* Свободное место после последнего живого объекта до конца сегмента освобождается(за исключением временных сегментов(0-1), поскольку вскоре приложение будет размещать в него объекты). 
* А свободные пространства остаются выделенными, но сбрасываются, освобождая ОС от необходимости записывать данные с них обратно на диск.
						
### Когда собираются большие объекты
Куча больших объектов собирается только во время сборки мусора поколения 2, как и сегмент этой кучи 

Условия сборки:
* Выделение памяти превышает пороговое значение для поколения 0 или больших объектов.
* Cборка мусора происходит в связи с распределениями в управляемой куче.
* вызывается метод GC.Collect .
	* **Если вызывается метод GC.Collect()** без параметров или c GC.MaxGeneration как аргумент, сборка мусора в куче больших объектов происходит одновременно со сборкой мусора в управляемой куче.
	* **В системе недостаточно памяти**. Это происходит, когда сборщик мусора получает от ОС уведомление верхней памяти. Если сборщик мусора считает, что сборка мусора поколения 2 будет продуктивной, он запускает ее.
												
### Влияние кучи больших объектов на производительность
Распределение в куче больших объектов влияет на производительность следующим образом.
#### Затраты на распределение.
* CLR гарантирует очистку памяти для каждого выдаваемого им нового объекта. при распределении большого объекта ресурсы расходуются на очистку памяти (если не запускается сборка мусора).

#### Затраты на сбор.
* при превышении порогового значения LOH или 2 запускается сборка мусора поколения 2. 
* Если сборка поколения 2 была запущена из-за кучи больших объектов, то само поколение 2 необязательно значительно уменьшится после сборки мусора. 
* Если поколение 2 большое, запуск многочисленных сборок мусора поколения 2 вызвает проблемы с производительностью.
* Если у вас много больших объектов с временным размещением и большая куча маленьких объектов, на сборку мусора может уходить слишком много времени. 

Кроме того, затраты на распределение могут нарастать, если вы и дальше будете распределять и освобождать очень большие объекты.
* Элементы массива со ссылочными типами.
* Очень большие объекты в куче обычно являются массивами (очень большие объекты-экземпляры весьма редки). 
* Если элементы массива имеют много ссылок, затраты выше, чем для элементов с небольшим количеством ссылок.
* Если элемент не содержит ссылок, сборщику мусора совсем не придется перебирать массив.
				
### Сбор данных производительности для кучи больших объектов
Прежде чем собирать данные производительности для определенной области, вы должны выполнить следующие действия:
* Найти свидетельство, которое нужно учитывать в этой области.
* Исследовать другие известные области и не найти в них причину проблемы с производительностью.
			
Для сбора данных о производительности кучи больших объектов можно использовать следующие средства:
* Счетчики памяти .NET CLR
* События трассировки событий Windows
* Отладчик
				
#### Счетчики памяти .NET CLR
Использование счетчиков памяти- первый этап поиска проблем с производительностью
				
Чтобы настроить монитор производительности, добавляются счетчики 
* К куче больших объектов относятся следующие счетчики:
	* Число сборок мусора поколения 2
	* Этот счетчик отображает последнее значение.
* Размер кучи для массивных объектов
	* Отображает текущий размер кучи больших объектов в байтах, включая свободное пространство. 
	  Этот счетчик обновляется в конце сборки мусора, не при каждом выделении памяти.

Распространенным средством просмотра счетчиков производительности является монитор производительности (perfmon.exe). 
			
##### ETW-события
Сборщик мусора предоставляет широкий набор событий трассировки событий Windows, помогая разобраться в функциях кучи. 
					
##### Отладчик	
Поскольку куча больших объектов не сжимается, иногда она считается источником фрагментации. 

**Фрагментация означает**:
* Фрагментация управляемой кучи, на которую указывает объем свободного пространства между управляемыми объектами.
* Фрагментация диапазона адресов виртуальной памяти. Это память, помеченная как MEM_FREE.

## Сборка мусора и производительность			
Чтобы определить, вызвана ли проблема сборкой мусора, выполните следующие действия.

Проверьте следующие два счетчика производительности памяти:
* % времени в сборке мусора. 
	* Отображение времени, потраченного на выполнение сборки мусора с момента последнего цикла сборки мусора (в процентах). 
	* Этот счетчик используется, чтобы определить, тратит ли сборщик мусора слишком много времени на освобождение пространства в управляемой куче. 
	* Если время мало, это может указывать на проблему ресурсов за пределами управляемой кучи.
* Всего зафиксировано байт.
	* Отображение объема виртуальной памяти, в данный момент выделенной сборщиком мусора. 
	* С помощью этого счетчика можно определить, является ли память, используемая сборщиком мусора, избыточной частью памяти, используемой приложением.

Большинство счетчиков памяти обновляются в конце каждой сборки мусора - могут не отражать текущие условия, сведения о которых вам требуются.				
													
### Рекомендации по устранению неполадок
####Сборка мусора на сервере или рабочей станции
* Убедитесь, что вы используете правильный тип сборки мусора.
	* Если приложение использует несколько потоков и экземпляров объектов, используйте сборку мусора на сервере вместо сборки мусора на рабочей станции. 

Когда измерять размер управляемой кучи
* Если вы не используете профилировщик, необходимо создать согласованный шаблон измерений для эффективной диагностики проблем с производительностью. 
	* При формировании расписания важно:
* Если измерение выполняется после сборки мусора поколения 2, вся куча будет свободна от мусора (неиспользуемых объектов).
* Если измерение выполняется сразу после сборки мусора поколения 0, объекты в поколении 1 и 2 еще не будут собраны.
* Если измерение выполняется сразу же перед сборкой мусора, будет измерено максимально возможное выделение до начала сборки мусора.
						
#### Индуцированные коллекции				
* В большинстве случаев сборщик мусора может определить самое подходящее время для выполнения сборки мусора, поэтому следует дать ему возможность работать независимо.
* В очень редких случаях принудительная сборка мусора может улучшить производительность приложения. 
* Если сборщик мусора непродуктивно пытается удалить объекты в не самое удачное время. 
  * передается значение перечисления GCCollectionMode.Optimized в метод Collect, чтобы осуществлять сбор только в случае его эффективности			
    * **Forced** или **Default** Блокирующий сбор выполнится, как только это станет возможным. 	
    * **Optimized**	В зависимости от текущего состояния сборщика мусора и значения параметра generation может выполняться блокирующая сборка. Сборщик мусора пытается обеспечить оптимальную производительность.		

#### Режимы задержки
* Чтобы освободить объекты, сборщик мусора должен остановить все выполняющиеся потоки приложения. 
* Период, в течение которого активен сборщик мусора, называется задержкой.
* В некоторых ситуациях, например, когда приложение получает данные или отображает содержимое, полная сборка мусора может произойти в критическое время и снизить производительность. 
* Степень вмешательства сборщика мусора можно настроить, присвоив свойству GCSettings.LatencyMode одно из значений System.Runtime.GCLatencyMode.				
					
#### Слабые ссылки
Сборщик мусора не может собрать объект, используемый приложением, пока код приложения взаимодействует с этим объектом. 

Говорят, что приложение **имеет строгую ссылку на объект**.
* дает сборщику мусора возможность удалить объект, но в то же время обеспечивает приложению доступ к этому объекту.
* допустима только в течение неопределенного количества времени до сборки объекта при отсутствии строгих ссылок. 

При использовании слабой ссылки приложение все еще может получить строгую ссылку в объекте, что предотвратит удаление последнего. 
* Всегда существует вероятность удаления объекта сборщиком мусора до повторного создания строгой ссылки.
* Слабые ссылки полезны для объектов, которые используют большой объем памяти, но могут быть созданы повторно без особых усилий, если они были удалены сборщиком мусора.
		
##### Краткие и длинные слабые ссылки
Можно создать краткую слабую ссылку или длинную слабую ссылку:
* **Short**
	* Назначением краткой ссылки становится null, если объект удален сборщиком мусора. 
	* Сама по себе слабая ссылка является управляемым объектом и подлежит сборке мусора, как и любые другие управляемые объекты. 
	* Краткая слабая ссылка является конструктором без параметров для WeakReference.
* Long
	* Длинная слабая ссылка сохраняется после вызова метода Finalize объекта.
	* Это позволяет повторно создавать объект, однако состояние объекта остается непредсказуемым. 
	* Чтобы использовать длинную ссылку, укажите значение true в конструкторе WeakReference.
	* Если тип объекта не имеет метода Finalize, используется функция краткой слабой ссылки, а сама слабая ссылка становится допустимой только до сборки целевых объектов, что может произойти в любое время после запуска метода завершения.

###### Правила использования слабых ссылок
* Используйте длинные слабые ссылки только при необходимости, так как состояние объекта после выполнения завершения становится непредсказуемым.
* Избегайте использования на небольшие объекты, потому что сам указатель может быть таким же по объему или даже больше.
* Избегайте использования в качестве автоматического решения проблем, связанных с управлением памятью.
												
###### Очистка неуправляемых ресурсов
* Для большинства объектов, создаваемых приложением, управление памятью осуществляется сборщиком мусора .NET.
* Неуправляемые ресурсы в необходимо освобождать их явно. 
* Сборщик мусора может отслеживать время жизни управляемого объекта, инкапсулирующего неуправляемые ресурсы, он не имеет сведений о том, как освобождать такие ресурсы.
						
Если ваши типы используют неуправляемые ресурсы, необходимо выполнить следующие действия:
* Реализуйте шаблон удаления. 
	* Реализация IDisposable.Dispose для детерминированного освобождения неуправляемых ресурсов. 
	* Объект-получатель типа вызывает метод Dispose, когда объект и используемые им ресурсы больше не нужны. 
	* Метод Dispose немедленно освобождает неуправляемые ресурсы.
		* Если метод Dispose не будет вызван объектом-получателем. Это можно осуществить двумя путями:
			* Используйте безопасный дескриптор в качестве оболочки для неуправляемого ресурса. 
			  **Это рекомендуемая методика.** 
				* Безопасные дескрипторы являются производными от класса System.Runtime.InteropServices.SafeHandle. 
				* Они включают надежный метод Finalize. 
				* При использовании безопасного дескриптора нужно просто реализовать интерфейс IDisposable и вызвать метод Dispose этого безопасного дескриптора в реализации IDisposable.Dispose. 
				* Метод завершения безопасного дескриптора автоматически вызывается сборщиком мусора, если не вызывается метод Dispose.
		* Переопределите метод Object.Finalize
			* завершение объекта может быть сложной операцией с высокой вероятностью ошибок, рекомендуется использовать безопасный дескриптор вместо указания собственного метода завершения.		
									
###### Реализация метода Dispose			
По окончании использования объекта, который реализует интерфейс IDisposable, необходимо вызвать реализацию объекта IDisposable.Dispose. Это можно сделать одним из двух способов.

* Заключение в оболочку каждого неуправляемого ресурса, используемого типом в безопасном дескрипторе (то есть в классе, производном от System.Runtime.InteropServices.SafeHandle). 
	* В этом случае необходимо реализовать интерфейс IDisposable и дополнительный метод Dispose(Boolean). Реализация интерфейса IDisposable и дополнительного метода Dispose(Boolean), а также переопределение метода Object.Finalize. 

Чтобы обеспечить соответствующую очистку ресурсов, метод Dispose должен быть доступен для многократного вызова без выдачи исключения.

##### Использование объектов, реализующих IDisposable

По окончании использования объекта, который реализует интерфейс IDisposable, необходимо вызвать реализацию объекта IDisposable.Dispose. Это можно сделать одним из двух способов.

**Оператор using**
* Оператор using получает один или больше ресурсов, выполняет заданные операторы, после чего автоматически освобождает объект. 
* Однако оператор using полезен только для объектов в области действия метода, в котором они созданы.
* исключения, вызываемые оператором using, а также создаваемые в блоке using, если блок try/catch отсутствует, не обрабатываются.
										
**Блок try/finally**
* Чтобы включить блок catch для обработки исключений, вызванных в блоке try. 
* В противном случае исключения, вызываемые оператором using, а также создаваемые в блоке using, 
* если блок try/catch отсутствует, не обрабатываются.
* Чтобы создать экземпляр объекта, реализующего интерфейс IDisposable, область действия которого не является локальной для блока, в котором он объявлен.	
						
## Глобальный кэш сборок
На каждом компьютере с установленной средой CLR имеется кэш кода на уровне компьютера, называемый глобальным кэшем сборок. 

В глобальном кэше сборок сохраняются сборки, специально предназначенные для совместного использования на компьютере несколькими приложениями.
		
Организовывать совместное использование сборок путем установки их в глобальный кэш следует только при необходимости. 

* Зависимости между сборками следует сохранять закрытыми, а сами сборки нужно размещать в папке приложения, если они не предназначены для совместного использования.
		
Кроме того, не обязательно устанавливать сборки в глобальный кэш сборок для доступа к ним из COM-взаимодействия или из неуправляемого кода.
* Существуют случаи, в которых явно не требуется установка сборки в глобальный кэш сборок.
* Если одна из составляющих приложения сборок помещается в глобальный кэш сборок, то не получится скопировать или установить приложение через xcopy путем копирования каталога приложения. 
				
* Существует два способа развертывания сборки в глобальном кэше сборок.
* Использование программы установки, предназначенной для работы с глобальным кэшем сборок.
* Используйте инструмент разработчика под названием средство глобального кэша сборок (Gacutil.exe) из Windows SDK.
			
Начиная с .NET Framework 4 расположение глобального кэша сборок по умолчанию — %windir%\Microsoft.NET\assembly.

Сборки, развернутые в глобальном кэше сборок, должны иметь строгие имена.
	* При добавлении выполняется проверка целостности всех входящих в нее файлов. Кэш выполняет такую проверку целостности, чтобы гарантировать, что сборка не была изменена

		
### Существует несколько причин для установки сборки в глобальном кэше сборок.
#### Общее расположение.
Используемые несколькими приложениями сборки можно располагать в глобальном кэше сборок. 

#### Безопасность файлов.
Администраторы часто защищают папку systemroot с помощью списка управления доступом, определяющего права на запись и выполнение.

### Управление параллельными версиями.
В глобальном кэше сборок может храниться несколько сборок, имеющих одинаковые имена, но различные сведения о версии.

### Дополнительное место для поиска.
Перед проверкой или использованием сведений о базе кода в файле конфигурации среда CLR ищет в глобальном кэше сборки, соответствующие запросу.
		
# Наследование в C# и .NET
* Наследование применяется только для классов и интерфейсов
* В C# производные классы могут содержать методы с такими же именами, как у методов базового класса.
* Метод базового класса должен быть определен как виртуальный.
* Если методу в производном классе не предшествуют ключевые слова new или override, компилятор выдаст предупреждение, а метод будет вести себя так, как если бы имелось ключевое слово new.
* Если методу в производном классе предшествует ключевое слово new, он определяется как независимый от метода в базовом классе.
* Если методу в производном классе предшествует ключевое слово override, объекты производного класса вызывают этот метод вместо метода базового класса.
* Метод базового класса можно вызывать из производного класса с помощью ключевого слова base.
* Ключевые слова override, virtual иnew можно также применять к свойствам, индексаторам и событиям.	
```	
	    class BaseClass  
		{  
			public virtual void Method1()  
			{  
				Console.WriteLine("Base - Method1");  
			}  
	  
			public virtual void Method2()  
			{  
				Console.WriteLine("Base - Method2");  
			}  
		}  
	  
		class DerivedClass : BaseClass  
		{  
			public override void Method1()  
			{  
				Console.WriteLine("Derived - Method1");  
			}  
	  
			public new void Method2()  
			{  
				Console.WriteLine("Derived - Method2");  
			}  
		} 
		static void Main(string[] args)  
        {  
            BaseClass bc = new BaseClass();  
            DerivedClass dc = new DerivedClass();  
            BaseClass bcdc = new DerivedClass();  
			
            bc.Method1();  
            bc.Method2();  
            // Output:  
            // Base - Method1  
            // Base - Method2  
  
            dc.Method1();  
            dc.Method2();  
            // Output:  
            // Derived - Method1  
            // Derived - Method2  
  
            bcdc.Method1();  
            bcdc.Method2();  
            // Output:  
            // Derived - Method1  
            // Base - Method2  
        }  
    }   
	
    class Program  
    {  
        static void Main(string[] args)  
        {  
            // Declare objects of the derived classes and test which version  
            // of ShowDetails is run, base or derived.  
            TestCars1();  
  
            // Declare objects of the base class, instantiated with the  
            // derived classes, and repeat the tests.  
            TestCars2();  
  
            // Declare objects of the derived classes and call ShowDetails  
            // directly.  
            TestCars3();  
  
            // Declare objects of the base class, instantiated with the  
            // derived classes, and repeat the tests.  
            TestCars4();  
        }  
  
        public static void TestCars1()  
        {  
            System.Console.WriteLine("\nTestCars1");  
            System.Console.WriteLine("----------");  
  
            Car car1 = new Car();  
            car1.DescribeCar();  
            System.Console.WriteLine("----------");  
  
            // Notice the output from this test case. The new modifier is  
            // used in the definition of ShowDetails in the ConvertibleCar  
            // class.
            ConvertibleCar car2 = new ConvertibleCar();  
            car2.DescribeCar();  
            System.Console.WriteLine("----------");  
  
            Minivan car3 = new Minivan();  
            car3.DescribeCar();  
            System.Console.WriteLine("----------");  
        }  
        // Output:  
        // TestCars1  
        // ----------  
        // Four wheels and an engine.  
        // Standard transportation.  
        // ----------  
        // Four wheels and an engine.  
        // Standard transportation.  
        // ----------  
        // Four wheels and an engine.  
        // Carries seven people.  
        // ----------  
  
        public static void TestCars2()  
        {  
            System.Console.WriteLine("\nTestCars2");  
            System.Console.WriteLine("----------");  
  
            var cars = new List<Car> { new Car(), new ConvertibleCar(),
                new Minivan() };  
  
            foreach (var car in cars)  
            {  
                car.DescribeCar();  
                System.Console.WriteLine("----------");  
            }  
        }  
        // Output:  
        // TestCars2  
        // ----------  
        // Four wheels and an engine.  
        // Standard transportation.  
        // ----------  
        // Four wheels and an engine.  
        // Standard transportation.  
        // ----------  
        // Four wheels and an engine.  
        // Carries seven people.  
        // ----------  
  
        public static void TestCars3()  
        {  
            System.Console.WriteLine("\nTestCars3");  
            System.Console.WriteLine("----------");  
            ConvertibleCar car2 = new ConvertibleCar();  
            Minivan car3 = new Minivan();  
            car2.ShowDetails();  
            car3.ShowDetails();  
        }  
        // Output:  
        // TestCars3  
        // ----------  
        // A roof that opens up.  
        // Carries seven people.  
  
        public static void TestCars4()  
        {  
            System.Console.WriteLine("\nTestCars4");  
            System.Console.WriteLine("----------");  
            Car car2 = new ConvertibleCar();  
            Car car3 = new Minivan();  
            car2.ShowDetails();  
            car3.ShowDetails();  
        }  
        // Output:  
        // TestCars4  
        // ----------  
        // Standard transportation.  
        // Carries seven people.  
    }  
	
    class Car  
    {  
        public virtual void DescribeCar()  
        {  
            System.Console.WriteLine("Four wheels and an engine.");  
            ShowDetails();  
        }  
  
        public virtual void ShowDetails()  
        {  
            System.Console.WriteLine("Standard transportation.");  
        }  
    }  
	
    class ConvertibleCar : Car  
    {  
        public new void ShowDetails()  
        {  
            System.Console.WriteLine("A roof that opens up.");  
        }  
    }  
  
    {  
        public override void ShowDetails()  
        {  
            System.Console.WriteLine("Carries seven people.");  
        }  
    }   
```

# Асинхронное программирование	

	Зачем писать асинхронный код?
	Современные приложения активно используют файловые и сетевые операции ввода-вывода. 
		API ввода-вывода обычно являются блокирующими по умолчанию, 
		в результате чего возникают зависания пользовательского интерфейса и снижается эффективность использования оборудования.
		Избежать этого можно, только научившись пользоваться сложными шаблонами. 
		Основанные на задачах асинхронные интерфейсы API и модель асинхронного программирования на уровне языка меняют эту диспозицию и 
		делают асинхронное выполнение режимом по умолчанию.
	Асинхронный код имеет следующие характеристики.
		Обрабатывает больше запросов сервера, предоставляя потокам возможность обрабатывать больше запросов во время ожидания результата от запросов ввода-вывода.
		Делает пользовательский интерфейс более быстрым, выделяя потоки для обработки действий в пользовательском интерфейсе во время ожидания запросов ввода-вывода и 
			передавая затратные по времени операции другим ядрам ЦП.
		Многие новые API-интерфейсы .NET являются асинхронными.	
				
	Task и Task<T>	
		Task (задача) — это конструкции, реализующие модель параллельной обработки на основе обещаний (Promise). 
		Она "обещает", что работа будет выполнена позже, позволяя взаимодействовать с помощью обещания с чистым API.
			Task представляет одну операцию, которая не возвращает значение.
			Task<T> представляет одну операцию, которая возвращает значение типа T.		

		Задачи - это абстракции асинхронных операций, но не абстракции поверх потоков. 
			По умолчанию задачи выполняются в текущем потоке и при необходимости делегируют работу операционной системе.
			Может явно запрашиваться запуск в отдельном потоке через Task.Run.
			
		Задачи предоставляют протокол API для мониторинга, ожидания и доступа к результирующему значению задачи.
		Интеграция с языком через ключевое слово await обеспечивает абстракцию более высокого уровня для использования задач.
		Использование await позволяет приложению выполнять работу во время выполнения задачи за счет передачи управления вызывающему объекту задачи до ее завершения.
	
	Подробный обзор задач, связанных с операциями ввода-вывода
		Если поток ОС знает, что запрос является "ожидающим", он "возвращается" обратно(NB), где его можно использовать в других целях.
		Ключевым моментом является то, что ни один поток не выделяется для выполнения задачи. 
			Несмотря на то, что работа выполняется в некотором контексте никакой поток специально не выделяется для ожидания возвращения данных из запроса. 
			Это позволяет системе выполнять гораздо больший объем работы
			
	Что это означает для сервера?
		Эта модель хорошо подходит для типовых рабочих нагрузок на сервере. 
			Неи потоков, выделенных для блокировки незавершенных задач,  пул потоков может обрабатывать большее количество веб-запросов.
			
		Рассмотрим два сервера: один выполняет асинхронный код, а второй нет. 
			Пусть на каждом сервере есть только 5 потоков, доступных для обслуживания запросов. 
			Предположим, что оба сервера получили 6 параллельных запросов. В каждом запросе выполняется операция ввода-вывода. 
				Сервер без асинхронного кода 
					должен поставить в очередь 6-й запрос, пока один из 5 потоков не завершит работу, связанную с вводом-выводом, и не возвратит ответ. 
					После поступления 20-го запроса работа сервера может начать замедляться, поскольку очередь становится слишком длинной.
				Сервер с асинхронным кодом
					помещает 6-й запрос в очередь, но так как он использует async и await, каждый из его потоков освобождается при начале работы подсистемы ввода-вывода,  а не после завершения такой работы. 
					к моменту поступления 20-го запроса очередь входящих запросов будет гораздо меньше (если в ней вообще что-либо будет), а сервер будет работать как и прежде.
	
	Что это означает для клиента?
		Важнейшим преимуществом использования async и await для клиента является повышение скорости реагирования. 
			процедура создания потока — это дорогостоящая операция по сравнению с использованием async и await. 
					
	Подробный обзор Task и Task<T> для операций, связанных с ЦП
		Код async, связанный с использованием ЦП, немного отличается от кода async, связанного с операциями ввода-вывода. 
		Поскольку работа выполняется на ЦП, невозможно избежать выделения потока для вычислений. 
			Использование async и await предоставляет чистый способ взаимодействия с фоновым потоком и позволяет объекту, вызвавшему асинхронный метод, по-прежнему реагировать на новые запросы.
			
	Что происходит на внутреннем уровне
		С точки зрения C#, компилятор преобразовывает код в конечный автомат, он контролирует 
			передачу выполнения при достижении await 
			возобновление выполнения после завершения фонового задания.
		
	Ключевые моменты для понимания
		Асинхронный код можно использовать:
			при ограниченной производительности ввода-вывода, 
			при ограниченных ресурсах процессора, но по-разному.
		В асинхронном коде используются конструкции Task<T> и Task, для моделирования задач, выполняемых в фоновом режиме.
		Ключевое слово async делает метод асинхронным, для использония await.
		await приостанавливает выполнение вызывающего метода и передает управление обратно вызывающему объекту, пока не будет завершена ожидаемая задача.
		await можно использовать только внутри асинхронного метода.
		
	Определение задач, ограниченных ресурсами процессора и производительностью ввода-вывода
		Перед написанием любого кода нужно ответить на два вопроса.
			Будет ли код "ожидать" чего-либо, например данных из базы данных?
				Если ответ утвердительный, то ваша задача ограничена производительностью ввода-вывода.
			Будет ли код выполнять очень сложные вычисления?
				Если ответ утвердительный, то задача ограничена ресурсами процессора.
				
		Если ваша задача ограничена производительностью ввода-вывода, используйте async и await без Task.Run. 
			Библиотеку параллельных задач использовать не следует.
		Если ваша задача ограничена ресурсами процессора и вам важна скорость реагирования,
			используйте async и await, но перенесите выполнение задачи в дополнительный поток с Task.Run. 
			Если к задаче применим параллелизм
				следует рассмотреть возможность использования библиотеки параллельных задач.	
	
	Важные сведения и советы
		Хотя принципы асинхронного программирования сравнительно просты, необходимо учитывать ряд моментов, чтобы избежать непредвиденных результатов.
			async методах должно присутствовать ключевое слово await. В противном случае результат не будет получен.
				Если ключевое слово await не используется в теле метода async, 
					будет выдано предупреждение, но код продолжит работу
					это неэффективно: конечный автомат, созданный компилятором C# для асинхронного метода, не будет выполнять никакой работы.
			async void следует использовать только для обработчиков событий.
					Исключения, вызываемые в методе async void, невозможно перехватывать вне этого метода.
					Методы async void могут иметь негативные побочные эффекты, если вызывающий объект не предполагает, что они являются асинхронными.
			если метод запускает асинхронную операцию, но не возвращает ожидаемый тип, его имя должно начинаться с Begin, Start или другого глагола, который указывает на то, что этот метод не возвращает или не выдает результат операции. 	 
			параметры out и ref исключены из этого правила, их следует избегать полностью. 			
			методы объединения -методы объединения задач (WhenAll и WhenAny)		
					
			Будьте осторожны при использовании асинхронных лямбда-выражений в выражениях LINQ
				Для лямбда-выражений в LINQ применяется отложенное выполнение.
				код может прекратить выполнение в тот момент, когда вы этого не ожидаете. 
				неправильное использование блокирующих задач может привести к взаимоблокировке. 
				усложняет анализ выполнения кода. 
				Асинхронное выполнение и LINQ — эффективные средства, но использовать их следует с максимальной осторожностью и ясным пониманием того, что вы делаете.
				
			При написании кода ожидание задач следует реализовывать без блокирования
				Блокирование текущего потока в целях ожидания завершения задачи приводит к взаимоблокировкам и блокированию потоков контекста,
					может требоваться значительно более сложная обработка ошибок.
			В приведенной ниже таблице даются рекомендации по реализации ожидания задач без блокировки.

				Рекомендуемый способ	Нерекомендуемый способ			Задача
				await					Task.Wait или Task.Result		Получение результата фоновой задачи
				await					Task.WhenAny	Task.WaitAny	Ожидание завершения выполнения любой задачи
				await					Task.WhenAll	Task.WaitAll	Ожидание завершения выполнения всех задач
				await					Task.Delay	Thread.Sleep		Ожидание в течение заданного времени
			
			Пишите код с менее строгим отслеживанием состояния
				Старайтесь, чтобы выполнение кода не зависело от состояния глобальных объектов или выполнения определенных методов. 
					Оно должно зависеть только от возвращаемых методами значений. Почему?
						Код будет проще анализировать.
						Код будет проще тестировать.
						Гораздо проще будет сочетать асинхронный и синхронный код.
						Как правило, можно полностью избежать состояний гонки.
						Зависимость от возвращаемых значений упрощает согласование асинхронного кода.
						Дополнительным преимуществом является то, что такой код хорошо работает с внедрением зависимостей.
			Следует стремиться к достижению полной или почти полной ссылочной прозрачности в коде.(
				Ссылочная прозрачность и ссылочная непрозрачность — это свойства частей компьютерных программ. Выражение называется ссылочно прозрачным, если его 
				можно заменить соответствующим значением без изменения поведения программы.) 	
				Результатом будет высокий уровень предсказуемости базы кода, а также ее пригодности для тестирования и обслуживания.
					
	Асинхронное программирование с использованием ключевых слов async и await  
		Модель асинхронного программирования задач (TAP) предоставляет абстракцию асинхронного кода. 
			Пишется код как последовательность операторов. 
			Читается код, как если бы каждая инструкция завершалась до начала следующей. 
			Компилятор выполняет ряд преобразований, так как некоторые из этих инструкций могут начать работу и вернуть Task, представляющий текущую работу. 
			
			Можно написать инструкции аналогично следующему списку, чтобы объяснить, как приготовить завтрак.			
				Налить чашку кофе.
				Нагреть сковородку, а затем поджарить два яйца.
				Поджарить три куска бекона.
				Сделать два тоста.
				Намазать тосты маслом и джемом.
				Налить стакан апельсинового сока.
			Приготовление завтрака представляет собой хороший пример асинхронной непараллельной работы.
				Один пользователь (или поток) может обрабатывать все эти задачи.
				Для параллельного алгоритма потребовалось бы несколько поваров (или потоков).
			Компьютеры не рассматривают эти инструкции так же, как люди. 
			Компьютер будет задерживаться над каждой инструкцией до момента, когда работа будет завершена, прежде чем перейдет к следующему оператору. 
			Чтобы компьютер асинхронно выполнил инструкции выше, необходимо писать асинхронный код.
			При написании серверных программ не стоит блокировать потоки. Эти потоки могут обслуживать другие запросы.
		
		Не блокировать, а использовать await
				Ключевое слово await позволяет обойтись без блокировки для запуска задачи, а затем продолжить выполнение, когда задача завершается. 
				Простая асинхронная версия кода для приготовления завтрака будет выглядеть так:
					static async Task Main(string[] args)
					{
						Egg eggs = await FryEggsAsync(2);
						Bacon bacon = await FryBaconAsync(3);
						Toast toast = await ToastBreadAsync(2);
						Console.WriteLine("Breakfast is ready!");					
					}		
				Этот код не блокируется при приготовлении яиц или бекона. Этот код, однако, не запускает других задач.
					По-прежнему придется поместить тост в тостер и смотреть на него, пока он не выскочит. Но по крайней мере можно отвечать всем, кто хочет вашего внимания. 
					В ресторане, где будет размещаться несколько заказов, повар сможет начать готовить другой завтрак, пока первый готовится.
					Лучше запускать каждую из задач компонента, не ожидая завершения предыдущей задачи.
		Одновременный запуск задач
			Во многих случаях требуется запускать сразу несколько независимых задач. 
			System.Threading.Tasks.Task и связанные типы — это классы, позволяющие делать выводы о задачах, которые находятся в процессе выполнения.
					Task<Egg> eggsTask = FryEggs(2);
					Task<Bacon> baconTask = FryBacon(3);
					Task<Toast> toastTask = ToastBread(2);
					WaitAll(eggsTask, baconTask, toastTask)
					Console.WriteLine("Breakfast is ready!");
					код работает лучше. Запуск всех асинхронных задач выполняется за один раз. 
		
		Потоки
			Асинхронные методы используются для неблокирующих операций. 
			 await не блокирует текущий поток на время выполнения ожидаемой задачи.
				выражение регистрирует остальную часть метода как продолжение и возвращает управление вызывающему объекту асинхронного метода.
			Ключевые слова async и await не вызывают создания дополнительных потоков. 
				Асинхронные методы не требуют многопоточности, асинхронный метод не выполняется в собственном потоке.
				Метод выполняется в текущем контексте синхронизации и использует время в потоке, только когда метод активен. 
				Task.Run применять для перемещения операций, использующих ресурсы ЦП, в фоновый поток
				фоновый поток не нужно применять для процесса, который просто ждет результата.
		
		Обобщенные асинхронные типы возвращаемых значений и ValueTask<TResult>		
			Начиная с C# 7.0 асинхронные методы могут возвращать любой тип, имеющий доступный метод GetAwaiter.
			Поскольку Task и Task<TResult> являются ссылочными типами, выделение памяти во влияющих на производительность сегментах может серьезно снизить производительность. 
				Поддержка обобщенных типов возвращаемых значений позволяет возвращать небольшой тип значения вместо ссылочного типа, благодаря чему удается предотвратить избыточное выделение памяти.
			ValueTask<TResult> - упрощенной реализацией обобщенного значения, возвращающего задачу. 
		
		Асинхронные потоки с IAsyncEnumerable<T>
			Начиная с C# 8.0, асинхронный метод может возвращать асинхронный поток, представленный интерфейсом IAsyncEnumerable<T>. 
			Асинхронный поток позволяет перечислять элементы, считываемые из потока, при создании блоков элементов с помощью повторяющихся асинхронных вызовов. 
			
	Библиотека параллельных задач (TPL)
		Библиотека параллельных задач (TPL) представляет собой набор открытых типов и API-интерфейсов в пространствах имен System.Threading и System.Threading.Tasks. 
			Цель TPL — повышение производительности труда разработчиков за счет упрощения процедуры добавления параллелизма в приложения. 
			Функции
				осуществляется секционирование работы, 
				планирование потоков в пуле ThreadPool, 
				поддержка отмены, 
				управление состоянием 
				выполнение низкоуровневых задач. 
		TPL(c 4.0) - предпочтительный способ создания многопоточного и параллельного кода. 
		Код не подходящий; 
			если цикл за каждую итерацию выполняет небольшой объем работ или выполняется для небольшого числа итераций, из-за дополнительной нагрузки, которую параллелизация оказывает на систему,  код может выполняться медленнее. 
			параллелизация усложняет выполнение программы. 
			
		Асинхронное программирование на основе задач
			Библиотека параллельных задач (TPL) основана на концепции задач, представляющих асинхронные операции. 
			Задача похожа на поток или рабочий элемент ThreadPool на более высоком уровне абстракции.
			Термин параллелизм - одновременное выполнение одной или нескольких разных задач. 
				Задачи предоставляют два основных преимущества.
					Более эффективное и масштабируемое использование системных ресурсов.
						В фоновом режиме задачи помещаются в очередь ThreadPool, усовершенствованную с помощью алгоритмов
							определяют и настраивают количество потоков 
							обеспечивают балансировку нагрузки для повышения производительности. 
					Больший программный контроль по сравнению с потоком или рабочим элементом.
						Задачи предоставляют набор интерфейсов API, которые поддерживают ожидание, отмену, продолжения, надежную обработку исключений, подробные состояния
				
			Явное создание и запуск задач
				Задача, не возвращающая значение, представляется классом System.Threading.Tasks.Task. Задача, возвращающая значение, представляется классом System.Threading.Tasks.Task<TResult>, унаследованным от Task. 
					Объект задачи обрабатывает сведения инфраструктуры и предоставляет методы и свойства, доступные из вызывающего потока в течение времени существования задачи.
					Например, можно получить доступ к свойству Status задачи в любое время
				При создании задачи ей передается пользовательский делегат, инкапсулирующий код, который будет выполнять задача.
					Делегат может быть выражен как именованный делегат, анонимный метод или лямбда-выражение. 
					Лямбда-выражения могут содержать вызов именованного метода
				Для создания и запуска задачи в одной операции можно также использовать методы Task.Run. 
					методы Run используют планировщик задач по умолчанию независимо от того, какой планировщик связан с текущим потоком. 
					Методы Run — предпочтительный способ создания и запуска задач, если не требуется более жесткий контроль над созданием и планированием задачи.
				Для создания и запуска задачи в одной операции можно также использовать метод TaskFactory.StartNew. 
					Причины использования
						если нет необходимости разделять создание и планирование
						требуются дополнительные параметры создания задач
						требуется использование определенного планировщика
				Задачи выполняются асинхронно и могут завершиться в любом порядке. 
				Result блокирует вызывающий поток до тех пор, пока значение не станет доступно.
				
			Создание продолжений задач
				С помощью методов Task.ContinueWith и Task<TResult>.ContinueWith можно указать задачу, которую нужно запускать по завершении предшествующей задачи.
			
			Идентификатор задачи
				Каждая задача получает уникальный на домен целочисленный идентификатор - Task.Id
				Этот идентификатор полезен для просмотра сведений о задаче в окнах Параллельные стеки и Задачи отладчика Visual Studio. 
				Он создается только после того, как запрашивается. 
			
		Параллелизм данных
			несколько ядер ЦП, которые позволяют одновременно выполнять несколько потоков. 
				Чтобы воспользоваться преимуществами оборудования, можно параллелизовать код для распределения работы между несколькими процессорами.
				
			Понятие Параллелизм данных относится к сценариям, в которых одна и та же операция выполняется одновременно (то есть параллельно) для элементов в исходной коллекции или массиве. 
				исходная коллекция секционируются таким образом, чтобы несколько потоков могли одновременно работать в разных сегментах.
				TPL поддерживает параллелизм данных с помощью класса System.Threading.Tasks.Parallel. 
				Этот класс предоставляет параллельные реализации на основе методов циклов for и foreach
				Логика цикла для Parallel.For или Parallel.ForEach 
					Нет необходимости создавать потоки или очередь рабочих элементов. 
					В базовых циклах нет необходимости применять блокировки. 
		
		Поток данных(TPL DataFlow)
			Библиотека параллельных задач (TPL) предоставляет компоненты потока данных, что позволяет повысить надежность приложений с включенным параллелизмом. 
				TPL - модель потоков данных поддерживает программирование на основе субъектов через обеспечение внутрипроцессной передачи сообщений для недетализированного потока данных и задач по конвейеризации. 
				Компоненты потоков данных строятся на типах и инфраструктуре планирования TPL и интегрированы с языковой поддержкой асинхронного программирования на C#
			Эти компоненты потоков данных полезны при наличии нескольких операций, которые должны асинхронно взаимодействовать друг с другом, или при необходимости обрабатывать данные по мере того, как они становятся доступными.
			
			Модель программирования
				Библиотека потоков данных TPL:
					обеспечивает основу для передачи сообщений и параллелизации приложений, создающих большую нагрузку на ЦПУ и ввод-вывод
					предоставляет явный контроль над тем, как данные буферизуются и перемещаются по системе. 
					можно создавать объекты потоков данных, которые обрабатывают изображения по мере считывания их с диска. 
						в модели потоков данных объявляется, как обрабатываются данные, когда они становятся доступными, а также объявляются любые зависимости между данными. 
				Среда выполнения управляет зависимостями между данными, часто можно избежать необходимости синхронизировать доступ к общим данным.
			Источники и целевые блоки
				Библиотека потоков данных TPL состоит из блоков потоков данных, которые представляют собой структуры данных, буферизующие и обрабатывающие данные. 
				Три типа блоков потоков данных: 
					блоки источника - источника данных, из которого можно считать данные, 
					целевые блоки - получателя данных
					блоки передачи - действует и как блок источника, и как целевой блок: из него можно читать и в него можно писать. 
			Соединение блоков
				Можно также соединять блоки потоков данных для создания конвейеров:
					линейные последовательности блоков потоков данных, или сетей, являющихся графами блоков потоков данных. 
					Конвейер - однин из видов сетей. 
						асинхронно распространяют исходные данные целевым объектам, когда данные становятся доступны. 
						метод ISourceBlock<TOutput>.LinkTo связывает блок потока данных источника и целевой блок. 
							Источник может быть связан с несколькими целевыми  объектами или не связан ни с одним;
							целевые объекты могут иметь связь с несколькими источниками или не иметь связей. 
						можно добавлять или удалять блоки потока данных из конвейера или сети одновременно.
						предопределенные типы блоков потоков данных отвечают за все аспекты потокобезопасности установки и удаления связей.
			Фильтрация
				при связывании источника с целевым объектом, можно указать делегат, который определяет, принимает или отклоняет целевой блок сообщение в зависимости от содержания этого сообщения. 
				Механизм фильтрации гарантирует, что блок потока данных будет получать только определенные значения. 
				если блок источника подключен к нескольким целевым блокам, когда один из целевых блоков отвергает сообщение, это сообщение отправляется следующему целевому объекту. 
				Порядок, отправления сообщения целевым объектам, определяется источником и различается для типа источника. 
				Большинство типов блоков источников перестают отправлять сообщение после того, как один из целевых объектов его принимает.
				Единственным исключением из этого правила является класс BroadcastBlock<T>, который предлагает каждое сообщение всем целевым объектам, даже если некоторые из целевых объектов отклоняют это сообщение.	
				
			Передача сообщений
				Модель программирования на основе потоков данных связана с понятием передача сообщений, так как независимые компоненты программы взаимодействуют друг с другом посредством отправки сообщений.
				Блоки источника предлагают данные целевым блокам, вызывая метод ITargetBlock<TInput>.OfferMessage. 
				Целевой блок отвечает на предложенное сообщение одним из трех способов: 
					принять сообщение вернет Accepted, 
					отклонить сообщение возвращает Declined
					отложить сообщение возвращает Postponed.						
			Предопределенные типы блоков потоков данных
				Библиотека потоков данных TPL предоставляет три категории блоков потоков данных.
					блоки буферизации, 
					блоки выполнения 
					блоки группировки
				Блоки буферизации
					Блоки буферизации хранят данные для их использования объектами-потребителями данных. 	
						BufferBlock(T)
							Класс BufferBlock<T> представляет структуру общего назначения для асинхронного обмена сообщениями.
								хранится очередь сообщений типа «первым вошел — первым вышел» (FIFO)
									в очередь могут записывать данные несколько источников 
									из очереди могут читать данные несколько целевых объектов.
							Если целевой объект получает сообщение от объекта BufferBlock<T>, это сообщение удаляется из очереди сообщений. 				
						BroadcastBlock(T)
							удобен, если необходимо передать несколько сообщений другому компоненту, этому компоненту нужно только самое последнее значение. 
							полезен при необходимости широковещательной передачи сообщения нескольким компонентам.					
						WriteOnceBlock(T)
							как класс BroadcastBlock<T> допускает только однократную запись. 
							становится неизменяемым после того,  как он получает значение 
			Определение планировщика заданий
				Все стандартные блоки потоков данных используют механизм планирования задач TPL для
					 передачи данных целевому объекту, 
					получение данных из источника 
					выполнение определенных пользователем делегатов, когда данные становятся доступны. 
					
				TaskScheduler — абстрактный класс, представляющий планировщик заданий, ставящий задачи в очередь потоков.
					по умолчанию использует класс ThreadPool для постановки в очередь и выполнения работы. 
					Можно переопределить планировщик заданий изменив свойство TaskScheduler при создании объекта блока потока данных.
					
			Определение степени параллелизма
				три типа блоков выполнения: 
					ActionBlock<TInput>, 
					TransformBlock<TInput,TOutput>
					TransformManyBlock<TInput,TOutput>, 
				они обрабатывают одно сообщение за раз.
				
			Определение количества сообщений на задачу
				Предопределенные типы блоков потока данных используют задачи для обработки нескольких входных элементов. 
					Это позволяет минимизировать число объектов задачи, необходимых для обработки данных, из-за чего приложения выполняются более эффективно. 
				Однако если задачи из одного набора блоков потока данных обрабатывают данные, 
					задачи из других блоков потока данных быть ожидают в течение времени, необходимого для обработки данных, добавляя сообщения в очередь. 
				Чтобы обеспечить улучшенное распределение ресурсов между задачами потока данных, используются свойства MaxMessagesPerTask. 
					DataflowBlockOptions.Unbounded, которое используется по умолчанию, задача обрабатывает столько сообщений, сколько их доступно. 
					не Unbounded, блок потока данных обрабатывает не больше этого количества сообщений на объект Task. 	
					
			Определение жадного и нежадного поведения
				Несколько группирующих типов блоков потоков данных могут работать либо в жадном, либо в нежадном режиме. 
				По умолчанию - жадный режим. блок сразу принимает данные, даже если соответствующие данные, с которыми нужно выполнить объединение, еще недоступны. 
				Нежадный режим - блок откладывает все входящие сообщения, пока сообщение не будет доступно на каждом из его целевых объектов для завершения объединения. 
				Если любое из отложенных сообщений больше недоступно, блоки соединения освобождают все отложенные сообщения и перезапускают процесс. 
				Для определения нежадного режима для блока потока данных задайте свойству Greedy значение False. 

		Библиотека параллельных задач и традиционное асинхронное программирование .NET Framework
			  
			В .NET есть три шаблона для выполнения асинхронных операций:
			TAP - Асинхронный шаблон на основе задач, который использует один метод для запуска и завершения асинхронной операции. 
				реализован в .NET Framework 4. Именно его рекомендуется использовать для асинхронного программирования в .NET. Ключевые слова async и await в C#
			EAP - Асинхронная модель на основе событий. Это устаревшая модель на основе событий, обеспечивающая работу в асинхронном режиме. 
				Для нее требуется 
					метод с суффиксом Async
					одно или несколько событий
					типы делегатов обработчика событий и производные типы EventArg. 
				Протокол EAP был введен в платформа.NET Framework 2.0. 
			APM - Модель асинхронного программирования (также называется шаблоном IAsyncResult). 
				Это устаревшая модель, в которой для реализации асинхронного поведения используется интерфейс IAsyncResult. 
					В этом шаблоне для синхронных операций требуются методы Begin и End (например, BeginWrite и EndWrite позволяют реализовать асинхронную операцию записи). 
					Этот шаблон не рекомендуется использовать для разработки новых приложений. 
							
			Асинхронный шаблон, основанный на задачах (TAP)
				Асинхронная модель на основе задач (TAP) основана на типах System.Threading.Tasks.Task и System.Threading.Tasks.Task<TResult> пространства имен System.Threading.Tasks, 
					они используются для представления произвольных асинхронных операций. 
				
				TAP — это рекомендуемый асинхронный шаблон для разработки новых компонентов.
				Именование, параметры и возвращаемые типы
					TAP использует один метод для представления инициализации и завершения асинхронной операции. 
						Это отличается от шаблона модели асинхронного программирования (APM или IAsyncResult) и асинхронного шаблона, основанного на событиях (EAP). 
						Для APM требуется метод Begin и End. Для EAP требуется метод с суффиксом Async, а также одно или несколько событий, типов делегата обработчика событий и производные от EventArg типы.
										
				Инициализация асинхронной операции
					Асинхронный метод, основанный на TAP, может выполнить небольшой объем работы синхронно, например проверить аргументы и инициировать асинхронную операцию, прежде чем вернуть результирующую задачу.
					Синхронная работа должна быть сведена к минимуму, чтобы асинхронный метод мог быстро вернуть значение. Причины быстрого возвращения указаны ниже.
						любые продолжительные синхронные задачи могут негативно сказаться на скорости реагирования приложения.
						при одновременном запуске задач любые длительные синхронные фрагменты асинхронного метода могут отложить запуск других асинхронных операций
						В некоторых случаях объем работы, необходимый для выполнения операции, меньше объема работы, необходимого для асинхронного запуска операции(например чтение закешированных данных)
				Исключения
					Асинхронный метод должен вызывать исключение, которое должно создаваться вызовом асинхронного метода только в ответ на ошибку использования. 
					Ошибки использования никогда не должны происходить в рабочем коде. 
						исключения должны относиться к возвращаемой задаче, даже если асинхронный метод выполняется синхронно перед возвращением задачи. 
				Целевая среда
					При реализации метода TAP можно определить, где происходит асинхронное выполнение.
					Можно выполнить рабочую нагрузку:
						в пуле потоков, реализовать ее с помощью асинхронного ввода-вывода  (без привязки к потоку в большей части выполнения операции), 
						выполнить ее в определенном потоке (например, в потоке пользовательского интерфейса)
						использовать любое количество потенциальных контекстов. 
				Состояние задачи
					Класс Task обеспечивает жизненный цикл для асинхронных операций, и этот цикл представлен перечислением TaskStatus. 
					Задачи, созданные открытыми конструкторами Task, называются холодными задачами, так как они начинают свой жизненный цикл в незапланированном состоянии Created, 
						их планирование осуществляется, когда в этих экземплярах вызывается метод Start.
					Все другие задачи начинают свой жизненный цикл в активном состоянии,
						асинхронные операции, которые они представляют, уже были инициированы и их статус задачи — это значение перечисления, отличное от TaskStatus.Created.
						Необходимо активировать все задачи, возвращаемые методами TAP. 
						
				Отмена (необязательно)
					Отмена является необязательной как для асинхронной реализации метода
						Если операция позволяет выполнить отмену, она предоставляет перезагрузку асинхронного метода, принимающую токен отмены (экземпляр CancellationToken).
						По правилам этот параметр называется cancellationToken.

					Асинхронная операция отслеживает этот токен на наличие запросов на отмену.
						Если операция получает запрос на отмену, системой может быть принято решение об удовлетворении запроса и отмене операции.
						Если запрос на отмену приводит к преждевременному завершению работы, метод TAP возвращает задачу в состоянии Canceled - отсутствует результат и исключение не создается.
												
						Состояние Canceled считается конечное состоянием  IsCompleted = true
							любые продолжения задачи Canceled, планируются или исполняются, если не выбран параметр отказа от продолжения, такой как NotOnCanceled. 
						любой код, который асинхронно ожидает отмененной задачи с использованием языковых возможностей, продолжает выполняться,
							но получает исключение OperationCanceledException или производное исключение. 

					Если токен отмены запросил отмену до вызова метода TAP
						если отмена запрошена во время выполнения асинхронной операции, она не обязательно примет запрос на отмену. 
							возвращаемая задача должна завершиться в состоянии Canceled, только если операция завершается в результате запроса отмены. 
							если отмена запрошена, но выполнение продолжается, задача должна завершиться в состоянии RanToCompletion или Faulted.
							
					Отчет о ходе выполнения (необязательно)
						Для некоторых асинхронных операций имеет смысл предоставлять уведомления о ходе выполнения;
						В TAP ход выполнения контролируется в интерфейсе IProgress<T>, который передается в асинхронный метод в качестве параметра 
			
			Асинхронная модель на основе событий (EAP)
					Пространство имен System.Threading предоставляет все необходимые средства для создания высокопроизводительных многопоточных приложений
						Для относительно простых многопоточных приложений компонент BackgroundWorker предоставляет прямолинейное решение.
						Для более сложных асинхронных приложений рекомендуется реализовать класс, который соответствует асинхронной модели на основе событий.
				Асинхронная модель на основе событий применяется для предоставления асинхронного поведения класса. 
				С момента ее появления .NET Framework определяет две модели для предоставления асинхронного поведения: 
					на основе интерфейса System.IAsyncResult
					на основе событий. 
				Общие принципы
					Обычно для всех асинхронных функций лучше применять асинхронную модель на основе событий. 
					Требования, которым она не полностью соответствует, тогда следует реализовать модель IAsyncResult.
				public class MyClass  
				{  
					public void ReadAsync(byte [] buffer, int offset, int count);  
					public event ReadCompletedEventHandler ReadCompleted;  
				}  		
							
			Асинхронная модель программирования (APM)
				Асинхронная операция, использующая шаблон разработки IAsyncResult, реализуется в виде двух методов с именами BeginOperationName и EndOperationName, которые соответственно 
					начинают и завершают асинхронную операцию OperationName.
					Например, класс FileStream предоставляет методы BeginRead и EndRead для асинхронного считывания байтов из файла. Эти методы реализуют асинхронную версию метода Read .
		
				После вызова метода BeginOperationName приложение может продолжить выполнение инструкций в вызывающем потоке, пока асинхронная операция выполняется в другом потоке. 
					Для каждого вызова метода BeginOperationName приложение должно вызывать метод EndOperationName, получающий результаты операции.
				
				public class MyClass  
				{  
					public IAsyncResult BeginRead(  
						byte [] buffer, int offset, int count,
						AsyncCallback callback, object state);  
					public int EndRead(IAsyncResult asyncResult);  
				}  

		Difference between TPL and TAP
			TPL является частью BCL(стандартная библиотека классов платформы, включает system). 
			Он включает в себя Task, а также несколько других высокоуровневых абстракций, связанных с параллелизмом, включая Parallel и Parallel LINQ.
			В центре внимания TPL была параллельная обработка, и использование задач в качестве фьючерсов - хотя и поддерживается - было относительно неиспользуемой функцией.

			TAP это шаблон. Он называется «На основе задач», потому что он повторно использовал тип задачи из TPL в качестве общего типа Future. Задача (и связанные с ней типы) были расширены, 
				чтобы включить больше примитивов для поддержки TAP и асинхронного программирования (например, GetAwaiter (), Task.WhenAll и т. Д.). 
			В наши дни TAP также работает с «подобными задачами», включая ValueTask. TAP ориентирован на асинхронное программирование, а не на параллельную обработку.
					
		Различные реализации асинхронных фоновых задач
			Многие приложения с пользовательским интерфейсом обнаруживают, что им необходимо поддерживать какую-то асинхронную «фоновую» задачу. 
				Точные требования варьируются, но большинству приложений нужна какая-то способность запускать операцию, которая будет выполняться без блокировки пользовательского интерфейса; 
				и сообщать об этой операции обратно потоку пользовательского интерфейса после завершения.
			
			Общие требования
				Не всем приложениям нужно все это, но некоторые общие требования:

				Результаты. Обычно целью - определение некоторого значения или набора значений, которые затем используются для обновления состояния программы.
				Ошибки. Если во время фоновой обработки возникает исключение, то желательно сохранить это исключение, включая его исходный стек вызовов.
				Прогресс. В дополнение к простому обновлению состояния программы после завершения (или ошибки), часто полезно постепенно сообщать о прогрессе.
				Отмена. Для длительных операций  следует включить какой-то механизм отмены. Если возможно, фоновая операция должна иметь способ определить, 
					когда была отменена просьба об отмене, и правильно ответить.
				Верстка. Обычно игнорируемым требованием является возможность вложения фоновых операций. 
				Синхронизация. Обычно существует некоторый пользовательский интерфейс, который необходимо обновить, когда фоновая задача сообщает о ходе выполнения, завершается с результатом,
					завершается с ошибкой или отменяется.
			
			Tasks (Async Methods)
				Лучший общий метод - использовать асинхронные методы с возвратом задач, новые в .NET 4.5 и C # 5.0. Они естественно поддерживают все общие требования:

				Результаты.
						Любой асинхронный метод, возвращающий Task <TResult>, может просто вернуть свой результат напрямую. Результат извлекается в ожидании Задачи <TResult>.
				Ошибки. 
						Любые исключения, сгенерированные заданием, перебрасываются, когда задание ожидается. Стек вызовов правильно сохраняется.
				Прогресс.
						Асинхронные методы используют абстракцию отчетов о прогрессе (IProgress <T>), чтобы сообщать о прогрессе.
				Отмена. 
						Асинхронные методы интегрируются с унифицированной структурой отмены, которая обеспечивает полную поддержку отмены.
				Верстка. 
					Асинхронные методы естественным образом вкладываются в ожидание результатов других асинхронных методов.
					Исключения из внутренних методов правильно распространяются. 
					Отмена может быть легко распространена путем передачи CancellationToken во внутренний метод.
				Синхронизация. Асинхронные методы по умолчанию захватывают и возобновляют свой контекст автоматически.
							
			Tasks (Task Parallel Library)
				Вы также можете использовать задачи без асинхронных методов.

				Результаты. 
					Класс Task <TResult> позволяет естественным образом возвращать результат. Результат извлекается чтением Task <TResult> .Result.
				Ошибки.
					Любые исключения, сгенерированные заданием, перебрасываются при его выполнении. 
					Исходное исключение заключено в AggregateException, поэтому внешнее исключение больше не содержит правильный стек вызовов.
				Отмена. 
					4.0 включает в себя унифицированную структуру отмены, которая обеспечивает полную поддержку отмены
				Верстка. 
					При желании задачи могут быть вложенными; 
					Дочерние задачи правильно распространяют любые исключения вверх, а родительские задачи могут опционально распространять отмену вниз.
					Вложение не является автоматическим, поэтому эту возможность должен предоставлять любой API бизнес-уровня, основанный на задачах.
				Синхронизация. 
					Задачи представляют очень гибкую модель синхронизации, отделяя фактическую операцию от запланированной.
					неудобна;
						планировщик задач пользовательского интерфейса можно получить, вызвав TaskScheduler.FromCurrentSynchronizationContext, находясь в потоке пользовательского интерфейса.
						Этот планировщик может затем использоваться для планирования продолжения задачи, чтобы маршалировать результат, ошибку или обновление отмены в поток пользовательского интерфейса.
				Прогресс. 
					Один из способов сообщить о ходе выполнения задачи - создать другую задачу (обновить пользовательский интерфейс)
						
			BackgroundWorker
				До выпуска .NET 4.0 BackgroundWorker был стандартом де-факто. Он поддерживает большинство требований:

				Результаты. 
					Поддерживать результат немного неловко; делегат DoWork должен установить свойство DoWorkEventArgs.Result своего аргумента. 
					Затем это значение передается делегату RunWorkerCompleted качестве свойства RunWorkerCompletedEventArgs.Result.
				Ошибки. 
					Исключения, создаваемые DoWork, перехватываются и передаются в delgate RunWorkerCompleted как свойство RunWorkerCompletedEventArgs.Error. 
					Этот объект исключения включает в себя правильный стек вызовов; 
						однако, если к свойству RunWorkerCompleteEventArgs.Result обращаются, когда операция завершается с ошибкой, исходное исключение переносится в TargetInvocationException и
						внешнее исключение больше не содержит правильный стек вызовов.
				Прогресс. 
					Любой BackgroundWorker, свойство WorkerSupportsProgress которого имеет значение true, может сообщать о прогрессе. 
					Делегат DoWork вызывает ReportProgress, что вызывает событие ProgressChanged. 
					Отчеты о ходе выполнения всегда асинхронные, поэтому DoWork продолжит работу до фактического выполнения события ProgressChanged.
				Отмена. 	
					Любой BackgroundWorker, свойство WorkerSupportsCancellation которого имеет значение true, может быть отменено. 
					Поток отмены сначала вызывает BackgroundWorker.CancelAsync.	
					Это приводит к тому, что свойство BackgroundWorker.CancellationPending становится истинным. 
					Делегат DoWork должен отслеживать это свойство (проверяя его на регулярной основе) и установить для DoWorkEventArgs.Cancel значение true и возвращать, если операция отменена. 
					Делегат RunWorkerCompleted обнаруживает отмененный результат, проверяя RunWorkerCompletedEventArgs.Cancelled.
				Синхронизация. 
					Самым большим преимуществом BackgroundWorker является его поддержка автоматической синхронизации. 
					События ProgressChanged и RunWorkerCompleted синхронизируются с SynchronizationContext, который имел место при вызове RunWorkerAsync. 
					В большинстве ситуаций RunWorkerAsync вызывается из потока пользовательского интерфейса, поэтому события ProgressChanged и RunWorkerCompleted вызываются в потоке пользовательского интерфейса.
				У BackgroundWorker есть один довольно существенный недостаток.
					Он отлично работает для менее сложных систем, но не легко вкладывается.
				Верстка.
					Проблема BackgroundWorker с вложенностью заключается в том, что делегату DoWork не предоставляется SynchronizationContext для запуска. 
					когда RunWorkerAsync вызывается из DoWork, события ProgressChanged и RunWorkerCompleted на дочернем BackgroundWorker не синхронизируются с потоком пользовательского интерфейса (или с родительским BackgroundWorker). 
					Это можно решить одним из двух способов:
						Если дочерний BackgroundWorker должен синхронизироваться с пользовательским интерфейсом, то родительский BackgroundWorker может вручную установить SynchronizationContext пользовательского интерфейса
							в своем делегате DoWork, вызвав SynchronizationContext.SetSynchronizationContext.
						Если дочерний BackgroundWorker должен синхронизироваться с родительским BackgroundWorker
							родительский BackgroundWorker может запустить цикл синхронизации  с использованием объекта, подобного Nito.Async.ActionDispatcher. 
							В качестве альтернативы родительский BackgroundWorker может быть полностью заменен Nito.Async.ActionThread
										
			Delegate.BeginInvoke
				Каждый делегат в .NET поддерживает асинхронный вызов. Это метод более низкого уровня, который не требует отдельного объекта (например, Task или BackgroundWorker) 
					для определения асинхронной операции. Поскольку он находится на более низком уровне, он поддерживает меньше стандартных требований:

				Результаты. 
					Результат делегата может быть получен путем вызова Delegate.EndInvoke, даже если асинхронный делегат уже завершен.
				Ошибки. 
					Любое исключение, выброшенное делегатом, сохраняется и перебрасывается Delegate.EndInvoke,сохраняя стек вызовов.
				Этот низкоуровневый подход не полностью поддерживает эти требования:
`				Прогресс. 
					Делегат должен быть предназначен для поддержки отчетности о ходе работы; 
					Один из способов сделать это состоит в том, чтобы метод принял другой делегат в качестве одного из своих аргументов и вызвал этот делегат для сообщения о прогрессе.
				Отмена. 
					Нет встроенной поддержки отмены, но делегат может регулярно проверять наличие сигнала отмены (например, volatile bool или ManualResetEvent).
				Верстка.
					делегаты могут асинхронно вызывать других делегатов; 
					но нет понятия «родительский» и «дочерний» асинхронные делегаты. Распространение ошибок происходит автоматически, а распространение отмены - нет.
				Синхронизация. 
					Для асинхронных делегатов автоматическая синхронизация отсутствует
						два общих решения:
							Используйте классы AsyncOperation и AsyncOperationManager. Эти типы предоставляют тонкую оболочку для SynchronizationContext, обеспечивая простую (асинхронную) синхронизацию прогресса и завершения. 
								Недостатком этих классов является то, что они не поддерживают вложенность. 
							Используйте класс SynchronizationContext напрямую. Код синхронизации немного сложнее, но возможно поддерживать вложение.
												
			ThreadPool.QueueUserWorkItem
				Один из подходов самого низкого уровня - поставить работу в очередь непосредственно в ThreadPool. К сожалению, этот подход не поддерживает ни одно из требований напрямую;

				Результаты. 
					Делегат, переданный в ThreadPool.QueueUserWorkItem, не может вернуть значение. 
						Чтобы вернуть результат, нужно либо использовать дочерний объект аргумент, либо передать лямбда-выражение, связанное с переменной, содержащей возвращаемое значение.
				Ошибки. 
					Если делегат, поставленный в очередь в ThreadPool, разрешает распространение исключения, тогда весь процесс уничтожается. 
					Если возможны какие-либо ошибки, они должны быть заключены в попытку… catch, и объект исключения «возвращается» в вызывающий поток
					Исключение можно перебросить с правильной трассировкой стека, вызвав PrepareForRethrow из библиотеки Rx.
				Другие требования имеют те же проблемы (и смягчающие решения), что и подход Delegate.BeginInvoke выше
			
									
Многопоточность
	Пул управляемых потоков
		Класс System.Threading.ThreadPool обеспечивает приложение пулом рабочих потоков, управляемых системой, позволяя пользователю не углубляться на управлении потоками. 
		пул управляемых потоков — это самый простой способ воспользоваться преимуществами нескольких потоков для небольших фоновых задач
		В Framework 4 > использовать пул потоков стало значительно проще через Task и Task<TResult>, которые выполняют в потоках пула асинхронные задачи.
			
		Платформа .NET использует потоки из пула:
			для операций библиотеки параллельных задач (TPL), 
			асинхронного ввода-вывода, обратных вызовов таймера, регистрируемых операций ожидания, 
			асинхронного вызова методов с использованием делегатов и для подключения к сокетам System.Net.									
							
		Минимальные значения пула потоков
			Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу. 
				минимальное значение потоков - ThreadPool.GetMinThreads.
			При достижении минимума пул потоков может создавать дополнительные потоки или ожидать завершения некоторых задач.
				пул потоков создает и уничтожает рабочие потоки в целях оптимизации пропускной способности
					это количество задач, выполняемых в единицу времени. 
					слишком малое количество потоков препятствует оптимальному использованию доступных ресурсов
					слишком большое их количество может усиливать конкуренцию за ресурсы.
		Использование пула потоков
			Самым простым способом использования пула потоков является применение библиотеки параллельных задач (TPL).
					По умолчанию такие типы TPL, как Task и Task<TResult>, используют потоки из пула для выполнения задач.
				Пул потоков также можно использовать путем вызова 
					из управляемого кода ThreadPool.QueueUserWorkItem
					из неуправляемого кода ICorThreadpool::CorQueueUserWorkItem 
					передачи делегата System.Threading.WaitCallback, представляющего метод, который выполняет задачу.
				
			Другим способом использования пула потоков - помещение в очередь рабочих элементов, которые имеют отношение к операции ожидания, 
				с помощью метода ThreadPool.RegisterWaitForSingleObject и передача дескриптора System.Threading.WaitHandle методом System.Threading.WaitOrTimerCallback, при получении сигнала или истечении времени ожидания
			Потоки из пула потоков используются для вызова методов обратного вызова.
			
		Когда не следует использовать потоки из пула потоков
			Существует ряд сценариев, в которых следует создавать собственные потоки и работать с ними, а не использовать потоки из пула:
			Необходим основной поток.
			Поток должен иметь определенный приоритет.
			Имеются задачи, которые приводят к блокировке потока на длительное время.
				Для пула потоков определено максимальное количество потоков, большое число заблокированных потоков в пуле может препятствовать запуску задач.
			Необходимо поместить потоки в однопотоковое подразделение. 
			Все потоки ThreadPool находятся в многопотоковом подразделении.
			Необходимо иметь постоянное удостоверение, сопоставленное с потоком, или назначить поток задаче.
			
	Общие сведения о примитивах синхронизации
	
		Переменные от которых зависит выбор алгоритма блокировок
			Конфигурация системы
				одноядерная система
				однопроцессорная многоядерная
				многопроцессорная
				гибридная система
			Конфигурация длин квантов
				короткие (2 такта интервального таймера) - для десктопа- 30 мс
				длинные (12 тактов для интервального таймера) для сервена - 180мс
			Приоритеты снимающего блокировку и освобождающегося потоков
			Время блокирования	
				Сверхкороткое
				Среднее
				Длинное
		Одноядерная система
		в рамках одного ядра потоки выполняются последовательно.
		Операционная система разбивает потоки на части и выполняет частями, чтобы создавалась видимость параллеьной работы
			Блокировка уровня ядра
				не можем ждать второй поток
				оба потока работают на одном ядре. один берет - второй тоже пытается
				пока первый поток не отпустит блокировку, время другие не получат
				большинство потоков не участвуют в планировании и после ожидания(снятия блокировки) пробуждаются с повышенным приоритетом
			Уровня пользователя
				завязана на процессор. 
				жрет процессорное время на длинную дистанцию не подходит
			Гибридная
				комбинация дву выше. есть свое состояние + возможность перейти на уровень ядра
				если за определенное время не получили блокировку - переходим на уровень ядра
				частично сжирается прцессорное время прии использовании пользовательской
		Средняя	блокировка
			Блокировка уровня ядра
				время входа в уровень ядра может занять больше врменеи больше чем в гибридной
			Уровня пользователя
				потребляет процессорное время
			Гибридная
				в случае цикла - бесполезен.
				Возможно использование thread yield: чтобы не уходить на уровень ядра, засыпаем и пробуждаемся. тогда в ядро вообще не уходим
				идеально отрабатывает
		Короткая блокировка
			Блокировка уровня ядра
				много время уходит на сходить и выйти из ядра
			Уровня пользователя
				
			Гибридная
				хороша
				примитив понимает, что блокировка и делает thread yeld
				нет пропуска по коду
		Множественная Короткая блокировка
			Блокировка уровня ядра
				очень дорог вход и выход из блокировки 
				и разваливается цикл обработки потоков
			Уровня пользователя
				вообще не работает
			Гибридная
					
		Блокировки уровня ядра отлично работаю в длинную
		Вариант в среднюю и короткую должен спиновать
			пробовать связть пользовательскую
			не получилось Yield
			пробуем еще
			так несколько раз
			не получилось? уходим в блокировку уровня ядра
		однопроцессорная Многоядерная система
			длинная блокировка
				Блокировка уровня ядра
					работает правильно и корректно.
					оптускает процессорное время
					расходы на вход и на выход малы в сравнении с дистанцией блокировки
				Уровня пользователя
					не работает
				Гибридная	
					удобна, когда не понятно длинная будет блокировка или короткая
			средняя блокировка
				Блокировка уровня ядра
					работает правильно и корректно.
					оптускает процессорное время
					расходы на вход и на выход малы в сравнении с дистанцией блокировки
				Уровня пользователя
					не работает
				Гибридная	
					удобна, когда не понятно длинная будет блокировка или короткая
			короткая блокировка
				Блокировка уровня ядра
					не подходит
				Уровня пользователя
					не подходит. подходит только когда алгоритм без блокировок. коллекции lock free
				Гибридная	
					удобна, когда не понятно длинная будет блокировка или короткая
					без ухода в ядро tread yield
		lock
			конвои блокировок снижают производительность
			друг за другом выполняются потоки
			lock берет блокировку в рамках кванта, пока квант отработает
		
		Выаоды
			на длинной дистанции блокировка уровня ядра лучший вариант
			на коротких - гибридные. могут проверить на каком ядре(одноядерный-многоядерный), могут првоерить какого типа блокировка(длинная-короткая)
			необходимо понимать,что можно попасть на одноядерный вариант
			при понимании на каких ядрах идет работа можно оптимизировать
				
		Примитивы уровня ядра
			мьютексы, семафоры, события, таймеры
		уровень пользователя
			voilate,
			Interlocked
		гибридные 
			lock, monitor
			readerWritelock/readerWritelockSlim
			
		Платформа .NET предоставляет ряд типов для синхронизации доступа к общему ресурсу или координации взаимодействия потоков.
		Несколько примитивов синхронизации .NET являются производными от класса System.Threading.WaitHandle, который инкапсулирует собственный дескриптор операционной 
			системы синхронизации и использует механизм сигнализации для взаимодействия потоков из System.Threading:
				Mutex, который предоставляет монопольный доступ к общему ресурсу. Если мьютексом не владеет ни один поток, сообщается состояние мьютекса.
				Semaphore, ограничивающий число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.
					Состояние семафора становится сигнальным, когда это число становится больше нуля, и несигнальным, когда равно нулю.
				EventWaitHandle, представляет событие синхронизации потоков
					может быть в сигнальном или несигнальном состоянии.
				AutoResetEvent, производный от EventWaitHandle
					при получении сигнала автоматически сбрасывается в сигнальное состояние после освобождения одиночного потока в состоянии ожидания.
				ManualResetEvent, который является производным от EventWaitHandle
					при получении сигнала остается в сигнальном состоянии до вызова метода Reset.
					
	Синхронизация доступа к общему ресурсу
		Платформа .NET предоставляет ряд примитивов синхронизации для управления доступом нескольких потоков к общему ресурсу.
		
		Monitor класс
			Класс Monitor предоставляет монопольный доступ к общему ресурсу, блокируя или разблокируя объект, определяющий ресурс. 
				Во время блокировки поток, удерживающий блокировку, может снова поставить и снять блокировку.
				Любой другой поток не может получить блокировку, и метод Monitor.Enter ожидает снятия блокировки. 
				Метод Enter получает снятую блокировку. 
				Можно также использовать метод Monitor.TryEnter, чтобы задать количество времени, в течение которого поток пытается получить блокировку. 
				Так как класс Monitor реализует привязку потока, поток, который получил блокировку, должен снять ее, вызвав метод Monitor.Exit.
			Можно координировать взаимодействие потоков, которые получают блокировку для одного и того же объекта, с помощью методов Monitor.Wait, Monitor.Pulse и Monitor.PulseAll.
			
		Mutex класс
			Класс Mutex, как и Monitor, предоставляет монопольный доступ к общему ресурсу.
				С помощью вызова одной из перегрузок метода Mutex.WaitOne можно запросить владение мьютексом. 
				Как и Monitor, Mutex реализует привязку потока, и поток, который получил мьютекс, должен освободить его, вызвав метод Mutex.ReleaseMutex.
			В отличие от Monitor, класс Mutex может использоваться для межпроцессной синхронизации. 
				Для этого нужно использовать именованный мьютекс, который виден в операционной системе. 
				Чтобы создать экземпляр именованного мьютекса, используйте конструктор Mutex, который задает имя. 
				Также можно вызвать метод Mutex.OpenExisting, чтобы открыть существующий именованный системный мьютекс.	
				
		Структура SpinLock
			Структура System.Threading.SpinLock, как и Monitor, предоставляет монопольный доступ к общему ресурсу на основе доступности блокировки. 
			Когда SpinLock пытается получить блокировку, которая недоступна, этот примитив будет ожидать в цикле, постоянно проверяя возможность получения блокировки.
			
		Класс ReaderWriterLockSlim
			Класс ReaderWriterLockSlim предоставляет монопольный доступ к общему ресурсу для записи и обеспечивает одновременный доступ к ресурсу для чтения нескольким потокам. 
			Используется для синхронизации доступа к общей структуре данных, поддерживающей потокобезопасные операции чтения, но требующей монопольного доступа для выполнения операции записи.
			Если поток запрашивает монопольный доступ
				последующие запросы модуля чтения и записи блокируются, пока все существующие модули чтения не освободят блокировку, 
				модуль записи получает и снимает блокировку.
				
		Классы Semaphore и SemaphoreSlim
			Классы Semaphore и SemaphoreSlim ограничивают число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов. 
				Дополнительные потоки, запрашивающие ресурс, ожидают освобождения семафора любым из потоков. 
				Так как семафор не реализует привязку потока, поток может занять семафор, а другой поток может его освободить.
			SemaphoreSlim — это упрощенная альтернатива Semaphore, которую можно использовать для синхронизации в рамках одного процесса.
			В Windows можно использовать Semaphore для внутрипроцессной синхронизации.
			Для этого необходимо создать экземпляр Semaphore, выполняющий роль именованного системного семафора. 
			SemaphoreSlim не поддерживает именованные системные семафоры.
			
		Взаимодействие потоков или сигнализация
			Взаимодействие потоков (или сигнализация потоков) означает, что поток должен ждать уведомления или сигнала от одного или нескольких потоков, чтобы продолжить. 
				Например, если поток A вызывает метод Thread.Join потока B, поток А блокируется до завершения потока B. 
			Предыдущие примитивы синхронизации, реализуют другой механизм сигнализации: 
				снятие блокировки потоком является сигналом другому потоку о возможности продолжать исполнение, получив блокировку.		
				
		lock.
			Оператор lock получает взаимоисключающую блокировку заданного объекта перед выполнением определенных операторов, а затем снимает блокировку. 
			Во время блокировки поток, удерживающий блокировку, может снова поставить и снять блокировку. 
			Любой другой поток не может получить блокировку и ожидает ее снятия.					
			Ожидание внутри lock-а - это рецепт создания deadlock-ов.	
				после await мы можем продолжить работу в другом потоке, и в итоге мы можем разблокировать другой поток, а не тот, который изначально занимал эту блокировку.
				Есть и другие проблемы, связанные с ожиданием внутри блокировки, такие как инвертирование порядка блокировки
				    public ActionResult Deadlock()
					{
						StartWork().Wait();
						return View();
					}
					private async Task StartWork()
					{
						await Task.Delay(100);
						var s = "Just to illustrate the code following await";
					}
				Этот код так же вызовет дедлок, так как в момент вызова StartWork().Wait() единственный разрешённый поток будет заблокирован и будет ожидать окончания операции StartWork(), 
					а она никогда не закончится, так как поток, в котором выполнение должно продолжиться, занят ожиданием.	
				В netcore дедлока не будет. Это связано с тем, что в ASP.NET Core нет контекста синхронизации
			Можем заменить lock семафором.
				Вызов WaitAsync на семафоре создает задачу, которая будет завершена, когда этому потоку будет предоставлен доступ к семафору.
				
	Управляемая поточность
		При разработке для компьютеров как с одним, так и с несколькими процессорами, необходимо, чтобы приложение обеспечивало наиболее эффективное взаимодействие с пользователем
		Использование нескольких потоков выполнения — это один из способов обеспечить в приложении возможность реагирования на действия пользователя при одновременном использовании процессора 
			для выполнения задач между появлением или даже во время появления событий пользователя. 
		Потоки и работа с ними
			Многопоточность позволяет увеличивать скорость реагирования приложения и, если приложение работает в многопроцессорной или многоядерной системе, его пропускную способность.
			
			Процессы и потоки
				Процесс — это исполнение программы. Операционная система использует процессы для разделения исполняемых приложений. 
				Поток — это основная единица, которой операционная система выделяет время процессора. 
				Каждый поток имеет приоритет планирования и набор структур, в которых система сохраняет контекст потока, когда выполнение потока приостановлено. 
				Контекст потока содержит все сведения, позволяющие потоку возобновить выполнение, например набор регистров процессора и стек потока. 
					Несколько потоков могут выполняться в контексте процесса. 
					Все потоки процесса используют общий диапазон виртуальных адресов.
				Поток может исполнять любую часть программного кода, включая части, выполняемые в данный момент другим потоком.
						Платформа .NET Framework предоставляет способ изоляции приложений в процессе с помощью доменов приложений. (Домены приложений недоступны в .NET Core.) 
		
				По умолчанию программа .NET запускается с одним потоком, часто называемым основным потоком. 
					Она может создавать дополнительные потоки для выполнения кода параллельно или одновременно с основным потоком. 
					Эти потоки называются рабочими потоками.
				
			Цели применения нескольких потоков
				Использование нескольких потоков, 
					для увеличения скорости реагирования приложения и воспользоваться преимуществами многопроцессорной или многоядерной системы, 
					для увеличения пропускной способность приложения. 
				Использование рабочих потоков для выполнения длительных операций. 
				Использование для оперативной реакции на входящие сообщения 
				Использование для связи с сетью или устройством.
				Если программа выполняет операции, которые могут выполняться параллельно, можно уменьшить общее время выполнения через
					выполнения этих операций в отдельных  потоках
					запуска программы в многопроцессорной или многоядерной системе. В такой системе использование многопоточности может увеличить пропускную способность, а также повысить скорость реагирования.
					
			Как использовать многопоточность в .NET
				Начиная с .NET Framework 4 для многопоточности использовать TPL и PLINQ.
				TPL и PLINQ полагаются на потоки ThreadPool. 
				можно использовать класс System.Threading.Thread, который представляет управляемый поток.
				Несколько потоков могут требовать доступ к общему ресурсу. 
					Чтобы сохранить ресурс в неповрежденном состоянии и избежать состояния гонки, необходимо синхронизировать доступ к нему потоков. 
				
		Рекомендации по работе с потоками
			Многопоточность требует тщательного программирования. 
			Большинство задач можно упростить, поместив запросы на выполнение в очередь по потокам пулов потоков.
			При использовании нескольких потоков соблюдайте следующие рекомендации:
				Не использовать
					Thread.Abort для завершения других потоков. Вызов метода Abort для другого потока аналогичен вызову исключения в этом потоке, когда неизвестно, на каком этапе находится обработка этого потока.
					Thread.Suspend и Thread.Resume для синхронизации действий между потоками. Используйте вместо этого Mutex, ManualResetEvent, AutoResetEvent и Monitor.
					типы как объекты блокировки. Следует избегать кода lock(typeof(X)) или Monitor.Enter с объектами Type. Для каждого конкретного типа существует только один экземпляр System.Type в каждом домене приложения.

				Не контролируйте выполнение рабочих потоков из основной программы (например, с помощью событий). 
					рабочие потоки должны ожидать доступности задания,  выполняли его и оповещали другие части программы о его завершении. 
					Если рабочие потоки не блокируются, можно использовать потоки из пула потоков.
												
				Внимание к блокировке экземпляров, например lock(this). Если другой код в приложении, который является внешним для типа, заблокирует объект, 
					может возникнуть взаимоблокировка.
				Каждый поток, входящий в монитор, обязательно вышел из этого монитора, даже при исключении в мониторе. 
					lock делает это автоматически через вызов метода Monitor.Exit с помощью блока finally. 
					мьютекс автоматически освобождается, как только прекращается выполнение владеющего им потока.
				Для задач, которые требуют различных ресурсов, использовать несколько потоков и не назначать несколько потоков одному ресурсу. 
				Вместо оператора lock для простого изменения состояния лучше использовать методы класса Interlocked
					lock — хороший универсальный инструмент, но класс Interlocked обеспечивает высокую производительность для обновлений, которые должны быть атомарными. 
					Если конкуренции нет, он выполняет внутри единственный префикс lock.
					
		Рекомендации для библиотек классов
			При разработке библиотек классов для многопоточности необходимо учитывать следующие рекомендации.
			Старайтесь не создавать потребность в синхронизации.
				Особенно это относится к коду, который используется наиболее часто. 
			Данные экземпляров не должны быть потокобезопасными по умолчанию.
				Добавление блокировок для создания потокобезопасного кода
					снижает производительность, 
					увеличивает конфликт блокировки 
					создает условия для возникновения взаимоблокировок. 
				В обычных моделях приложений пользовательский код одновременно выполняется только одним потоком, что уменьшает необходимость потокобезопасности. 
				Поэтому библиотеки классов .NET Framework не являются потокобезопасными по умолчанию.
			Не предоставляйте статические методы, изменяющие статическое состояние. 
				В обычных сценариях сервера статическое состояние используется запросами совместно, а значит, код одновременно могут выполнять сразу несколько потоков. 
				Это открывает возможность для появления потоковых ошибок. 
				Нужно применить конструктивный шаблон, инкапсулирующий данные в экземпляры, которые не являются общими для запросов.
				
		Синхронизация данных для многопоточности
			Если несколько потоков могут вызывать свойства и методы отдельного объекта, эти вызовы важно синхронизировать. 
				В противном случае поток может прерваться действиями другого потока, а объект может остаться в недопустимом состоянии. 
				Класс, члены которого защищены от подобных прерываний, называется потокобезопасным.
				
			.NET предоставляет несколько способов синхронизации доступа к экземпляру и статическим членам:
				Синхронизированные области кода. 
					Используя класс Monitor, можно синхронизировать только тот блок кода, которому эту требуется, повысив тем самым производительность.
				Синхронизация вручную. 
					Можно использовать объекты синхронизации, предоставляемые библиотекой классов .NET.
				Синхронизированные контексты.
					Для приложений .NET Framework и Xamarin вы можете использовать SynchronizationAttribute для реализации простой автоматической синхронизации для объектов ContextBoundObject.
				Классы коллекции в пространстве имен System.Collections.Concurrent.
					Эти классы предоставляют встроенные синхронизированные операции добавления и удаления. 
			Синхронизации нет
				По умолчанию для объектов. Любой поток может получить доступ к любому методу или полю в любое время. Одновременно обращаться к этим объектам может только один поток.
			Синхронизация вручную
				Библиотека классов .NET предоставляет ряд классов для синхронизации потоков. См. раздел Обзор примитивов синхронизации.							
			Синхронизированные области кода
				Если код выполняется потоком, он пытается получить блокировку. Если блокировка уже получена другим потоком, поток блокируется, пока блокировка не станет доступной. 
				Когда поток выходит из синхронизированного блока кода, блокировка снимается независимо от того, каким образом поток выходит из блока.						
			Поддержка компилятора
				Если в коде блока возникает исключение, блокировка, введенная оператором lock автоматически снимается. 
				Компиляторы C# выдают блок try/finally с Monitor.Enter в начале оператора try и Monitor.Exit в блоке finally. 
				Если исключение возникает в блоке lock запускается обработчик finally, позволяющий выполнить очистку.
			
		Основные и фоновые потоки
			Управляемый поток может быть основным или фоновым. 
				Фоновые потоки отличаются от основных только в одном аспекте: фоновый поток не поддерживает работу управляемой среды выполнения. 
			После того, как в управляемом процессе остановятся все основные потоки, система принудительно останавливает все фоновые потоки и завершает работу процесса.
			
		Управляемые и неуправляемые потоки 
  			Управление всеми потоками осуществляется посредством класса Thread. 
			Среда выполнения отслеживает в своем процессе все потоки, которые когда-либо выполняли код в управляемой среде. 
				Другие потоки она не отслеживает. 
			Когда неуправляемый поток входит в среду выполнения, например, посредством вызываемой оболочки COM, система проверяет локальное 
				хранилище потока данного потока для поиска внутреннего управляемого объекта Thread . 
				Если найден, среда выполнения уже оповещена об этом потоке. 
				Если не найден, среда выполнения создает новый объект Thread и устанавливает его в локальном хранилище потока данного потока.
				
		Локальное хранилище потока: статические поля потока и области данных
			Используют управляемую локальную память потока для хранения данных, которые являются уникальными для потока и домена приложения. 
			два способа работы с локальной памятью: 
				статические поля потоков  - можно применять, если нельзя точно прогнозировать потребности во время компиляции.
						Статические поля потоков обеспечивают более высокую производительность.
						Они также позволяют выполнять проверки типов во время компиляции.
				ячейки данных 
			области данных - если фактические требования могут определяться только во время выполнения, используйте  
					работают медленнее
					менее удобны в использовании, чем статические поля потоков. 
					данные в качестве типа Object, поэтому перед использованием необходимо привести их к правильному типу.
					
		Домены приложений			
			Операционные системы и среды выполнения содержат средства изоляции приложений друг от друга.
			в Windows для изоляции приложений используются процессы. 
				Эта изоляция необходима, чтобы выполняемый одним приложением, не мог нарушить работу других приложений.
			Домены приложений -  изолированная область для безопасности, надежности, управления версиями и выгрузки сборок. 
			Домены приложений обычно создаются базовыми средами выполнения, отвечающие за начальную загрузку среды CLR перед запуском приложения.	
			
	Почему в NetCore нет контекста синхронизации
		Когда асинхронный обработчик возобновляет выполнение в устаревшем ASP.NET, продолжение ставится в очередь в контексте запроса. 
			Продолжение должно ждать любых других продолжений, которые уже были поставлены в очередь (одновременно может выполняться только одно продолжение). 
			Когда он готов к запуску, поток берется из пула потоков, входит в контекст запроса и затем возобновляет выполнение обработчика. Этот «повторный вход» 
				в контекст запроса включает в себя ряд вспомогательных задач, таких как настройка HttpContext.Current и идентификация и культура текущего потока.
		При использовании контекстного подхода ASP.NET Core, когда асинхронный обработчик возобновляет выполнение, 
			поток берется из пула потоков и выполняет продолжение. Очереди контекста избегают, и нет необходимости «ввода» контекста запроса.
			Кроме того, механизм async / await сильно оптимизирован для сценария без контекста. Для асинхронных запросов просто меньше работы.	
			
	Шпаргалка по шаблонам проектирования
		поведенческие
			цепочка обязанностей
				 позволяет передавать запросы последовательно по цепочке обработчиков. 
				 Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
				 Применимость
					 Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, 
					 какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
			команда
				превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, 
				ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
				 Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
				 Позволяет реализовать простую отмену и повтор операций.
				 Позволяет реализовать отложенный запуск операций.
				 Позволяет собирать сложные команды из простых.
				 Реализует принцип открытости/закрытости.
				 Усложняет код программы из-за введения множества дополнительных классов.
			интерпретатор
				Задача поиска строк по образцу может быть решена посредством создания интерпретатора, определяющего грамматику языка
				получая формальный язык, определяет представление его грамматики и интерпретатор, использующий это представление для обработки выражения языка.
			итератор
				 даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.
				 Упрощает классы хранения данных.
				 Позволяет реализовать различные способы обхода структуры данных.
				 Позволяет одновременно перемещаться по структуре данных в разные стороны.
				 Не оправдан, если можно обойтись простым циклом.
			посредник
				позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.
				Применимость
					Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.
					Посредник позволяет поместить все эти связи в один класс, после чего вам будет легче их отрефакторить, сделать более понятными и гибкими.
				Устраняет зависимости между компонентами, позволяя повторно их использовать.
				Упрощает взаимодействие между компонентами.
				Централизует управление в одном месте.
				Посредник может сильно раздуться.
			хранитель (momento)
				Когда вам нужно сохранять мгновенные снимки состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии.
				Не нарушая инкапсуляции фиксирует и выносит за пределы объекта его внутреннее состояние так, чтобы позднее можно было восстановить в нем объект.
				Паттерн предлагает держать копию состояния в специальном объекте-снимке с ограниченным интерфейсом, позволяющим, например, узнать дату изготовления или название снимка. 
				Но, с другой стороны, снимок должен быть открыт для своего создателя, позволяя прочесть и восстановить его внутреннее состояние.
				Уменьшает зависимость между клиентом и обработчиками.
				Реализует принцип единственной обязанности.
				Реализует принцип открытости/закрытости.
				Запрос может остаться никем не обработанным.
			наблюдатель
				создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
				 Издатели не зависят от конкретных классов подписчиков и наоборот.
				 Вы можете подписывать и отписывать получателей на лету.
				 Реализует принцип открытости/закрытости.
				 Подписчики оповещаются в случайном порядке.
			состояние
				 позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.
				 Избавляет от множества больших условных операторов машины состояний.
				 Концентрирует в одном месте код, связанный с определённым состоянием.
				 Упрощает код контекста.
				 Может неоправданно усложнить код, если состояний мало и они редко меняются.
			стратегия 
				определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, 
				после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
				 Горячая замена алгоритмов на лету.
				 Изолирует код и данные алгоритмов от остальных классов.
				 Уход от наследования к делегированию.
				 Реализует принцип открытости/закрытости.
				 Усложняет программу за счёт дополнительных классов.
				 Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.
			шаблонный метод
				определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. 
				Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.
				Облегчает повторное использование кода.
				Вы жёстко ограничены скелетом существующего алгоритма.
				Вы можете нарушить принцип подстановки Барбары Лисков, изменяя базовое поведение одного из шагов алгоритма через подкласс.
				С ростом количества шагов шаблонный метод становится слишком сложно поддерживать.
				internal abstract class GameObject
				{protected int PlayersCount;}
				 public class Monopoly : GameObject{protected override void PlayersCount()}
			посетитель
				позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.
				есть клиент
				Упрощает добавление операций, работающих со сложными структурами объектов.
				Объединяет родственные операции в одном классе.
				Посетитель может накапливать состояние при обходе структуры элементов.
				Паттерн не оправдан, если иерархия элементов часто меняется.
				Может привести к нарушению инкапсуляции элементов.
				Point p = new Point2D(1, 2);
				IVisitor v = new Chebyshev();
				p.Accept(v);
		порождающие
			абстрактная фабрика
				позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
				Гарантирует сочетаемость создаваемых продуктов.
				Избавляет клиентский код от привязки к конкретным классам продуктов.
				Выделяет код производства продуктов в одно место, упрощая поддержку кода.
				Упрощает добавление новых продуктов в программу.
				Реализует принцип открытости/закрытости.
				Усложняет код программы из-за введения множества дополнительных классов.
				Требует наличия всех типов продуктов в каждой вариации.
			строитель
				позволяет создавать сложные объекты пошагово.
				Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
				Позволяет создавать продукты пошагово.
				Позволяет использовать один и тот же код для создания различных продуктов.
				Изолирует сложный код сборки продукта от его основной бизнес-логики.
				Усложняет код программы из-за введения дополнительных классов.
				Клиент будет привязан к конкретным классам строителей, так как в интерфейсе строителя может не быть метода получения результата.
				      Director director = new Director();
					  Builder b1 = new ConcreteBuilder1();
					  director.Construct(b1);
			фабричный метода
				 определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
				 Избавляет класс от привязки к конкретным классам продуктов.
				 Выделяет код производства продуктов в одно место, упрощая поддержку кода.
				 Упрощает добавление новых продуктов в программу.
				 Реализует принцип открытости/закрытости.
				 Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.
			прототип
				 позволяет копировать объекты, не вдаваясь в подробности их реализации.
				 Позволяет клонировать объекты, не привязываясь к их конкретным классам.
				 Меньше повторяющегося кода инициализации объектов.
				 Ускоряет создание объектов.
				 Альтернатива созданию подклассов для конструирования сложных объектов.
				 Сложно клонировать составные объекты, имеющие ссылки на другие объекты.
			одиночка	
				 гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
				 Применимость
					Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, 
					общий доступ к базе данных из разных частей программы).
					 Гарантирует наличие единственного экземпляра класса.
					 Предоставляет к нему глобальную точку доступа.
					 Реализует отложенную инициализацию объекта-одиночки.
					 Нарушает принцип единственной ответственности класса.
					 Маскирует плохой дизайн.
					 Проблемы мультипоточности.
					 Требует постоянного создания Mock-объектов при юнит-тестировании.
		структурные
			адаптер
				позволяет объектам с несовместимыми интерфейсами работать вместе.
				Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
				Усложняет код программы из-за введения дополнительных классов.
				Адаптер применяется постфактум, чтобы заставить несовместимые классы работать вместе.
			мост
				разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.
				Позволяет строить платформо-независимые программы.
				Скрывает лишние или опасные детали реализации от клиентского кода.
				 Реализует принцип открытости/закрытости.
				 Усложняет код программы из-за введения дополнительных классов.
			компоновщик
				позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.
				 Упрощает архитектуру клиента при работе со сложным деревом компонентов.
				 Облегчает добавление новых видов компонентов.
				 Создаёт слишком общий дизайн классов.
			декоратор
				позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».
				Применимость
				Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.
				Когда нельзя расширить обязанности объекта с помощью наследования.
				Большая гибкость, чем у наследования.
				Позволяет добавлять обязанности на лету.
				Можно добавлять несколько новых обязанностей сразу.
				Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.
				Трудно конфигурировать многократно обёрнутые объекты.
				Обилие крошечных классов.
			фасад
				предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.
				применимость
					Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.
					Когда вы хотите разложить подсистему на отдельные слои.
				 Изолирует клиентов от компонентов сложной подсистемы.
				Фасад рискует стать божественным объектом, привязанным ко всем классам программы.	
			приспособленец
				шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.
			прокси
				шаблон проектирования, предоставляющий объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).
				удалённый заместитель;
				виртуальный заместитель может выполнять оптимизацию;
				защищающий заместитель;
				«умная» ссылка(указатель);
				резкое увеличение времени отклика.
				Шаблон Proxy может применяться в случаях работы с сетевым соединением, с огромным объектом в памяти (или на диске) или с любым другим ресурсом, который сложно или тяжело копировать. Хорошо известный пример применения — объект, подсчитывающий число ссылок.
				
	Архитектура
		Порты и адаптеры
			явно определяет три фундаментальных блока кода в системе:
				То, что позволяет запускать пользовательский интерфейс, независимо от его типа.
				Системная бизнес-логика или ядро приложения. Его использует UI для совершения реальных транзакций.
				Код инфраструктуры, который соединяет ядро нашего приложения с такими инструментами, как БД, поисковая система или сторонние API.
				
			Ядро приложения. 
				Этот код позволяет совершать реальные действия в системе
				С ним могут работать несколько пользовательских интерфейсов (WEB, PHONE, CLI..), всё выполняется на одном ядре.
				Типичный поток выполнения идёт от кода в UI через ядро приложения к коду инфраструктуры, и обратно к ядру приложения и ответ в UI.
				
			Инструменты
				инструменты, которые использует приложение(ядро БД, поисковая система, веб-сервер и т.д).
				отличия инструментов
					консоль CLI и веб-сервер говорят приложению что-то сделать, ядро СУБД, наоборот, получает команды от приложения. 
				общее
					 и то, и другое — инструменты, используемыми приложением.
		
			Адаптеры - блоки кода, соединяющие инструменты с ядром приложения
				позволяют бизнес-логике взаимодействовать с определённым инструментом, и наоборот.
			Порты - спецификация того, как инструмент может использовать ядро приложения или наоборот
				в простейшем виде этот порт будет интерфейсом, но фактически он может быть составлен из нескольких интерфейсов и DTO.
				порты  находятся внутри бизнес-логики, а адаптеры — снаружи. 
			
			Первичные адаптеры - говорят приложению что-то делать
				функции: оборачиваются вокруг порта и используют его для указания ядру приложения, что делать. 
						  преобразуют все данные от механизма доставки в вызовы методов в ядре приложения.
						  
				может быть контроллерами или консольными командами,
					внедряются в их конструктор с некоторым объектом,
					класс которого реализует интерфейс (порт), который требует контроллер или консольная команда.
				может быть интерфейсом службы или интерфейсом репозитория, который требуется контроллеру. 
				может быть шиной команд (command bus) или интерфейсом шины запросов (query bus). 
					конкретная реализация шины команд или запросов вводится в контроллер, который затем создает команду или запрос и передаёт его соответствующей шине.		  
			Вторичные или управляемые адаптеры - приложение говорит что-то делать
				функции:
					реализуют порт, интерфейс, а затем вводятся в ядро приложения там, где требуется порт (с указанием типа).
					создается persistence-интерфейс с методом сохранения массива данных и методом удаления строки в таблице по её ID. 
					поэтому везде, где приложение должно сохранить или удалить данные, мы будем требовать в конструкторе объект, который реализует persistence-интерфейс, 
			
			Инверсия управления		
				особенностью этого шаблона является то, что адаптеры зависят от конкретного инструмента и конкретного порта (путём реализации интерфейса). 
				Но бизнес-логика зависит только от порта, созданный для удовлетворения потребностей бизнес-логики и не зависит от конкретного адаптера или инструмента.
				зависимости направлены к центру, то есть налицо инверсия принципа управления на архитектурном уровне.
			
			Важно создавать порты в соответствии с потребностями ядра приложения, а не просто имитировать API инструментов.
			
		Организация ядра приложения
			Архитектура Onion подхватывает слои DDD и включает их в архитектуру портов и адаптеров. 
			уровни нужны чтобы внести порядок в бизнес-логику, внутреннюю часть «шестиугольника» портов и адаптеров. 
			направление зависимостей — к центру.
		
			Уровень приложения (прикладной уровень)
				 это процессы, которые можно запустить в ядре одним или несколькими пользовательскими интерфейсами. 
				 например разделение по ролям доступа
					Варианты использования определяются на прикладном уровне — первом уровне DDD и архитектуры Onion.
				 содержит службы приложений (и их интерфейсы) в качестве объектов первого класса
				 содержит интерфейсы портов и адаптеров (порты), которые включают интерфейсы ORM, интерфейсы поисковых систем, интерфейсы обмена сообщениями и т. д.
				 В случае шины команд или запросов, на этом уровне находятся соответствующие обработчики команд и запросов.
			
			Службы приложений или обработчики команд содержат логику развёртывания варианта использования, бизнес-процесс. 
				Роль:
					использовать репозиторий для поиска одной или нескольких сущностей
					попросить эти сущности выполнить некоторую логику домена
					использовать хранилище, чтобы заново сохранить сущности, эффективно сохраняя изменения данных.

				Обработчики команд можно использовать двумя способами:
					могут содержать логику для выполнения варианта использования;
					можно использовать как простые части соединения в нашей архитектуре, которые получают команду и просто вызывают логику в службе приложения

				содержит инициирование событий приложения, которые представляют собой некоторый результат варианта использования.
				запускают логику, являющуюся побочным эффектом варианта использования, 
					например, отправку сообщений электронной почты, уведомление стороннего API, отправку пуш-уведомления и т.д
		
		Уровень домена
			Объекты на этом уровне содержат данные и логику для управления этими данными, которые являются специфическими для самого домена и не зависят от бизнес-процессов, 
				запускающих эту логику. 
			Они независимы и совершенно не знают о прикладном уровне.
			Сервисы домена
				логика домена должна оставаться вне уровня приложения
				если есть некоторая доменная логика, которая включает в себя различные сущности одинакового или разных типовсоздать доменную службу,
					роль которой состоит в получении набора сущностей и выполнении на них некоторой бизнес-логики. 
					доменная служба принадлежит к доменному уровню и поэтому ничего не знает о классах на прикладном уровне, 
						таких как службы приложений или репозитории.
		Модель домена
			В самом центре находится модель домена. 
			Она не зависит ни от чего за пределами этого круга и содержит бизнес-объекты, что-то представляющие в домене.
			Примерами таких объектов являются, прежде всего, сущности, а также объекты-значения (value objects), перечисления (enums) и любые объекты, используемые в модели домена.

			В модели домена «живут» также события домена. 
				Когда определённый набор данных изменяется, то инициируются эти события, которые содержат новые значения изменённых свойств. 
				Эти события идеально подходят для использования в модуле регистрации событий (event sourcing).
	
	
