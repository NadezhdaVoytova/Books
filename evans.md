# Эрик Эванс
# Модель предметной области в работе
## Переработка знаний
Любая система - это цепочка этапов с разветвлениями как условиями ~или~ и вершинами выбора
### Составление эффективного моделирования
* Установка связи между моделью и релизацией (Связь с действительностью)
* Ввод языка, основанного на модели (Общий понятийный аппарат)
* Разработка информоемкой модели (Содержание общией информации разного рода)
* Дистилляция модели (Отброс второстепенных понятий либо вон, либо в новую модель)
* Мозговые штурмы (Event Storming)

**Переработка знаний**- важный элемент дейтельности программиста. Обработать много информации и сформировать на еёоснове видимую модель. Все это вместе с командой - специалистов предметной области, пользователей систем, технической поддержки.

Плохой стиль переботки - каскадный: специалист -> аналитик -> программист. Знания перетекают в одном направлении и не накапливаются.
Плохой _(Хороший?)_ стиль `итерационный` - если от специалистов приходят таски по очереди и программисты не пытают абстрагироваться.

#### Постоянное обучение
Любая предметная область может приподносить сюрпризы и нельзя ее недооценивать
**NB невежество заставляет делать неверные предположения**
Вся команда должна непрерывно обучаться

#### Информоемкая архитектура
Прояснение через переработку знаний: самых скрытых знаний (правил). Донести важность таких незначительных правил специалистам

#### Углубленные модели
Пjнять что именно необходимо автоматизировать. Первоначальная постановка может быть далека от того, что нужно

## Коммуникация и язык
Модель предметной области может служить основой общего языка для коммуникации в рамках проекта по разработке ПО
**NB Модель - это набор понятий с названиями, терминами, отношениями, взаимосвязями, отражающими понимание предметной области**

**NB Термины и связи - это семантика языка, адаптированная к предметной области**
Язык нужен для разработки информоемкой архитектуры программыю  Отсутствие языка порождает(ухудшает) обмен знаниями не только между специалистами, но и между членами разных команд. Не должно быть перевода между членами.

### Словарь единого языка
* имена классов и основных операций(глаголов)
* термины для обсуждения правил
* термины из принципов высокоуровневой реализации (карта контекстов, крупномасштабная архитектура)
* названия шаблонов

Изменения в языке - это изменения в модели и нужно переименовывать понятия, методы в угоду появившемуся новому знанию
* Нужно старать пользоваться языком, если он неудобен, то это повод пересмотреть термины
* Единый язык должен находить отражение везде: модель (от нее изначально оттталкиваемся), документация, схемы разговор

**Единый язык** - основной носитель тех аспектов, архтектуры, которые не проявляются в коде; крупномасштабной структуре; организающих всю систему, ограниченных контекстов, опредлеляющих отношение между разными системами и моделями, например, шаблонов, относящихся к модели и программной архитектуре

Единый язык сложно внедрять. Может помочь обсуждение вслух: Через дискуссию программисты и специалисты могут найти неточности в ходе своего мышления и, если неточность найдена, ее можно и нужно прояснить.

Единый язык  - это смесь жаргона специалистов, программистов, терминов предметной области. И, как следствие, это потенциальные термины модели, имена ограниченных контекстов и терминология крупномасштабной структуры

### Диаграммы, схемы, диаграммы
* Схемы нужны для более простого взаимодействия (наглядного). Не стоит все переносить на них.
    * можно нарисовать схему с текстом, определить классы и функции словами
    * схема может быть от руки, лишь бы была читаема
* Документация характеристики
    * должна дополнять код и устные обсуждения
    * код не может быть документацией: слишком сух, а иногда и абстракте(или слишком конкретен)
    * в ней не может быть деталей реализации, это обязанность кода
    * должна отразить смысл, помочь понять крупномасштабную архитектуру
    * должна сконцентрировать внимание на ключевых элементах
    * не должна отставать от процесса
    * должна меняться и должна быть гибкой(без лишних инструкций и уточнений)

Документация должна:
* разъяснить понятийный аппарат модели
* помогать ориентироваться в деталях кода
* дать понимание, как должна использоваться модель
* должна быть написана на едином языке
* должна помочь в написании ТЗ, пользовательской документации

**Если документация не влияет на единый язык, т.е ее не заполняют, не используют, то она либо составлена неверно (слишком много - слишком мало), либо не отражает реальной стадии разработки**

### Пояснительная модель
Модель, по которой выполняется проектирование - это один взгляд на проблему, но для обучения, ввода в курс дела полезно иметь вспомогательные точки зрения для лучшей передачи общих данных
Можно предствить предметную область, как пояснительную модель. Пояснительную модель можно расширять схемой или документацией. Например, есть модель в системе терминов, но для непосвященных это может лишь запутать ситуацию и тут-то является пояснительная модель (схема, график) для более наглядного представления. А модель  - это список связей с блоками, отражающая архитектуру приложения, в виде более строгихдиаграмм, таблиц, схем. 
**Важно четко понимать разницу между пояснительной моделью и рабочую модель**

# Связь между моделью и реализацией
Иногда сформуированная модель может быть очень детальной и подробной, но при попытке ее реализовать оказывается множество связей и связности. Т.е она не влияет на разработку разработку
**Модель в DDD  - прочный фундамент для архитектуры приложения**

## Проектирование по модели
Аналитическая модель - результат ананлиза прикладной темы, ее систематизация без учета роли, которую она будет играть в программной системе. Программная архитектура строится опосредовано по аналитической модели, лишь ссылаясь как на "логику" поведения. Но фактически модель не всегда помогает понять предметную область, напротив, запутывая ее.
**Иногда из-за наличия аналитиков разработчики не имеют возможности принять участие в анализе**

## Этапы проектирования и анализа
* извлечь фундаментальные понятия и представить их (анализ)
* задать набор компонентов, которые конструируются с помощью средств разработкидля решения поставленной задачи (проектирование)
* поиск модели между анализом и архитектурой (MDD - model driver design)
Как следствие получаем единый процесс моделирования и проектирвоания.

Модель должна использовать единый язык. Модель будет совершенствоваться итерационно. Вокруг нее будет строиться проектирование

## Парадигмы моделирования и средства программирования
* процедурная
* логическая
* ООП

Каждая из них выполняет свою задачу. И исходя из ориектирования вокруг модели можно выбрать, например, ООП или функциональную парадигму. Архитектура тянет парадигму.

## Анатомия модели
Проектирование модели требует работы только с одной моделью. Никаних дополнительных, избыточных или усеченных модулей. Все строится вокруг полной модели

## Моделировщики практики
Высококвалифицированные конструируют и моделируюит, остальные реализуют. 
НО DDD требует проектирования от всех. 
* если одни проектируют, а другие пишут код, то теряется владение знанием, получается испорченный телефон. Программисты не чувствуют ответственности за модели и не понимают ее необходимости. Не будут понимать, что изменение кода ведет к изменению модели, тогда их рефакторинг будет вредить.
* проектировщик будет терять связь с миром технологий, пониание требований и собенности реализации. В обсуждении рождается истина. Даже если выделены проектироващики, они должны тесно взаимодействавать и обсуждать концепции с разработчиками

# Изоляция предметной области
## Многоуровневая архитектура
Необходимо ограничить объекты предметной области от общих функций системы и избежать путаницы между понятиями предметной области и остальных функций системы.

Уровни: 
* **Интерфейс пользователя**вывод информации пользователю, интерпретирование его команд. Внешним субъектом может быть не только человек, но и информационная система. 
* **Операционный** - распрделение работы между совокупностями на более низкие уровни. В нем нет отражения состояния, объектов, предметов прикладной модели, но может быть состояние, для информирования ользователя о степени выполнения задачи
* **Предметной области** прелставляет понятие прикладной предметной области, рабочие состояния, деловые регламенты. Здесь используется текущее состояние прикладной модели, этот уровень главная алгоритмическая часть
* **Инфраструктурный** - техническая поддержка верхних уровней, берет на себя поддержку схему взаимосвязей между всеми уровнями. 
**Когда код размазал по базе фронту его сложнее анализировать, изменять и искать. Получается каждое изменение влечет непредсказуемое поведение в лругих слоях.**

Основной принцип многоуровневой архитектуры - каждый уровень зависит от работы элеиентов этого кровня и от более низких уровней. **Ценность многоуровневости** - это специализация каждого уровня на конкретном аспекте программы. Уровней может быть больше, но все они должны следовать главному правилу.

Разные уровни можно разместить на разных серверах.
**Необходимость операционного уровня: при измении испочника запроса - точка всегда юудет единой, помогает поддерживать архитектуру в целостном виде**

### Связь между уровнями
* уровни должны быть связаны нежестко и сверху-вниз
* верхние уровни манипулируют нижними через вызов публичных методов, хранения ссылок на них
* если нужна связь снизу вверх, то нужно реализовывать сообщениями или паттерном наблюдатель
* инфраструктурный уровень не инициирует операций на уровне предметной области
* техничесике возможности(инфраструктурный уровень) предоставляются в виде служб, например, посласть письмо: оперативный уровень запрашивает передачу сообщения - это дополнительная помощь для операционного уровня, но при этом он не знает технической сложности службы
* некоторые технические компоненты проектируются так, чтобы напрямую поддерживать функционирование других уровней(абстрактный базовый класс)

### Архитектурные среды
Речь идет об инфраструктурном уровне, где не все решается использованием интерфейсов. Среды, которые могут влиять на предметный уровень. Например решение реализовать модель в виде объектов конкретной ORM. Важно не выбирать жестко готовое решение раз и навсегда, а делать выбор в пользу полезности для работы над предметной моделью

## Уровень предметной области- вместилище модели
**Для DDD ключевой областью(слоем) является предметной слой, уровень предметной области**
Модель предметной области(**domain model**) - это набор понятий. Уровень предметной области (layer) - выражение данной модели и всех элементов программной архитектуры, имеющие к ней отношение. Этот уровень образуется путем проектирования и реализации всей совокупности понятий и связей в предметной области. Такого рода проектирование, конструкции уровня предметной области отражают концепции модели.
**Изрляция предметной области - это основа DDD**

## Антипаттерн интеллектуального интерфейса пользователя
Реализация логики внутри интерфейса пользователя. Хранение - общая реляционная БД. Плюсы и минусы очевидны.

# Модель, выраженная в программе
Связь между моделью и реализацией необходимо проектировать на уровне деталей.

**Основное различие сущности  и объекта-значения в том, что сущность имеет протяженность и обособленность, а объект-значение  выражает состояние предметной области.**

Служба(Services)  - это что-то срабатывающее на запрос клиента. На уровне предметной области они появляются при моделировании деятельности, которая соответствует опрерациям программы, но не ассоциируется ни с каким ее состоянием.

## Ассоциации
При необходимости соблюсти однозначное соответствие между моделью и программной реализацией сложнее всего при создании ассоциаций между объектами
Для всякой прослеживаемой в модели ассоциации должен существовать механизм в программе, обладающий теми же свойствами (связь между покупателем и продавцом в магазине, связь в коде между объектами). **Реализация может быть разной, но должна быть в архитекутре предусмотрена**

### Правила упрощения ассациаций
1. свести отношения к однонаправленным (снижает связность и упрощает структуризацию)
    * отпределить, какое соотношение важнее (отель в какой стране? - какие отели в стране?)
    * можно последовательно пытаться ограничить ассоциации и , как следствие, упростить и сделать значимыми оставшиеся ассоциации
2. добавить квалификаторы
    * путин - президент? президент какой страны путин? - класс человек независим от менее функдаментального президент.
        выбор главного направления из "многие ко многим" сужает его к "один к одному"
3. устранить несущественные ассоциации

## Сущности
Многие объекты не сводятся к набору атрибутов, а характеризуются непрерывностью и индивидуальностью существования. Индентичность - это то, что определяет именно его. (Как определить, что сущность(человек) именно тот, кем является?)
Десять лет назад для понимания сущности главное не атрибуты, а абстрактное непрерывное существование в течение всего жизненного цикла, даже с переходом в разные формы

Для некоторых объектов опредление через атрибуты не главное. Они непрерывно существуют во времени, переходят в состояния, но не утрачивают своего значения (понимания-смысла). Может существовать две сущности с одинаковыми атрибутами, но разными по факту.
* эти обекты должны идентифицироваться таким образом, чтобы их можно было однозначно опредить.
* определение классов обязанностей, атрибутов, ассоциаций для них следует строить вокруг смыслового значения, а не атрибутов (человек, город, авто, билет и т.д)

**Индивидуальное существование  - это тонкий смысловой атрибут, который невсегда возможно превратить в стандартное средство единого языка**

**Иногда имеет смысл посмотреть на транзакцию, как на сущность**

### Правила
* если объект определяется индивидуальным существованием, а не набором атрибутов, это свойство следует следует считать главным в определении объекта в модели
* класс должен строиться вокруг непрерывности и уникальности цикла объекта
* найти способ разлисать объект вне зависимости от формы и существования
* обратить внимание к техническими требованиям, необходимым для сопоставления объектов по атрибутам
* создать операцию, которая способна генерировать новый результат для объекта(например, GUID). Она(операция) должна соответствовать правилам различения объектов в модели.
* должно даваться точно определение, что такое разные объекты
* если у объекта нет уникального признака (место без номера), то, возможно, это не сущность

## Моделировани сущностей
При моделировании объекта нужно думать об атрибутах и важно думать о его поведении, рабочих функциях.
Основная функция сущности - поддерживать непрерывность существования, чтобы поведение было понятным и предсказуемым. как следствие выведем правила:
1. ограничиваем определение сущности неотъемлемыми характеристиками (то что используется для поиска и сравнения)
2. задаем только те функции, которые существенны для создания понятия об объекте 
3. задать атрибуты, которые требуют функции (2)
4. остальные атрибуты и функции и объекты выносим в другие функции или объекты-знаечния

**Функции координируют операции объектов, которые им принадлежат. Номер телефона не может быть уникальным, но можно вынести в деловые контакты**

## Проектирование операций идектификации
* может быть некоторый уникальный признак
* если нет - присваиваем уникальный код сами (в рамка плана уникальный)
* могут быть разные способы генерации (важно помнить о том, что система может быть рапределеннной)
* идентификатор может быть внутренним (не нужно показыать пользователям). Могут быть необходимы для пользователя (коды подтверждения для токенов в письмах)
* если нужен общий для разных организаци (например использование федерального или общепринятого справочника)
* иногда можно ожидать определения индивидуальных идентификаторов от пользователя (логин - почта)

##  ОБъекты-значения
ОБъекты без индивидуального существования описывают характристики того или иного объекта

**Пример** Рисунок - сущность, чем его рисовали и вкакой технике - характеристики

**Один и тот же объект в разных ситуациях может быть сущностью или объектом-значением.** Адреса для человека - это объект-значение, а для ФИАС  - сущность

Объект-значение  - это объек, представляющий описанный аспект предметной области и не имеет индивильного существования, собственной идентичности
* объект-значение может представлять совокупность других объектов
* может ссылаться на сущности (нужный маршрут состоит из сущностей населенный пункт, дорога)
* может персылаться в сообщениях между объектами
* может носит временный характер
* может использоваться как атрибут сущности (человек - сущность, объект-знаечние - имя)
**если элемент модели определяется своими атрибутами(полностью), то это объект-значение**
* сделайте, чтобы объект-знаечние отражал смысл заложенных в него атрибутов атрибутов, придайте соответствующую функциональность
* нужно считать его неизменяемым
* не должен содержать индивидуальности
* должен быть целостным (не три значения улица, город, страна), а одно - адрес

### Проектирование объектов-знаечний
Есть одно имя у двух человек. Один имя поменял. Менять ззначение объекта нельзя, так как изменится имя другого человека 
Можно сделать вывод:
* объект-знаечния не изменяем, а заменяем
* может быть многократно используем для разных сущностей (с сущностью такое не пройдет)

#### Случаи изменяемости
* частое изменение
* затраты создание-уничтожения
* опасность замены при группировании (совместное использование)
  если объект-знаечниие изменяем, то он не должен использоваться совместно

**Чтобы иметь возможность технически оптимизировать быстродействие, необходимо избегать связей и ограничений в модели**

**!! В реляционной БД можно провести донормализацию с целью засунуть объект-знаечние из отдельной таблицы в таблицу-сущности. Для экономии времени**

**В распределенной  системе, если хранить ссылку на объект-значение на другом сервере, может замедлиться передача сообщений, поэтому лучше передавать на другой сервер копию объета**

Нужно избегать двунаправленной ассациации между объектами-значениями

## Службы
* служба не инкапсулирует состояние 
* большинство служб находятся на инфраструктурном уровне и имеют технический характер
* службы на уровне предметной области взаимодействуют с инфраструктурными (при изменении баланса  - отсылаем письмо)
* отличить службы операционного уровня и предметной области: операционный уровень отдаем команду на перевод денег, а реализация перевода денег - фундаментальная операция предметной области **Грань тонка**
* в службах предметной области реализуются деловые регламенты

### Распределение служб по уровням
#### Операционный
* принимает входные данные
* посылает сообщение в службу модели для выполнения
* ожидает подтверждения
* принимает решение об отправке извещения

#### Предметной области
* взаимодействует с нужными объектами
* посылает подтверждение результата

#### Инфраструктурный
* рассылка
* экспорт

## Модули
### Цели
* уменьшить смысловую сложность
* удобно прослеживать архитектурные решения через связи модулей

### Характеристики
* низкая внешняя зависимость и сильная внутренняя связанность
* помогают строить все так, чтобы не нарушать границ модуля
* позволяют развивать модуль внутри модуля
* должны входить в единый язык
* должны рассказывать историю системы

### Ловушки инфраструктуры
* нельзя разделить концептуальный объект на части (Razor, WinForm)
* обязательный пакеты накладывают ограничения

### Парадигмы моделирования
**Объектная** - простота,  популярность, комьюнити  необъекты в объектном мире (логическая). Зависим от математических соглашений
**Логическая** - необъекты в объектном мире.
**Функциональная**

#### Смешение парадигм. Советы
* не противостоять парадигме реализации (искать то, что будет соответствовать)
* полагаться на единый язык
* не зацикливаться на UML
* подвергать все сомнению
* исчерпать все в рамках текущей пардигме

# Цикл существования объектов модели
Каждый объект имеет цикл существования (создание - модификация - архив - удаление).
Существуют временные и долгоиграющие объекты (со сложными связями, изменением состояния, подчиняется инвариантоности)

## Трудности управления объектами
* поддрежание целостности на этапе существования
* предотвращение излишней сложности в управлении циклом существования

**Шаблоны для разрешения трудностей**
* агрегаты - помогают в поддержании целостности объектов
* фабрики - создание - восстановление сложных объектов
* хранилища - поиск и извлечение

## Агрегаты
**Проблема**
При внесении изменений в объекты модели со сложной системой ассоциаций можно получить несогласованные данные. Необходимо соблюдать инварианты к тесно связанным группам объектов, а не к отдельным объектам. Если переборщить со схемами блокирования, то будут проблемы с параллельной работой.

**Помогают решению**
* знание предметной области
* знание частоты смены экземпляров объектов
* построение модели с большой свободой в местах интенсивной передачи конкурирующих данных
* построить моделт, принуждающую к соблюдению инварианта

**Корень проблемы**
* нечеткие границы

**Правила для танзакций, вносящих изменения и в первичные, и в связыные объекты**
* абстракция для инкапсулрующих ссылок в пределах модели (Агрегат)

**Агрегат состоит:**
**Корень агрегата** (корневой объект) - это конкретный объект-сущность
 * сущности снаружи агрегата ссылаются на него
 * объекты внутри границы могут ссылаться друг на друга
 * сущности внутри корневого объекта могут быть локально индивидуальны, но только в пределах границ. Снаружи доступа нет.
      Пример: Шины у машины. Внешний номер машины - известен за пределами границ. Уникальность конкреной шинынеобходима только в рамках конкретной машины.

**Из взаимосвязей между объектами агрегата можно составить инварианты - Правила совместности, которые должны соблюдаться при любых изменениях данных. это правило должно контролировать при завершении любой транзакции**

### Правила создания агрегата
* корневой объект имеет глобальную идентичность и несет ответственность за проверку инвариантов
* некорневые объекты-сущности имеют локальную идентичность
* ничто, кроме корня агрегаты не открываются за пределы границ для сохранения
* корневой объект может передавать ссылки на внутренние объекты-сущности другим объектам, НО во временное пользование без хранения или фиксирования (на время существования операции)
* корневой объект может передавать копию объекта-значения. Его дальнейшая судьба не важна.
* только корневой агрегат можно получать по запросами к источнику данных. все остальное разрешается извлекать по цепочке связей
* объекты внутри агрегаты могут хранить ссылки на корневые объекты других агрегатов
* удаление удаляет все в границах агрегата
* при изменении любого объекта внутри границ агрегата удовлетворятся все инварианты агрегата
**Пример инварианта - сумма не больше предела**

## Фабрики
Фабрики обеспечивают инкапсуляуцию внутри агрегата: Когда создание объекта перекладывается на клиента это:
* не соответствует принципу SRP
* утечка обязанности из предметной области
* брешь инкапсуляции

**Объект необходимо дистилировать, пока в нем не останется ничего, что имеет отношение к его сути и его роли в транзакциях**

Создание сложных объектов - это обязанность предметной области, но не объектов, выражающих модель
**Обязанность фабрики - создавать объекты**
* интерфес объекта должен инкапсулировать реализацию
* фабрика инкапсулирует знания для создания сложного объекта или агрегата

**Шаги создания сложного объекта и агрегата**
* передать обязанности создания объекта фабрике (задача по созданию передана отдельному классу)
* создать интерфейс инкапсулирующий сложные операции и не требует от лиента ссылаться на конкретные классы
* создайте агрегат как единое целое с соблюдением инварианта

**Требования к фабрикам**
* один метод создания - должен гарантировать соблюдение инваринта
* создавать объект целиком в корректном состоянии (для сущности создается целый агрегат с соблюдением всех инварианта, можно позже добавить второстепенные элементы; для собъекта-значения - это значит, что все атрибуты иниуиализируются всеми окончательными корректными значениями)
* если есть возможность ввода некорректного значения долна инициироваться исключительная ситуация
* абстрагировать фабрику нужно к желаемому типу, а не к конкретному классу

### Выбор фабрик и их местонахождения
* если добавляются элементы внутрь уже существующего агрегата - в корневом объекте агрегата создать фабрику
* если объект участвует в порождении дургого объекта, но не владеет им после создания - в него можно поместить метод-фабрику для создания не основого объекта
* фабрику помещаем только в объект, где сильная естественная связь с порождаемым объектом
* если нужно скрыть реализацию или сложность процесса создания, но нет естественного объекта лдля инкапсуляции - нужна специальная фабрика или служба. Такая автономная фабрика порождает агрегат, вызывая ссылку на корневой объект (и инваринат соблюдает)
* если нужна фабрика для внутреннего объекта по отношению к агрегату (например корень не подходит) - фабрика, НО! на порождаемый объект возможны только врменные ссылки извне агрегата.

**Когда достаточно конструктора**
* класс является типом, не входит в иерархию, не используется полиморфиески
* клиенту нужно знать реализацию объекта (например для выбора стратегии)
* все атрибуты объекта доступны клиенту (в конструкторе не создаются никакие новые объекты)\
* простое создание объекта
* общедоступный конструктор должен следовать тем же правила, что и фабрика
**Конструктор в конструкторе  - это плохо. Конструкторы должны быть простыми**

### Проектирование интерфейса
* каждая операция единая и неделимая (все данные для создания передаются в одну коммуникацию) Важно решить, что делать с исключениями (нужен единый стандарт)
* фабрика должна быть связана со своими аргументами . Если неосотрожно выбрать набор входных параметров, то может получиться паутина взаимосвязей(если сразу вставляются значения - низкая зависимость, если при конструировании берется только часть от объекта, то зависимость становится сильнее)
* используйте абстрактный тип аргумента, а не конкретные классы. (фабрика привязана к конкретному типу продуцируемых объектов, нет нужды привязывать в конкретным параметрам)

**Самые безопасные параметры - с нижних уровней архитектуры или близкородственный к генерируемому так что между ними не создается новая взаимозависимость (товарный заказ - позиция товарного заказа - товар)**

### Где релизовывать логику инваринтов
* проверка выполнения инвариантов - фабрика. Идеальный случай: фабрика делегирует проверку объекту. 
* иногда можно вынести в саму фабрику, не загромождая создаваемые объекты, например, для правил распространяемых на много объектов
* можно вынести в саму фабрику если логика не будет меняться в течение существования. например все характеристики у объекта-сущности - неизменяемые объекты-знаечния, тогда незачем тащить логику проверки инварианта в объект.

### Отличие фабрик-сущностей от фабрик-объектов-значений
* оБъекты-значений создают в окончательном виде и фабрика должна задавать полное описание продукта
* фабрики-сущности склонные работать с самыми существенными атрибутами для создания корректного агрегата и соблюдения инварианта, а детали позже. Плюсы: контроль над процессом создания индентификатора.
* если необходим извне получать уникальный идентификатор, то его контроль удобно возложить на фабрику. Даже в случае автогенерации ключа(база, внешний механизм) - фабрика знает, куда его поместить и откуда запросить

### Восстановление храниных объектов
Восставновление объекта в памяти - это сбор отдельных частей заново в единое целое. (Середина жизни цикла объекта)
* восстанавливает объект-сущность, не присваивая идентификационный номер (иначе это было бы не предыдущее состояние, а новый объект, поэтому идентификатор должен сохраняться во входных параметрах фабрики)
* восстанавливающая объект по-другому обрабатывает нарушение инварианта
    * при создании фабрика обычно просто сбрасывает объект
    * для восстановления должна быть схема разрешения противоречий

## Хранилища
Для проектирования объектов разумно сочетать поиск и отслеживание связей (поиск по идентификатору или подтянуть по связи)
* создание нового экземпляра на основании сохраненных данных - это по сути восставноение объекта
* объеты-значения подтягиваются через связи (не стоит тянуть напрямую из источника)
* глобальный поиск по атрибутам лучше реализовывать для сущностей
    **Если нуджно глобально найти объект-значения, возможно, это сущность**
* открытое использование технической инфраструктуры механизма доступа к источнику данных захламляет модель
**Обращение к любому объекта, внутреннему по отношению в агрегату, может выполянться только через корень агрегата**

**Хранилище** - это архитектура инкапсулирвоания технических решений. это объекты определенного типа в виде множества. Вроде коллекций: добавление, удаление, помещение в БД, методы ответа из БД на запросы клиентов

Что делать:
* для каждого типа объектов с глобальным поиском создаем посредника, который создаст иллюзию того, что все объекты типа объединены в коллекцию и находятся в оперативной памяти
* налаживаем доступ через хорого известный(общий) глобальный интерфейс
* реализуйте методы добавления, удаления объектов, скрывающие работы с БД
* реализуйте запросы
* реализуйте хранилища только для тех, к корневым агрегатам которых нужен доступ
* **клиент опирается на модель, операции обработки данных на хранилище**

### Запросы к хранилищам
Для создания гибких запросов можно строить запросы на основе **спецификаций**. **Спецификация** - это способ описания того, что нужно без углубления в то, как деалется. Создается объект, делающий этот выбор

### Клиентам безразлична реализация хранилищ, а разработчикам нет
Не будь соплей, умей работать с источникам данных, знай особенности внутренней обработки запросов и команд

### Реализация хранилищ
* абстрактный тип (generic)
* извлекайте преимущество из независимости клиента (отдельные релаизации кеширование, подмена источника, моки)
* оставить контроль транзакций клиенту (пусть клиент фиксирует транзакцию)
* хранилище - это инфраструктурный урвоень

### Связь с фабриками
Фабрика - это начало существования объекта, Хранилище - середина (находит и извлекает старые объекты)

### Проектирование объектов для БД
* если база основное храниелище  - нельзя сильно разводить модель БД и объектную (обсуждаемый процесс)
* процессы вне объектной системы не должны иметь доступ к хранилищу объектов

# Работа с языком. Расширенный пример
* нужно стремиться к формулировке утверждений: Должна, участвует, цель, этап
* стремиться к незагромождению моделей (не включать слишком много)
* усовершенствование моделей, проектирование и реализацию идут итерационно
* нужно стремиться обрисовать процесс

## Изоляция предметной области (Возможный первоначальный план)
* выделение многоуровневой архитектуры
* выделение уровня предметной области
* определение прикладных функций для операционного уровня
    * служба регистрации событий (классы координаторы без функций)

## Отделение сущностей от значений
Рассмотреть все объекты и выяснить, кто индивидуальная единица, а кто набор значений:
**Сущность**
* есть ли идентичность (признак)
* должна пониматься разница объектов (как их сравнивать и отличать)
* каждый ли объект значим (его изменение, существование)

**Объект-значения**
* если есть гипотетическая идентичность, то достаточно ли будет ее внутри границ агрегата
* зависит ли объект от более масштабного (значимого), однозначная ли это зависимость
* есть ли история и непрерывность существования

## Проектирование ассоциаций
Определеить приоритетную ассциацию(от чего идем)

## Границы агрегатов
* каждая из выявленых сущностей должна стать корнем агрегата в своем агрегате
* сформировать вокруг корня все, чего не сущетсвует без корня (например, все, что он порождает или зависит отнего, или является его описанием)

## Выбор хранилищ
* Определить, кто из агрегатов имеет право на хранилище (для тех, кого надо выбрать откуда-то, создать, найти)
* Нарисовать границы агрегатов в модели (все, что снаружи  - новый агрегат)
* пройти по сценарим программы, чтобы убедиться в эффективности решени.

## Создание объектов
* создать фабрику для корня агрегата (Абстрактную или метод)
    * в конструктор передать все атрибуты, определяющие уникальность 
    * возможно включить генерацию уникального идентификатора
    * вернуть из фабрики корень агрегата с "пустыми" объектами-значениями
    * можно включить внутрь создание зависимой сущности объекта 

### Перерыв на рефакторинг
* можно некоторые объекты или ссылки заменить на запрос к источники (например)

### Модули
* Выделить модули на основании связных понятий и целей проекта, а не технических особенностях реализации

### Применение новых требований от заказчика
* Выделить предохранительный уровень для работы со смежными системами (класс для обозрения необходимых возможностях в терминах модели)
    * Определить службу для каждый функции необходимой от внешней системы (реализовать их все через контроллер или хэндлер, только обращение к службе)

### Усовершенствование модели
* переработка понятий со специалистами. Важно не нарушать инкапсуляции и границ

### Определение быстродействия
* выявить возможные утечки и "дыры"
* определить, где есть место для кеша

# Углубляющий рефакторинг
Удобство внесения измений в процессе получения знаний - задача гибкой архитектуры. Простор для эксперимента.
**Процесс познания:** важноуметь подходить творчески, но и иногда следовать существующим шаблонам

# Качественный скачок
Распределение выгоды от рефакторинга имеет нелинейный характер. Наиболее важные качественные улучшения происходят скачкообразно и волна распространяется по проекту. Накопленные знания перерабытываются в компактную форму модели. **Скачок - нестрандартный прием**

## История успеха (Описание задачи.)
Обслуживание работы инвестиционного банка

## Модель неплоха, но:
* имеется база кода, которая была реконструирована на основе модели
* сформирована модель
* появляются проблемы с добавлением нвоой функциональности, расчетами, округлениями

## Качественный скачок
* выясняется существование неправильно понятой связи (Додуманной, не выявленной у специалистов предметной области)

## Углубленная модель
* выделяктся ранее скрытое понятие
* выясняется, что введенное понятие(вместо необходимого) было непонятно специалистам предметной области
* перестраивается модель
* удалена лишняя связь

## Трезвое решение
* предполагается отставание от графика, а модель затрагивает многое реализованное
* руководитель задает вопрос "Будет ли движение вперед без этого решения"

## Воздаяние (плюсы от рефакторинга)
* прекратили неожиданные изменения в требованиях программы
* ввелось новое понятие в единый язык: даже специалистов предметной области

## Потенциал
* самые важные достижения работают такими скачками

## Концентрация на основах
* нельзя насильственное вызвать качественный скачок - это парализует работу
* чаще всего понимание возникает из мелких изменений
* прорабатывайте единый язык и сосредоточиться на переработке знаний
* нащупывайте важнейшие понятия предметной области
* выражайте понятия в явном виде
* делайте архитектуру гибкой
* выполните дистиляцию моделей
* не чурайтесь мелких изменений
* не теряйте бдительности, но и не стопорите работу, заглядывая далеко вперед

## Каскад озарений
* углубленная модель может открыть перспективы для архитектуры (например могут быть найдены неуклюжие решения)
* с этими элементами работа ведется по инструкции в этой главе

# Перервод неявных понятий в явные
Этапы создания углубленной модели
* выделить ключевые понятия предметной области, пригодной для моделирования
* последовательные приближаения и рефакторинг

## Извлечение понятий
* ПРиглядываться к языку и исключить неуклюжие понятия

## Внимание к языку
* названия для некоторой сосокупности данных можно почерпнуть из отчетов
* помощь пользователей уточняющих понятия
* нужно внимательно слушать специалистов, прислушиваться к терминам
* нужно выявлять скрытые понятия. некоторые могут скрываться за глаголами
* новое понятие - это понятие-ориентир для переработки знания

## Выявление узких мест
* выявление "неудобных" мест (например, там постоянно появляются ошибки)
* выявить пропущенные понятия
* признаком пропуска понятия или неуклюжести может быть сложность вычислений
    * получили сложность вычислений - > необходимо уточнить, что специалист предметной области концентрируется на том же понятии, что и вы

## Размышления над противоречиями
Различные специалисты имеют свои взгляды на предмет, основанные на личном опыте. Если в словах специалиста есть противоречие, то есть источник(ключ) к угулбленной модели. ДИАЛЕКТИКА!

## Чтение книг
Чтение специализированных книг, как способ погружения в предметную область, как способ новых понятий, как поиск знаний

## Моделирование неочевидных понятий
### Явные условия-ограничения
Условия-ограничения образуют важную категорию понятий модели. Они существуют в неявном виде и их перевод в явный вид улучшают концептуальную архитектуру.

Ограничения вписываются в объект и их можно вывести в собственный метод
Плюсы:
* имя для ограничения более понятно, чем просто условие
* возможность расширения ограничения без нагромождения
* возможность компоновки с более сложными условиями
* принцип единичной ответственности
Минусы:
* для проверки ограничения используются данные, которые без него излишни для определения объекта
* в нескольких объектах есть связные правила и они требуют наследования или дублирования
* когда ограничения затмивают основные обязанности объекта

### Процессы как объекты предметной области
Процедура - это не главный аспект.
Главный - это объект, процедуры инкапсулируются объектами
Один из способов реализации процесса - это служба, которая может инкапсулировать сложные алгоритмы.

**Признаки того, что процесс нужно выделять в объект, а не инкапсулировать**
* говорят ли об этом специалисты предметной области или это внутренняя реализация. Если говорят специалисты - нужно присмотреться

Условия-ограничения и процессы - это путь к гибкой архитектуре

## Спецификация
Существуют правила, которые регламентируются бизнесом(сложные) и которые должны реализовываться на уровне предметной области, а не в объекте

**Реализация правил прикладной модели(деловые регламенты) часто не вписываются в рамки "низких" функций сущностей и объектов-значений, а обилие и разнообразие их может исказить смысл объекта предметной области. Вынесение этих правил из уровня предметной области  - хуже, так как тогда код уровня не выражает модель, и, как следствие необходимо выделить условие в отдельный объект**

Этапы выделения в отдельный объект: 
* представляют тест на истинность. Объекты, возвращающие булево значение
* выделяем его в объект-значения
* объект оценивает другие объекта, проверяет истинность применимого агрегата
    сущность - тест - сущность

* **Спецификация** задает ограничение на сосотояние другого объекта, которое может возникнуть, а может и не возникнуть.
* Спецификация может проверять любой объект на соответствие некоторым критериям
* **Спецификация - это предикат**, которые определяет, удовлетворяет объект критериям или нет. Как следствие, нужно создать набор явно определенных предикатов подобных для решения задач

Преимущество:
* правло на уровне предметной области
* фабрика может сконфигурировать спецификацию, используяинформацию из других источников (БД, регламентные данные)

### Применение спецификаций
* проверка пригодности (соответствие правилу)
* отбор по запросу (выбор набора на основе предыдущей проверки)
* создание по некоторому заказу (например создание при удовлетворении некоторых правил. генерация, к примеру)
**Релизация**
* можно реализовать общий интерфейс для всех спецификаций и передавать в конструктор правила, тоже реализующие определенный интерфейс
* можно использование спецификации реализовать в хранилище

# Гибкая архитектура
Если элементы архитектуры монолитны и отдельные части нельзя перекомбинировать в новое целое, тогда дублирование становится неизбежным. Каждое такое место создает потолок сложности алгоритмов. В этом случае для рефакторинга нет места.

**Архитектура, приглашающая к изменениям - гибкая архитектура**
* **гибкая архитектура** - это дополнение к углубленному моделированию: если нашли новое понятие, то необходимо как можно проще его внедрить.  Удобно для клиентов, которые не будут меняться, если все построено на интерфейсах (итеративно)
* гибкая архитектура выражает углубленную модель в ее основе и раскрывает ее потенциал

**Вспомогательные шаблоны**
* единый язык
* информативные интерфейсы
    интерфейс и его методы должны предоставлять полноту картины для клиента. не должно быть необходимости проваливаться в методы и смотреть реализацию. Имя должно описывать задачу и результат, но не способ
* функции без побочных эффектов
* контрольные утверждения
* изолированные классы
* концептуальные контуры
* замкнутость операций

## Функции без побочных эффектов
все операции можно разделить на команды и запросы: 
* **Команда** вносит изменения в систему. 
* **Запросы** оставляют систему без изменений.

**Побочный эффект** - последствие действия. Это изменение в системе, которое влияет на будущие операции.
Взаимный эффект правил комбинаций и вычислений непредсказуем. В этом случае программусту нужно знать, что будет после использоавния операции. В этому случае теряеттся смысл абстрагирования

Операции, возвращающие результат, не создавая побочных эффектов, назваются **функциями**. Можно много раз и ничего не изменится

### Рекомендации
* разграничить функции и команды
* оформить, как разные операции
* методы изменения прощеи не возвращают результат
* все запросы и вычисления выполнять в методах без побочных эффектов
* все операции объектов-значений должны быть без побочных эффектов
* операции, где сложный алгоритм смешивается с изменениями состояния факторизуются в отдельные операции
* сложные операции могут быть вынесены в отдельный объект-знаечние
* если операция дает что-то новое в результате, то это объект-знаечние

## Утверждения
* Утверждения используются для комманд и позволяют что-то сделать
* Разработчик должен понимать последствия произведенного утверждения. Часто эту задачу решают информативные интерфейсы.

**Иварианты классов - это утверждения о состоянии объекта в конце каждой операции (пост-условие)**

### Рекомендации
* инварианты позволяют охарактиризовать смысл класса
* нужно формулировать пост условия операций
* нужно формулировать инварианты для классов и агрегатов, включать их в документацию
* строить модель со связным набором понятий для формулирования утверждений
* частичто могут решить задачу модульные тесты

## Концептуальные контуры
* Монолит благоволит дублированию. Не предоставляет полной информации о возможностях. Мельчайшие изменения ведут к усложнению клиентского кода 
* Если переборщить с разбиением, то можно потерять суть, заложенную в объекте(Половина сосиски - это уже не сосиска)

**Когда модуль непросто приспособить к новым открытым понятиям необходим глубокий рефакторинг**
* внутренняя связность и низкая внешняя зависимость применимы к понятиям и коду. 
* при принятии решений не нужно сползать в только технический взгляд на вещи, нужно ответить на вопрос: "Это техническая уловка в угоду зависимостям в коде или отражение смыслового контура в предметной области: если сложение объектов имеет смысл на уровне предметной области"

**Каждый объект должен представлять собой законченное понятие (Whole value)**

### Рекомендации
* разбивайте элементы архитектуры (операции, интерфейсы, классы, агрегаты) на связные единицы, учитывая понимание границ предметной области
* наблюдайте за направлениями изменений, осями стабильности в ходе рефактринга
* ищите концептуальные контуры, по которым проходит расслоение

### Цель
* создать набор интерфейсов, которые можно сочетать между собой для составления интерфейсов

## Изолировнные классы
* Ограничение паутины взаимосвязей входит в задачи модулей и агрегатов.
* Зависимость от других классов внутри одного модуля менее вредоносна, чем внешние взаимосвязи

**В пределах одного модуля сложность взаимосвязей увеличивается и, как следствие, смысловая перегрузка и снижение сложности архитектуры, понятной разработчику. Вероятнее всего с возрастающей сложностью имеют место неявные понятия**

### Рекомендации
* можно уменьшить количество связей до нуля для важного подмножества
* каждая взаимосвязь и зависимость должны быть рассмотрены (факторизация)
* **низкая внешняя зависимость - это важнейшее свойство** и, как следствие, нужно удалять и исследовать все внешние зависимости, пытаясь сделать класс самодостаточным, как следствие, можно понимать объект отдельно от других
* выделять сложные классы вычислений в отдельные классы или объекты-значения
* устранение взаимосвязей - это не сведение всех элементов модели к самым приметитивным

**большое количество манипуляций с парой объектов помогают прояснить природу их взаимосвязи**

## Замкнутость операций
Там, где уместно, определяйте операцию с тем же типом возвращаемого объекта, что и тип аргумента. Если объект
, реализующий операцию, имеет состояние, используемое в вычислениях, то объект - это объект операции, поэтому аргмуенты и возвращаемое знаенчие должно быть того же типа, что и объект. Эта операция **замкнута** относительно множества экземпляров этого типа, как следствие, не зависит от других понятий

### Рекомендации
* чаще всего применяется в операциях объектов-значения, т.к цикл существования
* иногда применяется к объекту-сущности (например, нужно вернуть у работника, его начальника - тоже тип работник)
* операция может быть замкнута вокруг абстрактного типа, в этом случае аргументы могут относиться к разным классам
* делегирование (итераторы)

## Декларативная архитектура
Это способ написания программы, как спецификации. Управляется точечным описанием свойств: рефлексия, автоматически генерируемый код, логическое программирование
Минусы:
* невыразительность языка
* средства генерировани препятствуют итерационному циклу разработки: вставляют автоматически сгенерированный код в написанный вручную и повторное генерирование действует разрушительно

### Специализированные предметные языки
* можно разработать спеуиализированный предметный язык для задачи

### Декларативный стиль архитектуры
Часть декларативной архитектуры: информативный интерфейс, утверждения, функции без побочных эффектов. Эти элементы сочетаемы и являются частью гибкой архитектуры

### Расширение спецификаций в декларативном стиле
Сочетание спецификаций через логические операции
* нужно создать абстрактный класс для работы спецификаций любого рода
* возможно применение предохранительного оператора
* можно расширить операторами (and, or и т.д)

## Углы атаки
Выделение подобластей: 
* выделяем сложныев правила в модели
* определяем специальную математику

Пример кредитная математика:
* определяем запрос от команды
* выявить неявные понятия (может ложатся на логику, но не существуют)
* ответить на вопрос: можем лисделать зависимость (одного из объектов) объектом-значением
* сложем ли замкнуть операцию на объект-значение
* соствить утверждения относительно объектов-значения

Ход рефакторинга
1. сложные объекты инкапсулируем в специальные объекты-значения с функциями без побочных эффектов
2. операции-команды должны быть просты и характеризоваться утверждением
3. понятия модели должны бытиь независимы
4. в операциях должен быть минимум новых типов. некоторые замкнуты
5. выявлять знакомый рабочий протокол (не изобретать новый процесс)

# Применение аналитических шаблонов
**Аналитические шаблоны** - это группа понятий, представляемую часто используемую конструкцию в моделировании предметной деятельности, при этом могут относиться к одной или нескольким предметным областям
* нужно быть готовым к компромисам, но не отступать от проектирования по модели

**Архитектурый шаблон - способы взаимодействия между классами, адаптированные для решения задачи**

# Шаблоны и модель
Разница между шаблоном предметной области и архитектурным шаблоном: архитектурные шаблоны используются на уровне предметной области, но если они удовлетворяют решаемой задачи. Но рассматривать их применение нужно на двух уровнях: предметной области и технические решения

## Стратегия
Есть процессы без технической мотивации, но зато они имеют прямной смысл в соответствующей прикладной деятельности, и нужн обеспечить альтернативные процесс, то решение этой проблемы - **Стратегия**

### Рекомендации
* выделить изменчивую часть процесса в отдельный объект
* отделить правила от операцй
* реализовать правило или процесс согласно шаблону

**Применимость со стороны DDD**-возможность выражать концепцию, правило, понятие
**Минусы:** клиент должен знать о наличии разных стратегий
**Правило:** стратегия должна рельно существовать в процессе

## Композит
Компановка объектов в древовидные структуры "отч асти к целому". Композит позволяет клиентам единообразно представлять как отдельные объекты, так и их компоненты
* если в модели не отражена родственная связь связь между вложенными контейнерами, то на каждом уровне иерархии нужно дублировать код. Фактичеки клиенты взаимодействуют с разными уровнями иерархии, хотя для клинта не разницы

Перед применением необходимо определить относится ли шаблон к реальной предметной области. Удалось ли найти абстракцию, в которой все части принадлежать к одному концептуальному типу

### Правило
* определить абстрактный тип, заключающий все члены композита
* реализовать методы для возвращения агрегированной информации о содердании объектов
* листья реализуют методы в соответствии с атрибутами
* клиентам не нужно различать листья, они имеют дело с абстрактным типом
 **Плюс:** одинаковое поведение на каждом структурном уровне
**Требование к шаблону:** сообщать нечто концептуальное о предметной области

# Углубляющий рефакторинг
Многократный и многогранный процесс

## Принципы DDD
* жить в предметной области
* смотреть на вещи под разынми углами
* поддерживать диалог со специалистами

## Инициирование
Рефакторинг начинается разными методами: проблема в коде, сложные участки с постоянными проблемами, проблема предметной области, результат обучения и более глубокого понимания проблемы

## Исследовательские группы
Поиск усовершенствования:
* решит мелкое изменение
* решит поиск новой модели

### Решения для новой модели
* взять программистов, знакомых с предметной областью
* взять специалиста предметной области
* провести мозговой штурм (event storming)
* добиться понимания и осознанности у специалиста предметной области

### Неоьходимые детали
* самоорганизация (без сложных структур): несколько человек собрались и обсудили
* время (2-3 совещания)
* единый язык

## Предыдущие наработки
В качестве источника могут выступать книги, статьи, существующие понятия, аналитические шаблоны от прдшественников, применение логики, математики

## Архитектура для разработчиков
Гибкая архитектура хороша, выразительна и упрощает жизнь разработчиков

## Расчет времени
Постоянный рефакторинг - это best practics. Больше дыр - больше финансовых потерь.
**Предпосылки для рефакторинга:**
* архитектура не отражает прдставлений группы о предметной области
* важные понятия существуют в неявном виде
* есть возможность сделать какую-то чать более гибкой

**Не нужно гибкой архитектуры, демонстрирующей техническую возможность**

## Кризис, как потенциальная возможность
Криизис - это когда докопались в процессе углубленного рефакторинга до того, что руши сформулированную модель и, как следствие, изменения, котоыре исправят невыразительность существующей модели


























































