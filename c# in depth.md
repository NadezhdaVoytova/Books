https://csharpindepth.com/Articles/Specifications

https://ru.wikipedia.org/wiki/Транслятор

(http://mng.bz/3vW3

# Развитие c#
* Простой тип данных
* Строго типизированные коллекции
* Авто-свойста
* Именованные аргументы

### Сортировка и фильтрация
1.0 
  * Реализация IComparable, реализация передается в метод Sort. 
  * Слабо типизированный компаратор(Compare(object o, object o2)). 
  * Невозможно использовать делегат сортировки. 
	
2.0 
  * Делагат Sort(*) *-delegate IComparable
  * Сравнения с помощью делегатов
  * Анонимные методы
3.0 
  * Убрано явное delegate, заменено на лямбду!
	* Расширяющие методы как OrderBy. Работает путем извлечения элементов в определенном порядке, а не на "месте". Возможность оставить список несортированным

### Запрашивание коллекций
1.0
  * Тесная связь между условием и действием.Оба жестко закодированы
  * Цикл по коллекции тесно связан с условиями внутри и тем, что надо выполнить. Невозможно определить содержимое коллекции без прохода по элемента. 
2.0
  * Отделение условия от вызываемого действия через делагаты(применяем условие до цикла)
  * Анонимные методы для написания делегатов
3.0
  * Лямбда-выражения. Улучшают читаемость кода и рпзделяют ответственность

### Обработка отсутствия данных
1.0 
  * Обертка для value-type ссылочным типом, введение флага заполнения, установка мнимого значения
2.0 
  * Nullable<T>=> Введение синтансиса вида decimal?. Проверка вида HasValue()

### Необязательные параметры и стандартные значения
1.0
  * Вариации вида обхода отсутствия значения
  
2.0/3.0
  * Nullable || ?
  
4.0
  * Необязательные параметры с стандартными значениямм

## С# 3.0 
* LINQ(LANGUAGE INTEGRATED QUERY) 
    Гибкость в работе с различными источниками данных(xml, DB, colection)

## C# 4.0

* dynamic(привязка типов во время выполнения, а не компиляции)
* COM и именованные индексаторы
* Динамическая типизация
* Удобство работы с пакетами Office

## C# 5.0
* Асинхронный код(async-await)

## Рaзделение .NET
* Язык C# 

	* Определен своей спецификацией, которая описывает формат исходного кода, включая
			синтаксис и поведение
			IDisposable, 
			поддержка типов значений и ссылочных типов
			сборка мусора
	Не затрагивается платформа, на которой будут выполняться результаты компиляции

	* Детали компиляции
  
	Компилятор C# может генерировать вывод в форме, отличной от промежуточного языка (Intermediate Language — IL), которая является общепринятой. Исполняющая среда будет интерпретировать вывод из компилятора C# или преобразовывать его полностью в машинный код за один
	шаг, не выполняя JIT-компиляцию. 
	
* Общеязыковая исполняющая среда(CLR). 

	Аспект платформы .NET, связанный с исполняющей средой, реализован в виде кода, отвечающего, за то что программы представленные на IL, выполняются в соответствие со спецификацией общеязыковой инфраструктуры CLI(стандарт)
	(Common Language Infrastructure — CLI). 
	Среда CLR является реализацией спецификации CLI, спецификации общеязыковой инфраструктуры компании Microsoft.
	CLR — исполняющая среда для байт-кода CIL (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования
* Библиотеки инфраструктуры

	Библиотеки инфраструктуры в .NET в значительной степени построены на самом языке IL с участием машинного кода только там, где это необходимо
* Спецификации языка 

	Существуют две важных формы спецификации — международный стандарт от ЕСМА и спецификация от Microsoft. На момент написания книги спецификация ЕСМА (ЕСМА-334 и ISO/IEC23270)

## Делегаты

  * **Делегат** - это упакованное поведение. 
  * **Тип делегата** - это интерфейс с еднственным методом
  * **Экземпляр делегата** - объект класса
  Делагат описывает последовательность действий для выполнения в нужное время

### Условия работы делегата

  1. Тип делегата объявлен 
  	 ```delegate void StringProcessor(string input);```
  2. Код для выполнения внутри метода
  	 ```void PrintString(string x)```
  3. Создан экземпляр делегата
  	 ```vat proc2 = new StringProcessor(instance.PrintString);```
  	 **NB** Следует помнить о том, что экземпляр делегата будет препятствовать уничтожению своей цели сборщиком мусора, если сам экземпляр делегата не может быть уничтожен. Это может привести
  	 	к очевидным утечкам памяти, особенно когда какой-то недолговечный объект подписывается на событие, возникающее в долговечном объекте, используя самого себя в качестве цели
  4. Экземпляр вызван
  5. Тип - это наименование, параметры и возвращаемый тип 
      ```delagate int GetNumber(int a)```
	
 ### Возможности 
 * можно создавать экземпляр делегата
 * создавать и оставлять ссылки на экземпляры
 * код выполнения внутри метода должен иметь ту же сигнатуру что и объявленный тип ```int GetSumma(int b)```
 * cоздание экземпляра ```var c = new GetNumber(GetSumma).```
 * вызов экземпляра ```с.Invoke(5)```
  
### Объединение и удаление делегатов

  После того как экземпляр делегата создан, в нем уже ничего не может быть изменено. Это позволяет безопасно передавать ссылки на экземпляры делегата и объединять их с другими, не беспокоясь о согласованности, 
  безопасности в отношении потоков или внешних попытках изменения их действий.
  
  Это похоже на строки, которые также являются неизменяемыми
  ```Метод Delegate.Combine()``` подобен ```String.Concat()``` — оба они объединяют существующие экземпляры, чтобы сформировать новый экземпляр, никак не изменяя исходные объекты

  При попытке объединить делегат с null, null транслируется как экземпляр делегата с пустым стеком вызова.
  Объединение +=(за инструкцией ```Delegate.Combine()) || -= (за инструкцией Delegate.Remove())```. Код вызывается последовательно

### Групповые делегаты
Экземпляр делегата располагает списком связанных с ним действий, который называется **списком вызова**
Экземпляр всегда имутабелен. При каждом добавлении нового делегата - создается новый делегат
Если любое действие в списке вызова генерирует исключение, это предотвращает выполнение последующих действий.

**NB** Делегат позволяет достучаться к методу в памяти(MSIL)

### События

  События похожи на свойства. За добавлением и удалением события стоит какая-то логика. Событие как обертка.
  **Тип события** - это тип делегата
  На события можно только подписываться (добавлять обработчик события) или отменять подписку (удалять обработчик события)
  События добавляют слой инкапсуляции через наблюдатель.
  События - не экземпляры делегатов, это пары методов, оформленные в высокоуровневый ассемблер, чтобы связать их и дать языкам понять, что методы представляют события.
  **EventHandler** - это делегат.
  
### Добавление и удаление

Нужно принять параметр экземпляра делегата того же типа
  
Пути объявления(Дополнить из стати)
  Явные методы добавления и удаления, как свойство с ключевым словом event. public event EventHandler MyEvent
  Объявить без типа, как делегат. Автосвойства lock. 

### События vs Delegate

Делагатное поле - полный доступ к совйству. Может быть использовано += || -= разбить на части, приравлять к null
События управляются только через += || -=
События не потокобезопасны

**2.0** Появились анономные методы. 
* Создавать делегаты можно с похожей сигнатурой. 
* Обобщения ковариантность и контрвариантность делегатов

**3.0** Новый синтаксис через лямбду. 
	**Func** - группа обобщенных делегатов, которые принимают параметры и возвращают значение какого-то типа
  
## Система типов

### 1.0 
* является статической, явной и безопасной.
* “строгая типизация” фактически обозначает статическую типизацию.
* C# статически типизированный язык - каждая переменная имеет отдельный тип, который известен на этапе компиляции.
* Если используется object o = "a", то для доступа к свойства и методам string необходимо приведение
		только явная типизация

### 4.0 
* динамическая неявная типизация возможна(приведение, ковариация-контрвариация)
* **Явной типизация** тип каждой переменной должен быть явно указан в ее объявлении.
* **Неявная типизация** позволяет компилятору выводить тип переменной на основе ее использования.
* **Небезопасная система типов** => использование типа не имеющего отношения к текущему на уровне IL. Выполнение приведения между совершенно несвязанными структурами
  
**NB** **ковариантностью** возвращаемых типов object а используем вместо Person
       **контрвариантностью** возвращаемых типов Person а используем вместо object

### Две ситуации, когда может требоваться предоставление дополнительной информации коду, вызывающему метод.	
* Строго и слабо типизированные коллекции.
  Ковариантвность и проверка во время выполнения
    ```
    string[] strings = new string[5];
    object[] objects = strings;
    objects[0] = new Button(); ///ошибка object ссылается на ссылку! string   
    ```
     Ковариантность массивов достается засчет обеспечения безопасности типов во врем выполнения, а не на этапе компиляции.
     Для слаботипизированных коллекций(ArrayList) нет возможности удостовериться, что получаем тип string на этапе компиляции

* Наследование и переопределение методов или реализацию интерфейсов
    * Отсутствие ковариантности возвращаемых типов
    1.0-4.0 ковариантность возвращаемых типов и контравариантность типов параметров отсутствует
    Нельзя создать Person.Clone, не переопределив! Нужно явно реализвать интерфейс и там написать реализацию. Иначе Clone всегда будет как object.
        ```
        public Person Clone(){}
        object ICloneable.Clone()
        {
        	return Clone();
        }
        ```
## Типы значений и ссылочные типы
**массивы, делегаты, интерфейсы(могут быть реализованы типами значений)** - ссылочные типы, даже если типы элементов относятся к типам значений
**перечисления**-типы значений
	
Значением выражения ссылочного типа является **ссылка — это не объект, на который производится ссылка**. 
Значением выражения String.Empty будет не пустая строка, а ссылка на пустую строку

**Для типов значений**
* Значения переменных хранятся там, где они объявлены. 
* От типов значений нельзя наследовать
* не нужна сборка мусора, когда они не упакованы, 
* они не сопряжены с накладными расходами, связанными с идентификацией типов
* не требуют разыменования

**Факты**
* Значения локальных переменных в стеке, значения переменных экземпляра там, где экземпляр
* Статические переменные и ссылочные объекты всегда хранятся в куче
* Экземпляр ссылочного типа содержит в начале блок данных о типе объекта. Тип объекта изменить невозможно: при простом приведении проводится проверка указывает ли новая ссылка на допустимый объект

#### Мифы
* Структуры - это легковесные классы. 
    * типы значений не должны иметь методы, обладать важным поведением, а просто передавать данные
    * типы значений не всегда производительнее. Н-р для каждого присвоения его необходимо копировать

**NB** Затраты памяти на код происходят один раз, поэтому количество методов не влияет ни на что

* Ссылочные типы в куче, значения в стеке
    * в стеке только локальные переменные(переменные, объявленные внутри метода) и параметры метода.
    * тип значения там, где объявлен по умолчанию 
    
* По умолчанию в C# объекты передаются по ссылке
    * Сами объекты никогда не передаются, ни по ссылке, ни по значению. 
    * При работе со ссылочным типом выполняется либо передача переменной по ссылке, либо передача значения аргумента (ссылки) по значению
	* Если изменить внутри метода занчение ссылки, то наверх значение не уйдет, потому что ссылка была полностью заменена
  
#### Упаковка-распаковка
Значением ссылочной переменной всегда является ссылка
Значением переменной типа значения всегда является значением
```
int i = 5;
object о = i; // упаковка значения в объект является копия исходного значения
int j = (int) о;
```
**распаковка** при распаковке значение, находящееся внутри упаковки, копируется.
Распаковать в long не можем, помним, что в объекте если информация о содержащемся типе

## Новые возможности типов

**2.0** 
* Обобщения (обобщенные типы делегатов) 
* Выражения для создания экземпляров делегатов
* Анонимные методы
* Ковариантность и контравариантность делегатов
* Обобщения в коллекциях - нет затрат на упаковку-распаковку. Ранее все упаковывалось и запаковывалось

**3.0** 
* Анонимные типы, неявно типизированные локальные переменные, расширяющие методы.
* Анонимные типы вычисляет компилятор и две похожие конструкции с new{} может посчитать единым типом и позволит даже присвоение
* Расширяющие методы через static
	
**4.0** Dynamic
* BCL(Base Class Library) и DCR(Dynamic Language Runtime)
 
### Параметризованная типизация с использованием обобщений

Обообщения используются во многих операциях,  где используется object как параметр
Для компилятора меньшее количество проверок => выше производительность

Две форма обобщений: **обобщенные типы** (классы, интерфейся, делегаты, строки), **обобщенные методы**
**Параметр типа** — это заполнитель для реального типа. 
**Аргументами типа** -  желаемые реальные типы.  Аргумент типа должен быть известен на этапе компиляции

**Несвязный обобщенный тип** - форма обобщенного типа, при которой ни одному из параметров типов не были предоставлены аргументы типов. Это шаблон для сконструированного
**Сконструированный тип** - это когда аргументы типов указаны
**Открытый тип** — это такой тип, который по-прежнему содержит какой-то параметр типа (например, как один из аргументов типов или как тип элементов массива) 
**Закрытый тип** представляет собой тип, не являющийся открытым, т.е. каждый аспект типа точно известен

Для описания List<T> можно говорить для списка из T
Можно перегружать на основаниии параметра
Ообобщенные методы - это напрмер foreach, where по коллекции
	
**Типы ограничений на обобщения**
* Ссылочный тип (class)
* Тип значения
* Ограничения конструктора (new (str s)). У параметра типа должен быть объявленный конструктор
* Ограничение преобразования типа 
    ```class S<T> where T: Stream => Sample<MemoryStream>, недопустимый Sample<String>```
	  
**Ограничение объединений**
* нельзя ссылочный тип + тип значение
* ограничение конструктора, когда тип динамический
* класс должен быть перед интерфейсом

**Выведение типов для аргументов типов в обобщенных методах**
	Неявное приведение List<string> list = MakeList("a", "b"). Опускаем string - компилятор определяет сам.
	Вариант ошибки компилятора: Перадать вместо аргумента object + применить методы для string
	
**Правило для обобщений**
	Смотреть результат вывода всех аргументов. Если вывели лучше указать явно

**Выражения для стандартных значений**
	Если тип заранее не известен, то есть возможность исползовать для инициализации стандартное значение
```
class: Icomparatible<T>
{
 return value.CompareTo(default(T))
}
```
Текущее знаечние сравниванием со значением по умолчанию
```
default(string) = null
default(int) =0
default(DateTime) = Datetime.min
```		
**Прямые сравнения**
* Если тип является неограниченным(никаких ограничений к нему не применено), то можно использовать == !=, но только для сравнения с null. 
* Сравнивать два значения типа T друг с другом нельзя
* Если аргумент типа ссылочный тип, то применяется ссылочное сравнение
* Если аргумент тип значение, не допускающий null, то сравнение с null всегда false. есди допускат, то все по правилам сравнения с  null
* Если параметр типа ограничен ссылочным типом, то вид сравнения зависит от того, как ограничен параметр типа

**Перегрузки**	
* Если одно ограничение ссылочного типа, то выполняется ссылочное сравнение, если произвольный от типа, где == и !== * перегружены, то применяются перегрузки
* В типе string операция == перегружена
* В обобщениях дополнительные перегруженные методы, которые определяются через аргументы не будут вызваны, как если бы * передаваемые параметры имели тип object.
* При компиляции ничего о входчших аргументах не известно. Поэтому пергруженные методы не будут вызваны

**Equal & Compare**
* IComparer<T> и IComparable<T> - для сравнения занчений на предмет порядка (меньше, больше, равно)
* IEqualityComparer<T> и IEquatable<T> - сравнение на предмет эквивалентности по критерию + Вычисление хеш кода
* IComparer<T> и IEqualityComparer<T> реализуются типами, которые обладают способностью сравнения двух разных значений,
*  IComparable<T> или IEquatable<T>, позволяет сравнивать себя самого с другим значением.

### Статические поля и статические конструкторы
* Каждый закрытый тип имеет собственный набор статических полей. Закрытый тип - это (int, string)
* Базовое правило предусматривает наличие одного статического поля на закрытый тип.
* Статический конструктор для любого закрытого типа выполняется только один раз. 

	Правило: Один раз устанавливается значение на один закрытый тип Type<int> Type<double>
	
### Обработка обобщений JIT-компилятором
* компилятор JIT создает отдельный код для каждого закрытого типа с аргументом типа значения — int, long, Guid и т.д.
* разделяет машинный код, сгенерированный для всех закрытых типов, в которых в качестве аргумента типа применяется ссылочный тип, такой как string, Stream и StringBuilder(Компилятор JIT может это делать, поскольку все ссылки имеют один и размер)
* пространство в стеке, требуемое для ссылки, будет всегда одинаковым.
* Каждый тип по-прежнему располагает собственными статическими полями, но исполняемый код используется повторно.
	
### Обобщенная итерация
Если реализовать IEnumerable<T> необходимо реализовать методы обоих интерфейсов 
			**IEnumerator<T> GetEnumerator();**
			**IEnumerator GetEnumerator();**
		
**NB В перечислениях Dispose срабатывает после окончания цикла**

### Рефлексия

Задачи
* проверки структуры, д
* динамическое конфигурирования, 
* привязка в рантайме
		
**typeof()**
* извлекает определение обобщенного типа(несвязанный обобщенный тип) - 
    просто взять имя типа, как он был объявлен и удалить имена параметров типов, сохранив запятые typeof(X))
* извлекает отдельный сконструированный тип 
    указать аргументы типов таким же образом, как это делается при объявлениипеременной обобщенного типа. Dictionary<long,Guid>

**GetType** - динамический эквивалент операции typeof
		
**NB** Обобщения инвариантны. Отстутствие вариативности обеспечивает один тип внутри List<T> - это не может быть
```
		List<Animal> animals = new List<Cat>();
		animals[0] = new Turtle(); 
		animals.Add(new Turtle()); // ошибка выполнения хуже, чем ошибка на этапе компиляции
```
Массивы интвариантны из-за ковариантности массивов Java

### Типы допускающие null
Ссылка, отличная от null - это способ получения объекта null(специальный объект, который говорит, что ссылка отсутствует)
Ссылка **null** прдствлена в памяти нулями
	
#### Почему нельзя хранить в значениях null?**
**Пример**: есть байт 0..255 -> 256 значений, которые суммируются в байт, если хранить еще 257, то уместить невозможно(возможно с бардаком в виде одного бита в качестве флага, а стоит ли оно того). Для ссылочных типов пожертвовать одним битом для null не вопрос.
	
#### Шаблоны обойти null**
##### 1.0 
* конкретное знаечние(опасность пересечения)
* оболочка ссылочного типа(утечка памяти (todo: почему))
* булевский флаг

##### Nullable<T>
* **System.Nullable** - это статический класс, он содержит только статические методы, и создавать его экземпляры нельзя 
*  Nullable<T> 
    * Параметр типа Т имеет ограничение типа значения, использовать Nullable<Stream> нельзя 
    * Свойство HasValue указывает на то, присутствует ли реальные значения, если нет то экземпляр трактуется как null
        Если HasValue вернул true происходит неявное преобразование.
		
**NB** Тип **неизменяемый**, если экземпляр не может быть изменен после конструирования. Лучше создавать новое значение(тип-значение), чем изменять существующее

**Упаковка распаковка Nullable**
* Nullable<T> является структурой. На него распростаняются правила упаковки-распаковки
* Экземпляр Nullable<T> упаковывается либо в ссылку null, либо в упакованное значение типа Т (при наличии значения)
* Распаковать упакованное значение можно либо в нормальный тип, либо в соответствующий тип, допускающий null.
* Распаковка null в тип значение вызовет исключение
* значение null у типа значения  - это экземпляр без значения 

**Равенство Nullable<T> Equals**
    Если оба null - true
    Если занчения равны true
    Другие варианты  вернут false
			
**Синтаксический сахар**
Nullable<byte> можно использовать тип byte?
Можно явно приводить к (int?)

**Преобразования над Nullable**
    S? => T? (явное или неявное)			
    S => T?  (явное или неявное)
    S? => T  (только явное)
    
**Операции, которые затрагивают типы, допускающие null**
* унарные: + ++ - -- ! ~ true false
* бинарные: + - * / % & | ^ << >>
* эквивалентности: == !=
* отношения: < > <= >=

Когда эти операции перегружаются(поднимаются) для типа значения Т, не допускающего null, то тип Т?, допускающий null, получает те же самые операции со слегка отличающимися типами операндов и результатов.

**Ограничения применения операций**
* true false не поднимаются ?!
* поднимаются только операции с операндами, которые имеют типы значений, не допускающие null.
* для эквивалентного отношения возвращаемый тип должен быть bool

**Булева логика**
воспринмать выражениее true&y, где y - перменная с возможным знаечнием null(необпределенность)

**AS**
Это позволяет выполнять безопасное преобразование из произвольной ссылки в значение за один шаг
```int? nullable = о as int?;```
as медленне is и позволяет делать as и Long?

**Операция объединения с null**
var third = first ?? second, если second допускает second, то Nullable<>

## 2.0
### Делегаты
Ковариантность возвращаемых типов делегатов
```
	delegate Stream StreamFactory();
	static MemoryStream GenerateSampleData(){}
```
 Контравариантность для параметров делегата
 ```
	void KeyPressEventHandler(object sender, KeyPressEventArgs e)
	void LogPlainEvent(object sender, EventArgs e){}
	button.KeyPress += LogPlainEvent;
```	
**Неоднозначность при применении**
Преобразование, которое ранее соответствовало только методу базового класса, теперь может соответствовать методу производного класса из-за ковариантности или контравариантности в C# 2 метод производного класса будет выбран компилятором
NB ПРоверить перегрузку методов с ковариантностью и контрвариантностью

### Анонимные методы 
Анониманые методы указывают действие для экземпляра делегата, встроенного как часть выражения, создающего этотэкземпляр делегата
К анонимным методам контрвариантность не применяется

Действие код с одним параметром 
```
public delegate void Action<T>(T obj), где T - параметр делегаты, вернет void
Action<string> r = delegate(string t)
{
  Condole.Log(t)
}
r("string Value");
```
Пример анонимного метода 
```
var list = new List<string>{"1", "2"}
list.foreach(...)
```
В терминах реализации для каждого анонимного метода в исходном коде по-прежнему создается метод в коде IL. 
Компилятор сгенерирует метод внутри существующего класса, а затем будет использовать его в качестве действия при создании экземпляра делегата, как если бы это был обычный метод

#### Возвращение значений из анонимных методов
```
public delegate bool Predicate<T>(T obj) Predicate<int> isEven = delegate(int x) { return x % 2 == 0; };
public delegate T Predicate<T>(T obj) // Func - что принял, то и вернул
```
Возвращение значения из анонимного метода — это всего лишь возвращение из анонимного метода, а не возвращение из метода, создающего экземпляр делегата
	
#### Захвватывание переменных в анонимных методах
**Замыкание** - функция способна взаимодействовать со средой за пределами предоставляемых параметров
**Внешняя переменная** - это локальная переменная или параметр, область действия которой включает анонимный метод
**this**- внешняя  любого анонимного метода
**Захваченная переменная** - это внешняя переменная внутри анонимного метода
**Функция** - это анонимный метод
**Cреда взаимодействия** - набор захваченных переменных => Использование существующей информации вместо созданиясобственных типов внутри анонимного метода
```
void Count()
{
 int i = 1;
 var action = delegate() 
 {
	int a = 1;
	console.WriteLn("res = " = i+a)
 }
 action();
}	
```
i - захваченная переменная
Если в области действия переменной есть анонимный метод , то переменная внешняя
**Правила**
* При захвате захватывается сама переменная, а не значение. Захваченная переменная - это та же переменная, что и в другом куске метода
* Если смотреть выполнение, то из анонимного метода знаечние выходят измененным
Удобно, чтобы не городить сигнатуру под определенный тип
* Захваченная переменная сущствует пока на нее ссылается хоть один экземпляр делегата. 
* Захваченная переменная хранится в специальном дополнительном классе, а значит в куче	
* Если в цикле есть объявление, а потом анонимный метод, то перменная создается каждый раз и у каждого делегата естьсвоя. * Если есть внешняя, то надо учитывать и нижние процессы
**NB** Внимание к циклам. В цикле есть ссылка. Внешняя перменная общая	

### Реализация итераторов
**Итератор** - шаблон, который позволяет получать доступ ко всем элементам в последовательности, не заботясь о том, какой вид имеет эта последовательность — массив, список, связный список или ничего из перечисленного.
Итератор **перечисляет элементы** последовательности только вперед
С одной коллекцией может работать несколько итераторов 
foreach использует GetEnumerator, MoveNext, Current
#### 1.0 Необходимо реализовать IEnumerable и IEnumerator
	 Enumerator - объект для хранения состояния перечисления
	 MoveNext - переход к следующему
	 Current - текущий

#### 2.0 Yield
```
public IEnumerator GetEnumerator()
		{
			for (int index = 0; index < values.Length; index++)
			{
				yield return values[(index + startingPoint) % values.Length];
			}
		}
```
**yield return** сообщает компилятору, что это не простой метод, а возвращающий итераторный блок 
эту инстраукию можно применять только в методах(свойствах), возвращающих IEnumerable и IEnumerator или обобщенный тип
внутри итераторного блока только yield return
##### Ограничения
* yield return не используют в try, если есть  сatch, то тогда используются блок finally
* yield return или yield break не используют в блоке finally
		
##### Детали
При использовании итераторных блоков у компилятора запрашивается создание конечного автомата. 
Когда компилятор встречает итераторный блок, он создает вложенный тип, предназначенный для конечного автомата. 
Этот тип запоминает точное местонахождение внутри блока и значения локальных переменных	

**Конечный автомат имеет**
* начальное состояние
* при вызове MoveNext выполняет кол из GetEnumerator, пока не будет достигнуто следующее значение или yield return
* при вызове Current возврат последнего выданного знаечния
* должен знать, когда выдача завершена, чтобы метод MoveNext() мог возвратить false
* yield return в переменной реализации Enumerator
				   
Итераторный блок yield return осуществляет только временный выход из метода — на самом деле о нем можно думать как о средстве реализации паузы.
```
создан IEnumerable Create()
	{
		for (var i=0; i<s; i++)
		{
		  Console.WriteLn("1");
		  yield return i;
		  Console.WriteLn("2");
		}
	}   
```
каждый MoveNext дает команду к следующему возврату yield return
**yield break** ранний выход. Кoгда доходит до этой инструкции просто останавливается выполнение
**Finally**
* Блок finally не будет выполнен после остановки метода yield return. Он выполняется либо после остановки выполненеия, либо после yield break. 
* Наиболее распространненное применение освобождение ресурсов
Цикл forach вызывает dispose после окончания выполненения, как и using
		До тех пор пока вызывающий код использует foreach блок finally работает в итераторе как нужно
		finally итераторного блока вызывается при dispose(например в forach)

Подход с итератором можно использовать, когда нужно работать с неявной коллекцией: (список строк - добавляем в коллекцию, пробежавшись циклом - читаем)

### Частичные типы
* Разделение класса(partial) ноги растут из Windows Forms и необходимости разделить представление и логику. 
* Компилятор объединяет файлы перед компиляцией
* Части должны быть целиком в одном файле

#### Ограничения
* индентичность непротиворечия реализации
* могут быть разнесены ограничения типа. Они не должны противоречить друг другу
* инициализация переменных в разных файлах раздельная

#### Частитные методы
* если способ добавить поведение, но оно определено в автоматически сгенерированном файле, то можно унаследовать от абстрактного класса или переопределить методы или выполнить что-то в конструкторк
* может быть только void и не может принимать Out, но может быть статическим


### Статические классы
* Всегда только один экземпляр
#### Свойства
* все члены статические
* конструктор закрытый
* класс унаследован от object
* Обычно состояние не поддерживается, если только не задействовано кеширование или шаблон с единственным экземпляром
* видимых конструкторов нет-класс запечатаный(sealed) Если не закрывать конструктор, то компилятор добавляет* автоматически пустой	
#### Ограничения		
* не может быть abstract
* невозможно реализовывать интерфейсы
* нельзя указывать базовый тип
* нельзя включать любые члены protected или protected internal
			
### Отдельные модификаторы доступа
```
	public string Name
	{
		get { return name; }
		private set
		{
		name = value;
		}
	}
```
	отдельное средство получения или установки может быть только более закрытым, чем свойство.

### Псевдонимы пространства имен
* Если в двух сборках есть одинаковый тип могут быть использованы псевдонима using Out = System.Console
* Внешний псевдоним может указываться в alias

### Директива Pragma
* pragma - директива препроцессора, представляемая строкой. Может изменить поведение спецификации
* #pragma warning - если поставить перед строкой, вызывающей предупреждения disable, а после включить(для проверки дальнейших строк), то предупреждение обернутой строки не будет выполнено
* #pragma checksuь вычисление суммы на страницу(когда не работает дебаг, если файд изменили но скомпилированная версия * отличается)
### Открытие внутреннего кода для дружественных сборок
* InternalsVisibleToAttribute(Attribut) этот атрибут применяется только к сборке. 
* Сборка созданная с атрибутом используется к дружественной сборке.
* Атрибутов может быть несколько
* Дружественная сборка может видеть внутренние члены исходной сборки(только свойства и члены public)
* Удобно использлвать для внутренних членов(тестирование например)

## 3.0
### Автоматичесеки реализуемые свойства
Отказ от применения автоматических свойств не дает преимушеств

**NB** Вопрос почему не использовать открытие переменные вместо свойств, особено автогенерирвоанынх
### Неявная типизация локальных переменых
* компилятор получает тип выражения на этапе компиляции
* переменная все равно статически типизирована

#### Ограничения неявной типизации
* Объявляемая переменная является локальной, но не статическим полем или полем экземпляра.
* перемменная имеющая в виде части объявление
* выражение инициализации не является группой методов или анонимной функцией
* выражение инициализации не дает в результате null
* в операторе определена только одна пемеренная
* тип, который нужно назначить переменной, является типом выражения инициализации на этапе компиляции.
* в выражении инициализации не задействована объявляемая переменная

**За использование**: для анонимных типво сокращается объем кода
**Против использования**: неявность если типы похожи int, long

### Упрощенная инициализация 
* Упрощенную инициализаию можено применить к классам с конструктором без параметра. 
* Свойства устанавливаются в порядке заполнения - это создание объекта в одном выражении
* После вызова конструктора указанные свойства устанавливаются очевидным образом.
* Они устанавливаются в порядке, в котором заданы внутри инициализатора объекта, и каждое конкретное свойство можно * указывать только один раз

### Неявно типизированные массивы
```new[]{"r","m"}```
При компиляции выясняется тип массива. если в качестве инициализирующих параметров не один тип - ошибка окмпиляции
при создании массивов не работает контрвариация. все типы должны быть определены явно (object не может быть включен) - ????

### Анонимные типы
```new {name = "a", age = "5"}```
Внутри любой сборки компилятор трактует два инициализурующихся автономныx объектов , как относящихся к одному и тому же типу, если совпадает количество свойств, порядок и имена
#### Анонимные типы содержат 
* конструктор с инициализурующимися значениями
* открытые свойства только для чтения
* закрытые поля только для чтения, поддерживающие эти свойства.
* сравнение значений свойств Equals(), GetHashCode() и ToString().

**Эквивалентность** двух экземпляров одного анонимного типа определяется в естественной манере, со сравнением значений свойств по очереди. 
**Генерация хеш-кода** работает аналогично, поочередно вызывая метод GetHashCode() на значении каждого свойства и комбинируя результаты
Для анонимных типвов важен порядок

### Лямбда-выражения и деревья выражении
Во многих отношениях лямбда-выражения можно рассматривать как эволюцию анонимных методов из версии C# 2. 
Лямбда-выражения позволяют делать почти все то, что могут делать анонимные методы, и они практически всегда более
читабельны и компактны

**Деревья выражений** - это структура данных представляющая логику лямбда выражений. Это способ предоставления операций в конвейерах данных Ling
**Лямбда-выражения** это эволюция анонимных методов . 
**Анонимная функция** - это делагаты и анаонимные методы и лямбда-выражения
Обобщенные делегаты имеют 4 парметра

Трансформация лямбда-выражения
**2.0**
```Func<string,double,int>``` эквивалент типа делегата 
```
public delegate int SomeDelegate(string argl, double arg2)
Func<string,int> returnLength;
returnLength = delegate (string text) { return text.Length; };
```
**3.0**	Лямбда-эквивалент
```
Func<string,int> returnLength;
returnLength = (string text) => { return text.Length; };  - создание экземпляра делегата
Console.WriteLine(returnLength("Hello"));
```
**(string text) => text.length()** одиночное выражение как тело.
возможность неявно типизированных парметров => **text => text.length**
			
Поддержка лямбда-выражений основана на мастерстве компилятора. 
Компилятор Microsoft полагает, что может выиграть от повторного использования экземпляра делегата, если код обратится к нему еще раз, поэтому **кеширует** его.	
			
#### Деревья выражений
##### Функции:
* демонстрация преобразования лямбда выражений в экземпляры делегатов.
* абстрактный Способ предоставления кода в виде дерева объектов
* Область применения деревьев - ling
* Деревья выражений - это деревья объектов, где каждый узел  - выражение

Все выражения унаследованы от **Expression - абстарактный класс**, из статических фабричных методов для создания экземпляров других классов выражений
Свойства:
* Type - тип выражения возвращаемого
* NodeType - вид выражения в виде члена перечисления ExpressionType
```
Expression a = Expression.Const(1)  /*ConstantExpression NodeType=Constant Type=System.Int32 Value=1*/
Expression b = Expression.Const(2)
Ecpression add = Expression.Add(a, b) /* BinaryExpression NodeType=Add Type=System.Int32*/
Console.Writeln(add)
```
##### Компиляция деревьев выражений в делегаты
В число типов произведенных от Expression входит **LambdaExpression**
От LambdaExpression унаследован **Expression<TDelegate>**

**Expression<TDelegate>** является статически типизированным для отражения вида представляемого выражения в терминах возвращаемого типа и параметров. 
параметр типа TDelegate, должен быть типом делегата.
Выражение сложения это Func<int>, поэтому выражение сложения это Expression<Func<int>>(принял int, отдал int)

LambdaExpression определен метод **Compile()** - создает делегат подходящего типа
**Lambda** - метод для представления значения в статически типизированной манере
	
Реализация через LambdaExpression<TDelegate>
```
Expression a = Expression.Const(1)
Expression b = Expression.Const(2)
Ecpression c = Expression.Add(a, b)
Func<int> r = Expression.Lambda<Func<int>>(add).Compile()
```			
**Compile** - создает делегат подходящего типа
**Lambda**- для представления значения в статически типизированной манере
		
##### Преобразование лямбда в деревья
лямбда-выражения могут быть преобразованы в соответствующие экземпляры делегатов, либо неявно, либо явно
```
Expression<Func<int>> return5 = () => 5; // лямбда-выражение было преобразовано в дерево выражения без приведений
Func<int> compiled = return5.Compile(); 
Console.WriteLine(compiled());
```
сложнее с парметрами
```
Expression<Func<string, string, bool>> expression = (x, у) => x.StartsWith(у);
var compiled = expression.Compile();
Console.WriteLine(compiled("First", "Second"));
Console.WriteLine(compiled("First", "Fir"));
```
**Выражение - инстукция**. Принимает внутрь делегат по сути получает иерархический набор инструкций
Выражения принимающие делегат выделяют при выполнении:
* входящие параметры делегата
    ```var target = Expression.Parameter(typeof(string), "x");```
* cигнатуру метода(сам метод) делегата, 
	```MethodInfo method = typeof(string).GetMethod("StartsWith", new[] { typeof(string) });```
* возвращаемый тип
    * После разбивки строится выражение вызова (построение метода как выражения+параметры+метод)
    ```Expression call = Expression.Call(target, method, methodArgs);```
    * Преобразуется вызова метода в лямбда-выражение Lambda<тип делегата + сигнатура>
        ```
        var lambdaParameters = new[] { target, methodArg };
        var lambda = Expression.Lambda<Func<string, string, bool>>(call, lambdaParameters);
        ```
    * вызывает экземпляр чререз Compile. 
		```var compiled = lambda.Compile();```

##### Использование деревьев выражений в LINQ
Как **LINQ to Objects**, так и **LINQ to SQL** начинают с кода C#. 
После компиляции    LINQ to Objects вызывается код IL, использующий делегаты.
					LINQ to SQL вызывается код IL, использующий деревья выражений
###### Свойства деревьев
* неизменяемы (можно кешировать)
* объединяемы (можно формировать сложное поведение на основе простых строительных блоков)
* могут быть скомпилированы в делегаты
* с выражениями получаем более простую рефлексию

##### Изменения в выведении типов и распознавание пергруженных версий
* самая распространенная ситуация для выведения типов возникает при вызове обобщенного метода без указания любых аргументов типов
* если вызвать обобщенный метод, используя лямбда-выражение со списком неявно типизированных параметров, компилятору придется выяснить, о каких типах идет речь, до того как он сможет проверить тело лямбда-выражения.
* тема о выведении типов на основании входящих данных, например если реализоввынный делегат должен был возвращать и int, и object, но при этом выводимый тип T, то результатом будет object и упакованные int
```	
static void PrintType<T> (Т first, Т second)
{
Console.WriteLine(typeof(T));
}
PrintType(1, new object());
```
###### Этапы	
1. сначала проверяется соответсвие параметров одному типу(Вывести информацию из явно типизированных аргументов) 
	2.0 - падаем на этапе компиляции
	3.0 произойдет попытка неявной типизации к object
3. Производится фиксация типов, не зависящих от других типов н-р первый входной тип известен, теперь может быть преобразован
4. Проверяется все ли типы зафиксированны
5. Если остались незафиксированные - Вывести дополнительную информацию на основе недавно фиксированных параметров типов
6. Проверка возможна когда известны все типы параметров
7. лямбда-выражения воспринимаются компилятором, если известны все типы параметров
8. Анонимные функции (анонимные методы и лямбда-выражения) имеют выведенные возвращаемые типы, основанные на типах, которые использовались во всех операторах return.
9. при поиске лучшей перегруженного метода, где есть анонимная функция, принимается во внимание возвращаемый тип

#### Расширяющие методы
##### Задачи
* добавить к типу определенные члены.
* не нуждаетесь в добавлении каких-то дополнительных данных к экземплярам типа.
* не можете изменить сам тип, поскольку он находится в коде у кого-то другого.

##### Характеристика расширяющего метода
* невложенный необобщенный статический класс
* принимает хотя бы один параметр.
* первый параметр this без ref и out
* первый парметр  - это тип который расширяем

##### Поведение компилятора
Когда компилятор сталкивается с конструкцией, которая не определена в типе, он идет к поиску расширяющих методов
Если расширяющий метод был определен как типе, то предпочтение отдается новому

##### Расширяющие методы IEnumerable
Два шаблона обработки цепочек вызова
* шаблон “возврат той же самой ссылки” хорошо работает для изменяемых типов, 
* шаблон “возврат нового экземпляра, который является копией исходного с некоторыми изменениями” для неизменяемых типов требуется - string списка или массива.
LINQ - свободные от побочных эффектов: не изменяют входящую коллекцию

**NB** !Использование сортировки, обратный порядок-память. Буферизация vs ленивое исполнение
		OrderBy возвращает новую коллекцию

#### Выражения запросов и LINQ to Objects
Выражения запросов преобразуются в обычный код, который компилируюется обычным способом

##### Введение в linq
**Ключевое отличие последовательности и других структур**: 
* при чтении коллекции неизвестно число ожидающих элементов последовательности 	
* нельзя получить доступ к произвольному элементу, только к текущему

Причтении выражения запроса нужно думать о задействованных коллекциях
Могут быть бесконечные последовательности случайных чисел, но списки не массивы, хоть и последовательны. 
массивы конечны

##### Отложенное выполнение и организация потока
* Когда составлено выражение запроса, данные не обрабатываются
* В памяти строится представление запроса:
    - Для предоставления условий запроса и выбора строятся делегаты(их экземпляры)
    - обработка коллекции и вызовов выполняется поэтапно извлечение(where) -> извлечение(where)-> возврат
    - выполенение происходит только тогда, когда запрашивается первый элемент.
    - выборка происходит пооэлементно, а не пачкой
    - если нужны все данные, как reverse, то должны извлекаться полностью в буфер
* Отложенное выполнение - если возвращается новая последовательность
* Немедленное выполнение - если число, то немедленная 

##### Стандартные операции запросов
Стандартные операции запросов - коллекция трансформаций с понятным смыслом
Метод обработки данных зависит от поставщиков данных

##### Трансляция компилятора как основа выражений запросов
* Трансляция делается механически без анализа, когда происходит попытка трансформации ling в Lambda
* Вторая ступень - это поиск обычного члена класса или расширяющего метода. Параметр может иметь подходящий тип делегата, либо Expression для типа T
    * **Именно в этот момент важно, что лямбда-выражение может быть делегатом или деревом выражений. Деревья нужны для поставщиков SQL**
	* Если параметр имеет тип делегата, то компилятор будет принимать в качестве аргеумента лямбда-выражение, а затем искать метод с подходящей сигнатурой
	* Если в лямбда выражении используется переменнная, то она является захваченной
	В качестве объекта для LINQ могут выступать не только IEnumerable, но и обычные классы. 
* После трансляции поиск идет по расширяющим методам и методам экземпляра

##### Переменные диапазона и нетривиальная проекция
Переменная диапазона 
```
from user in table.Users user - переменная диапазона
Select user - использует переменную диапазона
```
переменная диапазона доступна только в выражениях и предназначены для передачи контекста одного выражения в другое
Представляют элементы последовательности и нужны для трансляции
	```SIMPLE.ALL.SELECT(x => x) SELECT(none)``` => это проекция. Именно в этом случае используется преобразование лямбды в делегат 	
Сначала один тип выше, потом другой для ```Select<TS, TRES>(this, Func<TS, TRES>)```
	
##### Явно типизированные переменные диапазонов
принимают произвольную нетипизированную последовательность и возвращают строго типизированную последовательность
	cast - приведения каждого элемента к целевому типу-и отказа в случае, если элемент имеет неподходящий тип
	ofType - сначала проверяем всю коллекцию, пропуская некорректный тип		
```from string a in list select a.substring(0, 2)``` трансформируется в ```list.Cast<string>().select(x => x)```

##### Фильтрация и упорядочивание
Компилятор транслирует в Where() с лямбда-выражением, которое использует перменную диапазона как параметр, а в качестве тела - выражение фильтра.
Выражение фильтра применяется как предикат к каждому элементу потока + в результате получаем новую последовательность
**Вырожденные выражения запроса:**
```
SampleData.AllDefects
SampleData.AllDefects.Select(defect => defect) -вырожденный
```
* Элементы, возвращаемые обеими последовательностями, будут одинаковыми, но результатом метода Select() является просто последовательность элементов, но не сам источник. 
* Результатом выражения запроса никогда не должен быть тот же самый объект, что и источник данных, если только не окажется, что поставщик LINQ неудачно спроектирован. 
* важно для целостности данных — поставщик может возвращать изменяемый результирующий объект, зная, что изменения ввозвращаемых данных не затронут оригинал, даже в случае вырожденного запроса

##### OrderBy
* при фильтрации коллекции первый в списке элемент сортировки помещается в orderby, остальные в thenBy(фильтрация по нескольким полям) 
* выполнение упорядочения требует загрузки всех данных

##### Let 
* вводит новую переменную диапазона со значением, которое может быть основано на других переменных диапазона
* задействует прозрачные идентификаторы

length - дорогостаящая операция
переменная на этапе трансляции вводится как анонимный тип
	let length = user.Name.Length
	users.select(x => new {user, length = user.name.length})
заключительнsq шага трансляции прозрачный идентификатор уничтожается

##### соединения(JOIN)
* первое выражение селектора ключей применяется к каждому эелементу второй поселедовательности, 
* второе выражение применяется к каждому элементу первой. На выходе получаем последовательность всех елементов, где ключ первого элемента совпадает с ключом второго. 
* для сложных ключей подходят анонимные типы. 
* сначала сопоставляется первая коллекиця со вторым ключом, потом результат буферизуется и начинается второе сопоставление.
* чтение также является отложенным до первого элемента последовательности
* ключи должны быть указаны соответственно первый второй не поменяв место
* при трансляции если поставить Join без select, то компилятор вводит программный идентификатор, чтобы сделать переменные * диапазонов, применяемые в обеих последовательностях

##### Групповые соедниения JOIN INTO
Возможно добавить в перменную полностью вторую последовательность, если после сопоставления equals сделать into

##### Перекрестное соединение
Создание новой последовательности если использовать два и более from без условий сопоставления. будет создано перечисление двух коллекций - все возможные пары.
Транслируется через SelectMany
	SelectMany полностью потоковое выполнение. обрабатывает по оному элементу, поэтому не нужно все грузить в память

##### Группировка
* Выполнение группировки определяет, каким образом последовательность группируется —это селектор ключей операции группирования.
* Общий результат - это последовательность, где каждый элемент  - группа. в каждой группе есть key. для группировки по сложному ключу используют анониимный тип.
* группировка применяется к каждой записи в ходящей коллекции, а последовательность группируется на основании выражения
* не может быть обеспечена организация потоков для результатов, все сгруппированные последовательности после применения выражения буферизуются.
* выполнение также отложенное
* Штука внутри groupBy - select - это проекция

##### Продолжение запрса
способ использования результата группировки для другого выражения.
для этого используется инструкция ```into select new{}```
все переменные диапазонов могут иползоваться после Into, кроме переменной диапазона в group by
Для join into используется только новая переменная диапазона

##### Выбор между выражениями запросов и точечной нотацией(lambda-код после трансляции)
Как понятнее, так и делать при выборе между lambda и linq
Компилятор не видит разницы между linq to object и linq to sql

#### LINQ за рамками коллекций
* контекст данных можно рассматривать как точку соприкосновения с базой данных
* контексты данных отвечают:
    * за управление транзакциями, 
    * трансляцию запросов, 
    * отслеживаение изменений в сущностях, 
    * обработку идентичности.
* если применять веменные переменные , то на месте использования переменнной генерируется sql код с вложенные запросом
* если в Linq запрсое будет использованы навигационные свойства , то они транслируются в Inner join

##### Трансляция с использование IQueryable И IQueryProvider
###### Преобразование выражений запрсоов в SQL
* Источник linq to object реализует IEnumerable, к нему приименяются расширяющие методы, так и 
* Table реализует IQueryable и применяет расширяющие методы класса Queryble
* Ling строит дерево, а потом позволяет выполнить поставщику

**IQueryable<T>** унаследован от **IEnumerable<T> И IQueryable**
Оба родителя унаследованы от IEnumerable
IQueryable имеет три свойства QueryProvider, ElementType, Expression

**IQueryable** - запрос, который будет выдавать последовательность результатов, когда он запущен на выполнение. 
Детали запроса в терминах LINQ хранятся в дереве выражения, которое возвращается свойством Expression интерфейса IQueryable. 
Запрос выполняется путем прохода по IQueryable (другими словами, вызовом метода GetEnumerator() и затем метода MoveNext() на полученном результате) или вызова метода Execute() на IQueryProvider с передачей ему дерева выражения.

##### IQueryProvider
* Для постоения запроса необходимо вызвать CreateQuery на подходящем IQueryProvider. 
* Запрос можно не только запускать, но и добавлять в другие
* Источник данных может воспринимать как запрос и дополнительные вызовы Where select orderby дают везультате другойапрос основанный на первом
* Имея любой запрос IQueryable можно создать новый запрос за счет шагов
    * Получить у запроса его дерево выражений через Expression
    * получить новое дерево выражений, которое содержит исходное выражение и дополнительную функциональность(фильтр, проекция)
    * Получить у запроса существующего поставщика через provider
    * вызвать метод createQuery на поставщике, передав новое дерево выражений

большая часть интенсивной работы поставщиков запросов производится, когда анализируется дерево выражений и * преобразовывается в форму подходящую для целевой платформы

##### Важное отличие между реализацией Enumerable и Queryble
Все методы Enumerable используют в качестве параметров делегаты например ```Select<Func<TSource, TResult>.>- ```
Это удобно для манипуляций в памяти, но для поставщиков linq которые выполняют запросы на стороны необходим формат, который можно исследовать более тщательно - деревья выражений. 
Для компилятоора нет разницы, т.к после трансляции получается лямбда-выражение, которое может быть преобразовано либо в делегат, либо в дерево выражений
А передается в целевой метод (where как func или expression)

**Источник linq to sql всегда требует деревья выражений**
Источник данных важен тогда, когда копилятор анализурует транслируемный запрос, чтобы найти подхлдящие реализации(where select)
Расширябщие методы Enumerable выполняют действительную работу, соответствующую запросу(строят итераторы для работы)

**Например** where  построил запрос, применил вильтр, выдал подходящие элементы в качестве результата
В Queryble только создаентся новый запрос на основе параметров и вызывается execute поставщика запросов.
Он не содержить логику, вся логика на поставщике

вся информация, представленная в исходном выражении запроса уже есть
Как только вызывается GetEnumerator получается рузультирующая последовательность. 

#### Paralell Linq
* ParalellEnumerable содержит расширяющие методы большинство из которых возвращает IEnumerable, поэтому результаты обрабатываются обычным образом. 
* Собственные расширяющие методы имеют приеритет над IEnumerable чтобы распалаллелить запрос необходимо применить asParalell() к источнику коллекции
* Выполнение не является упорядоченным. упорядочивание требует координации между потоками
* Для решения проблемы можно представить запрос как упорядоченный через asOrdered()

#### Ling to rx
До это данные в linq запросы доставлялись пассивно через IEnumerable
Есть вариант использовать активную доствку реагруя на появление новых данных
Модель Rx математически двойственна обычной модели IEnumerable: 
* При пассивной работе с данными мы простим предоставить Enumerator и затем запрашивается есть ли еще элемент (MoveNext),если * есть дай current
* в ling to rx это перевернуто, вместо запрашивания итератора или элемента, код сообщает когда готов , либо когда ошибка, * либо конец данных

**IObservable<out T> - ковариантный
IObservable<in T> - контрвариантный**
Наблюдатель имеет аналог для методов MoveNext, Current, Exception, OnNext, OnCompleted, OnError
Наблюдаемый объект может быть холодным или горячим. Холодный, когда нет наблюдателей, когда есть  - горячий

Для RX нет буферизующих методов Reverse и OrderBy 
Между IEnumerable И IObservable нет отношения наследования, но при этом доступны методы преобразований???

#### Расширение Ling to Object
Руководство по проектированию
* модульные тесты
* проверка аргументов при вызове(открытый с проверкой и выполнение итерации)
* Оптимизация
* возможность использования методов Icollection?
* документация
* выполенеие однократного выполненеия, когда возможно лучше буферизировать, если необходимо
* обеспечение освобождения итераторов using. Обычно это делает foreach, но в этому случае лучше предусмотреть
* поддержка специальных сравнений

## C# 4.0
Дополнительные именения
### Необязательные паметры и именованные аргументы
**параметр** - это переменная часть объявления метода
**аргумент** - выражение принимаемое при вызове метода
**необязательные параметры** - это параметры значения которых необязательно указывать при вызове методаю по сути необязательны параметр - частично и аргумент
```void Dump(int х, int у = 20, int z = 30)```
параметр должен быть константой
может быть любого типа

#### Ограничения:
* необязательные после обязательных
* не могут быть ref, out 
* не может быть массив параметров
* Нет возможности использования параметров в конструкторах

Когда компилятор ссылается на значение, крпирует его напрямую в вывод Значение устанавливается при компиляции в исполняемый файл.
Если стандартным значением является null, то можно добавить установку внутри кода для значения null, тем самым обойти ограничение того, что параметр должен быть константой
Минусы: непреднамеренная передача Null и получение exception

### Именованные аргументы
```Dump(z: 3, y: 2, x: 1);```
#### Преимущества: 
* Указание параметров в любом порядке
* Добавление смысла в случае вызова метода с множеством аргументов
* Можно комбинировать вызов обычных аргументов и именованных, но важно что сначала обычные, потом именованные

При объединении подхода именованных параметров и необязательных: в этом подходе можно в любом порядке указывать необязательные параметры

### Перегруженные методы
* Для того чтобы понять могут или не могут методы быть подходящими, строятся все возможные сочетания
* Если есть метод со всеми явными параметрами, а в другом один параметр с необязательным значением, в приоритете метод с явно объявленными параметрами. 
* Стандартные значения или нет - на этот вопрос отвечает компилятор
* Если две реализации void Foo(z1=1, z2=2 ) и void Foo(x = 1) => Foo()вызовет неоднозначность
* Если некотоыре методы объявлены в базовом типе, но в производном классе есть подходящие методы, то прелпочтение * отдается к производным

### Когда ref не являеся ref
важно при использовании ref в методе, ref получается не только параметр, но и аргумент
значение переданного аргумента может быть изменено
	
### Обощенная вариантивность для интерфейсов и делегатов
**Вариативность** - возможность использовать аргументы одного типа, как если бы он имел другой тип в безопасной манере 
Вариантивность в случае объявлении в качестве параметра Steram и возможность использовании MemoryStream это ариативность в рамках обычного наследования

**Обобщенная вариативность**  - это тоже, но применительно к обобщения
**Ковариантивность** - связана со значениями, возвращаемыми из операции обратно в вызываемый метод
```
interface IFactory<T> {
	T CreateInstance() // 	Возвращаемое значение T. Может трактовать фабрику, как фабрику более общего типа.
}
```
**Контрвариантность** связана со значениями, передаваемыми в api интерфейса. Потребление значение
```
interface IPrettyFilter<T>
{
	void Print(T document)
}
```
**Инвариативность** возможность движения в обе стороны	
```
interface IStorage<T>
{
	byte[] Serialize(T value)
	T Deserialize(byte[] data)
}
```

### Вариативность в интерфейсах
можно указывать, как может использоваться параметр типа ковариантно out или контравариантно in
любое преобразование это ссылочное преобразование. 
После преобразования возвращается таже ссылка. 
Преобразование трактует существующую ссылку, как если бы оно было целевым типом

Если параметр нужен только на выход то out 
```public interface IEnumerable<out T>```
Если на вход то In 
```public interface IComparer<in T>```

Контрвариантность использует метод сравнения Compare(IShape x1, IShape x2) 
Каждый из параметров имеет один тип , поэтому сравним площади, которые опредлены у базового типа 		
**Делегаты являются инвариантными**
```
Func<Square> factory = () => new Square()
Func<IShape> shapefactory = factory - контрвариантность
Action<IShape> printer = shape => concole.writeln(shape.area)
Acrion<Square> squarePrint = printer -контрвариантность
```

#### Ограничения
* только ссылочное преобразование (сделано для того, чтобы среда CLR могла знать, что операции будут безопасными к типам)
* Вариантные параметры типов могут иметь только интерфейсы и делегаты	
* параметры out не являются выходными - просто указание
* вариативность должна быть явной
    По умолчанию компилятор не имеет сам возможности разрусли вариантивность. нужно тщательно планировать работы, ибо безудумно существующие преобразования могут внести путаницу
* не смешивать групповые делегаты и вариативность - не добавлять в групповые делегаты string и object(хотя реобразования возможны)

### Изменения в блокировке
* Надежная блокировка
    lock компилируется в monitor.
    Раньше запрос блокировки было до try => метод в lock. Теперь в try => запрос+метод из lock
    ```
    try {
        System.Threading.Monitor.Enter(__lockObj, ref __lockWasTaken);
        // Your code...
    }
    finally {
        if (__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);
    }
    ```
* Изменения в событиях
	**Безопасность потков**
	До 4.0 блокировка была либо на this либо на тип для статических событий. Теперь копилятор реализует к потокам атомарную подписку-отмену через interlocked

### Динамическое связывание в статическом языке
* C# всегда был статически типизированным. в 4.0 появился тип dynamic - можно делать все на этапе компиляции
* В статическом языке компилятору известным типы выражений, а также члены доступные в любом типе.
* Процесс выяснения, какой член принадлежит применению, связывание происходит на этапе компиляции
* Добавили чтобы избавить от ошибок приведения , когда появились ironRuby, ironpyton
	**Минусы**
		ошибки на этапе выполнения, 
	**Плюсы**
		рефлексия сложнее и затратнее

В динамически типизированном языке все связывание осуществляется во время выполнения. 
компилятор или анализатор проверяет синтаксическую правильность, но не может удостовериться, что использованные методы и свойства существуют	
Для некоторых динамических языков (F#) используется интерпретатор и компилирует на лету
В C# интерпретатора во время выполнения нет
	**Когда удобно**	
* Известны только имя метода аргументы и объект, где он должен быть вызван
* **Утиная типизация** - если что-то выглядит как утка, плавает как утка и крякает как утка - это утка
Введен тип dynamic - это для компилятора, не тиа clr

Применяется сложный набор правил для точного определения члена, который должен использоваться в той или инойситуации:
* компилятор просто анализирует исходный код,
* определяет вид операции, которую вы пытаетесь запустить, ее имени, задействованных аргументов и любой другой существенной информации. 
* компилятор генерирует код, который обращается к среде DLR
* остальная работа производится во время выполнения.

##### Главые правила
* Существует неявное преобразование из почти любого типа clr в dynamic
* существует почти любое преобразование dynamic в clr
* выражения dynamic вычисляются динамически
* статическим типам динамически выполненное выражение считается dynamic
		разрешенными преобразования, которые существуют в clr string !=> int

##### отличия var и dynamic
* var используется только если типа переменной может быть выведен статически и система типов остается полностью статической.
* если var присвоить dynamic, то переменная будет типизирована как dynamic

##### для чего использовать:
* пользовательские сценарии
* уровень приложения к ironpyton
* pyton как язык конфигурации
* pyton как хранение правил
* использование библиотек из pyton в .net  если нет аналога
* интерактивный интерпретатор для отладки
	**резюме**: есть мезанизмы реализации pyton или ruby в с#. Если нужен результат функции, то нужно присвоить dynamic
	Скрипты можно использовать там, где нужно динамически(из сбооки на сервере) проконтролировать количество фоновых потоков, например реконфигурирование налету

##### Динамическая типизация и рефлексия
* сложности с рефлексией могут возникнуть для обощенных типов и поиска нужных методов
* эту задачу решает dynamic

**При статической типизации** c# использует одиночную дипетчиризацию: во время выоплнения точный метод зависит только от действительного типа целевого объекта

**Динамическая типизация** использует множественную диспетчеризацию: для нахождения наиболее специализированной реализации метода на основе типов аргументов во время выполнения
	
#### Введение в DLR
**DLR** - исполняющая среда исполняющего языка
DLR это БИБЛИОТЕКА, которую применяют динамические языки для динамического выполнения кода
DLR не на том же уровне, что и clr и не имеет отношения к JIT компиляции, сборке мусора и т.д
построена на .net 2.0, 3.5
```
	ruby pyton			   | 
	FronRuby frompyton     | VB C#           -приложения
	_______________________|_________________________________
	dlr(связыватели)       | .net библиотек
	_______________________|_________________________________
	mscorlib, system,core   -системные библмотеки
	jit, GC					- общеязыковая исполняющая среда
```
##### Ход обработки
```
	   d.foo
		|(компилятор c# )
	вызывающий компонент - связывание IL
		|(однократное и повтоное исполнение объектов)
		| DLR + динамические объекты + связыватели C#
	вызывающий компонент - кеширование(IL+правила) | Связыватель -> Кеширование (правила) Объекты с кешированным поведением
		| (JIT-компиляция (кода IL в кеше))
	вызывающий компонет - кеширование (IL+машинный код+правила) | связыыватель(кеширование и правила)
		|
	получаем машинынй код в следующий раз используемый
```
**резюме**
Получение высокоуровневого представления кода  и запуск кода на основе различной информации
одним из важных аспектов среды DLR является многоуровневый кеш
##### Вызывающие компоненты
* Мелкая единица кода, которая яаляется одиночной выполняемой единицей. 
* Одно выражение может содержать множество вызывающих компонетов, но поведение выстроено естесвенным образом с выполнением одного компонента за раз
* d.foo это один вызывающий компонент

##### Получатели и свзыватели
* **Получатель вызова** - это объект на котором вызывается член
    получатель это объект, на который ссылается d во время выполнения
* **Связыватель** зависит от языка вызова к вызывающему компоненту.
		например связыватель с# и COM
	
DLR отдает предпочтение получателю, если это динамический объект, которому известно, как обрабатывать вызов
Если получатель не является динамическим, решение о том, как должен выполняться код, принимает связыватель. применение специфичных для С# правил к коду и выяснение, что будет делаться
	
##### Правила и кеширование
Решение о том, как выполянть вызов - это правило: 
	обстоятельства, при которых вызывающий компонент должен вести себя подобным образом, и самого поведения.

Поведение представлено в виде дерева выражений: представление в форме дерева выражения означает возможность серьезной оптимизации за счет применения кеша
			
В DLR есть кеши трех уровней L0, L1, L2
	**L0, L1** собственные
	**L2** разделается междумножеством вызывающих компонентов
	
Набор вызывающих компонентов, разделяющих L2 определяется связывателем
* каждый связыватель имеет ассоциированный с ним кеш L2
* для каждого вызывающего компонента он создает новый связыватель, так что для разработчиков на C# особойразницы между кешами L1 и L2 не существует

**Кеш**  - это исполняемый код
	компилятор c# генерирует код, чтобы выполнить L0 или вызывающего компонента(делегат, доступный через свойство Target))
Кеш L0 имеет единственное правило, которое проверяется при его вызове. 
* если правило удовлетворено, выполняется связанное поведение. 
* если же правило не удовлетворено (или это вызов в первый раз, так что правила вообще еще нет)
    * в действие вводится кеш L1, который  вводит в игру кеш L2. 
    * если кеш L2 не может найти совпадающие правила, он предлагает распознать вызов получателю или связывателю. 
    * результаты затем помещаются в кеш для следующего раза.

L1 L2 имеют коллекцию правил и ппросматривают правила на предмет совпадения. 
L0 имеет две части: 
* проверка правила 
* делегирвоани управления L1 - они объединены в единый метод, который применяется JIT-компиляция
	
Обновление L0 предполагает повторное построение метода из нового правила
	Типовые вызывающие компоненты видят похожий контекст и являются быстрыми
```
вызывающий компонент    связыватель
кеш L0: делегат	 -> |	кеш L2 			<-	| множество вызывающих компонентов
_______________   		правила 		<-	|	с одной семантикой
кеш L1: правило	 -> |
```

##### Как компилятор обрабатывает динамическое поведение
Главная работа компилятора, когда добирается до динамического кода является выяснение, что требуется динамическое поведние и захват необходимого контекста
связыватель и получатель обладают достаточной информацией для распознавания вызова во время выполнения

Если используется dynamic, то вызов динамический
Динамическая ситуация: цель на которой вызывается член является динамической
возможны две ситуации:
* динамический объект сам распознает вызов
* связывателю C# возможно придется распознавать его позже с помощью рефлексии
		
Правило когда аргумент является динамическим
* если любая часть вызова является динамической , то вызов становится динамическим и перегруженная версия будет распознаваться с применением динамического типа значения
* если выражение типа dynamic 
```
			sring c = "r"
			dynamic c1 = 0
			array = new []{c, c1} // ошибки компиляции не будет так как выражение dynamic
```
* Динамически вычисляемые выражения не всегда dynamic
```
		dynamic d = GetVaiueDynamically();
		SomeType x = new SomeType(d);		
```
Сам вызов конструктора должен быть выполнен динамически. 
Во время выполнения может потребоваться распознавание между множеством перегруженных версий, но результат всегда должен быть ссылкой на SomeType. 
По этой причине присваивание переменной х может происходить без динамического преобразования.

##### Ограничения динамического кода
* нет расширяющих методов. компилятор не располагает сведениями о том, какие методы будут доступны во время выполнения
* ограничения преобразователей делегатов, нельзя использовать лямбда-выражения 
* 	при преобразовании лямбда-выражения, анонимного метода или группы методов компилятор должен знать точный тип задействованного делегата
* нельзя распознать конструктор или статический метод на динамическом типе нельзя
* 	но можно передать динамические аргументы
* базовый класс не может иметь тип dynamic. 
* нельзя использовать dynamic в ограничении параметра типа или как часть набора интерфейсов, которые тип реализует.

**резюме**: dynamic не существует в среде clr и он нем ничего не известно. 
		случаи использования dynamic транслируются в object c атрибутом[DynamicAttribute]
		атрибут четко указывает, какие части типа являются динамическими

## 5.0 
### Ассинхронность
**Ассинхронность**  - способ изьежать блокирования потока на время ожидания произвольной задачи.

#### Три подхода внутри .NET
* Подход BeginFoo()/EndFoo() - в котором для передачи результатов применяются IAsyncResult и AsyncCallback.
* Шаблон остнованный на событиях(BackgroundWorker и WebClient)
* Библиотека параллельныз задач TPL 
* async/await построено на основе TPL можно писать код,подобный синхронному,который использует ассинхронный, когда уместно
		
**ассинхронная функция** - это метод, либо анонимная функция, которая объявлена с модификатором async и может включатьвыражения await.
	
**NB** Анонимная функция - это лямбда-выражение или анонимный метод

**Выражения await**  -точки, где происходит:
* пока не достигунто по-настоящему ассинхронное выражение await метод выполняется синхронно
* если значение ожидаемое выполнением не достигунто, асинхронная функция немедленно дает возврат и будет продолжен с места, в котором управление ее покинуло, когда значение станет доступным
* главная задача - избежать блокирования, пока ожидается выполнение длительной операции
    * при использовании await текущий поток не блокируется
    * До точки await метод выполняется синхронно в потоке, по достижении await проверяет доступен ли результат , если это почти всегда он планирует продолжение, когда операция завершится
	* Продолжение выполнит оставшуюся часть метода, перепрыгивая на конец выражения await 

**Продолжение** -это обратный вызов который должен быть выполнен когда асинхронная операция завершится 
* поддреживает состояние метода( как замыкание поддерживает среду в терминах переменных) 
* запоминает где должно быть активировано
* для присоединения продолжений используется ContinueWith

**Многопоточность часть типового использования ассинхронности но не обязательна для ассинхронного выражения**

#### Основы
* **синхронный пример**:
			Первый выов завершится, а затем начнется второй вызов 
* **асинхронный пример**:
    * В модели ассинхронного выполенения все сводится к продолжениям - сообщение о том, что происходит по звершении
    	**Продолжения это делегаты которые являются действием**, которое получает результаты асинхронной операции
    * await предлагает копилятору построить продолжение
        * вместо передачи продолжения ассинхронной операции эта операция начинается и возвращает маркер, который можно использовать для предоставления продолжения в более позднее время
        * он представляет выполняющуюся операцию, которая может быть завершена перед возвратом в вызывающий код или продолжать свое выполнение
        * после маркер применяется везде, где необходимо остановиться, пока операция не завершена	
        * **Маркер - это Task**
    	* **Wait - блокирует поток**, ожидание завершения (синхронным образом)


#### Шаги потока выполнения:
* некоторая работа
* начать ассинхронную операцию и запомнить маркер 
* дополнительная работа(делать что-то пока ассинхронная операция не завершена) либо ничего
* ожидать через маркер завершения
* дополнительная работа
* завершение
	
Ассинхронная функция возвращает в поток с применением synchronisationContext - зависит от среды

#### Вызывающий метод | Ассинхронный метод | Ассинхронная операция
**вызывающий** - тот кто вызывает
**асинхронный метод** - то где async
**ассинхронная операция** - та где await
**Граница** между вызывающим и ассинхронным методом Task

#### Синтаксис и семантика
async может находиться в любом месте объявления
возможные возвращаемые типы **void, task, Task<TResult>** - производный от Task
* Task не нуждается в генерации результата
* void нужен для совместимости с обработчиками событий
	Подпсика на событие единственный случай использования void
				
#### Ограничения:
* ни один параметр не может быть ref out 
* как и yield return await нельзя применять в catch и finally, в ассинхронных анонимных функциях, в lock
		
Задействован только один интерфейс, который покрывает часть “присоединения продолжения”. 
		Интерфейс находится в пространстве имен ```System.Runtime.CompilerServices``` и выглядит следующим образом:	
```
public interface INotifyCompletion {
void OnCompleted(Action continuation);
}
```
Работа с await похожа на прохождение цикла foreach
		
#### Поток выражений await 
Разворачивание сложных выражений
* await может использоваться с результатом вызова метода 
		```string a = await new Model().getStringAsync()```
* await может применяться как аргумент метода или внутри другого выражения

##### Видимое поведение	
* Если операция завершилась, то поток выполнения продолжается
* Если есть исключение, то оно будет сгенерировано
* Из операции получается результат — путем извлечения string из Task<string> — и происходит переход на следующую часть программы. это делается без переключения контекстов, потоков или присоединения продолжение

**Зачем в таком случае асинхронность?**
* это как count в linq. Есть возможность пройти поэлементно, а есть получить все(оптимизация) единственная абстракция, которая покрывает оба сценария. 
* чтение потока с диска: может быть вериятность что данные до этого кто-то считал и используется результат, а если не считал, то читаем ассинхронно
		
**Если операция по прежнему выполняется**
* медод асинхронно ожидает выполнения операции,
* к ассинхронной операции присоединяется продолжение
* производится возврат (Возобновляется выполнение через продолжение)
* продолжается в соответствующем контексте 
асинхронная операция отвечает за возобновление работы в правильном потоке(либо из пула, либо в пользовательском интерфейсе)

**Два вида возврата из метода**
* выражения await, которое фактически ожидается, поэтому в стеке присутствует первоначальный вызывающий метод  
	по сути возвращение task task<Tresult> возвращающему методу
* ожидается что-то еще, поэтому находимся внутри продолжения, которое было вызвано еще чем-нибудь.
	В стеке будет каша из вызовов в сравнении с началом выполенения

 Вызов асинхронного метода не похож на инициирование новой задачи в отдельном потоке, нужно писать асинхронные методы так, чтобы они обеспечивали быстрый возврат поэтому в ассинхронном методе лучше избегать работы требующей длительного времени лучше вынести  ругой метод, для которого можно создать объект Task.

#### Использование шаблонов ожидания
* если поток выполнения линеен легко представить как выглядит продолжение(как лямбда-выражение)
* если есть циклы и условия, то сложно все уместить в один метод
			
**Схема**
```
				                        встретили await
								оценка выражения поддерживающего ожидание  
												|
									извлечь объект ожидания через GetAwaiter
												|
									Возвратить сначение свойства? 
										awaiter.IsCompleted?
												/\
											 +      -   	
					извлечь результат			\/   запомнить объект ожидания
					черех awaiter.GetResult				 присоединить продолжение через awaiter.OnCompleted
									|					 в случае возврата возобновить через продолжение
									|						|
									\						/
											ПРОДОЛЖЕНИЕ
```								
#### Возвращение значений из ассинхронных методов
	task подобен void, ему не нужен оператор возврата
	task<T> обещаение значения или исключения
	Если в блоке finally будет исключение не получается задача даже если она успешна
	При возврате значения из асинхронного метода проиcходит упаковка в task через return value
	
#### Исключения
* Распаковка исключений при ожидании асинхронного метода или асинхронной операции
    * GetResult предназначение не только для извлечения ожидаемого значения, но и за передачу исключений обратно методу

* Обозначение исключений через task
    * 	status получае знаечние fauled
    * 	exception возвращет agreagteException
    * 	wait сгенерирует exception если задача отказала
    * 	если задача отменена свойство result Task<T> сгенерирует wait 
* Отмену поддерживает canceletionTokenSource и canceletionToken
* Кастомыне исключения при обычном подходе не будет отловлены, потому что RESULT и Wait сгенерируют AgregateException.
    * при этом выдавать будет только первое исключение даже в группе методов
    * можно использовать WhenAll, тогда получим исключения от всех задач, но если сделать await Task.WhenAll(), то получим первое исключение
    * Для решения проблемы можно написать расширяющий метод для Task<T>, который будет генерировать одно исключение AgregateException на всех
	*В этом методе ждем выполнение задачи через Wait и ее рузультат генерирует интересующее исключение в специальном ожидающем объекте

#### Упаковка исключений при генерации между ассинхронным методом и вызывающим методом
* Ассинхронные операции никогда не генерируют исключение прямо при вызове .
* Для ассинхронных методов возвращающих task task<T> любые исключения сгенерированные внутри метода(и синхронных и ассинхроных операций) просто помещаются в задачу
    * 	Если ждем через wait, то получим agreagteException 
    * 	если через await то исключение будет распаковано из задачи
* Ассинхронные методы, возвращающие void  сообщают исключение исходному объекту synchronisationContext, который обрабатывает его в зависимотси от контекста
* Если нет разницы для контекста, то исключение можно перехватить через catch вложенным методом IOException e
	
#### Принудительная генерация исключения
##### Проблема
определение проверки аргументов от реализации(если есть ассинхронный метод, который возвращает task, при этом в вызывающем между вызовом и ассинхронного метода и await его результата происходит еще что-то)
* Исключение будет вызвано только после async
* чтобы решить можено проверить аргумент до вызова ассинхронного метода
* применение асинхронных анонимных функций

#### Обработка отмены
* TPL вводит понятие CanceletionToken(CT) и CanceletionTokenSource(CTS)
* Создаетсся объект CTS
* у него запращивается результат СТ, который передается ассинхронной операции
* Отмену может выполнить только CTS а отражается она на CT

Один и тот же признак можно можно передать нескольким операциям и не перживать, что они будут мешать друг другу 
Существуют разнообразные способы применения признака отмены, но наиболее идиоматический подход предполагает вызов метода ThrowIfCancellationRequested(), сгенерирует исключение OperationCanceledException, если сам признак был отменен, и ничего не делает в противном случае. 

#### Ассинхронные анонимные функции
Это комбинация анонимных функций(лямбда-выражение, анонимные метод) и асинхронных функций
Позволяют создавать делегаты (для создания деревьев выражений их использовать нельзя) которые представляют ассинхронные операции
	```Func<Task> = async()=> await task.Delay(1)```
Все как с анонимными функциями и ассинхронный захват преемнных, вызов делегата запускает операцию
Result блокирует поток до тех пор, пока задача не будет завершена	
		Если спользовать Result, то пока не освободится первая операция, результат второй, даже если он вычислен, получен пока не будет

### Детали реализации
#### Трансформация компилятора
Реализация имеет форму **конечного автомата**
Компилятор генерирует закрытую вложенную структуру для представления ассинхронного метода и должна включить метод, имеющий ту же сигнатуру, как у объявленного - каркасный метод от которого все зависит
Каркасный метод 
* создает конечный автомат 
* заставляет конечный автомат выполнить первый шаг синхронным образом (любой код выполняемый перед await)
* осуществить возврат только когда метод завершен, либо достигнута точка, где необходимо созать ассинхронную операцию
* после завершения первого шага каркасный метод запрашивает у построителя задачу для возвращения
* конечный автомат применяет построитель для установки результатов или исключения
* возвращает задачу для предоставления хода работ конечного автомата

Конечный автомат рассматривает что-то другое 
продолжения, присоединенные к другим асинхронным операциям, просто сообщают конечному автомату о том, что нужно выполнить еще один шаг.
Конечный автомат сигнализирует, когда достигает конца, предоставлением подходящего результата задаче, которая была возвращена ранее.
```				
					каркасный метод
					|
					создать конечный автомат
					|
					выполнить первый шаг
					|
															----------
															Продолжение ассинхронной операции
															-----------
															|
															выполнить тело метода пока не встречен await
															|
															/ 			\
							установить результат задачи	-	  выход из await    + присоединение продолжения
									
															\			/
																возврат
					возврат задачи вызывающему методу
```												
#### Структура каркасного метода
У конченого автомата есть 
* поле для параметра
* поле для AsyncTaskMethodBuilder<int> as **ATB** -структура для связывания конечного автомата и каркасного метода(отдельные для возвратов void task)
* поле state которое хранит значения, начиная с -1. Начальным значением всегда является -1

Конечный автомат - это структура и ATB тоже структура. Сознательно не выполняется выделение памяти в куче. 
если можно ожидать любого выражения await понадобится много значений в куче, но упаковка используется где необходимо. Выделение памяти сведено к минимуму
	вызов ```machine.builder.Start(ref machine)``` - использование здесь передачи по ссылке позволяет избежать создания копии конечного автомата (и таким образом копии построителя) — это сделано в целях производительности и корректности
		
Тип каркасного метода для конкретной реализации
```		
	var machine = new PrintAndWaitStateMachine
	{
		delay = delay,
		builder = AsyncTaskMethodBuilder.Create(),
		state = -1
	};
	machine.builder.Start(ref machine);-передача по ссылке для экономии памяти
	return machine.builder.Task;
```
#### Структура конечного автомата
Конечный автомат всегда реализует интерфейс **IAsyncStateMachine**
Содержит только два метода **MoveNext** и **SetStateMachine**
Каждая локальная переменная имеет собственное поле в конченом автомате, т.к для чтения между вызовами MoveNextдолжны сохраняться значения
Для каждого объекта ожидания(**TaskAwaiter** и **YieldAwaiter**) предусмотрено поле 
* если это тип значения для каждого свое
* одно поле для всех ссылочных типов

**TaskAwaiter** и **YieldAwaiter** это структуры поэтому каждое значение хранится отдельно
* В каждый момент времени может быть активен только один объект ожидания 
* Нужно передавать объекты ожидания между выражениями await, чтобы после завершения операции можно было получить результат.

Поле **State**, которое инициализируется каркасным методом отслеживается текущим методом, отслеживает  текущий статус
**Builder** используется для создания Task Task<T> для возвращения каркасным методом
**Stack** используется когда await встречается как часть оператора, которому необходимо отслеживать дополниельное состояние, не представленное локальную переменную
**SetStateMachine** применяется чтобы упаковать копии конечного автомата иметь ссылку на себе внутри построителя
```
	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
		this.builder.SetStateMachine(stateMachine);
	}
```
**MoveNext()** содержит всю логику первоначального метода, а также код для обработки всех переходов между состояниями, и код оболочки для обработки окончательного результата или исключения.
Конечный автомат имеет единственную точку входа — метод MoveNext()
* метод используется с самого начала и для продолжений всех выражений await. 
* когда вызывается MoveNext():
	* конечный автомат выясняет с помощью поля state, в какой точке метода он находится. 
		* логическая начальная точка метода
		* либо конец выражения await, когда все готово для оценки результата. 
	* конечный автомат выполняется только раз:
		* имеется оператор switch, основанный на state, который содержит различные конструкции case с соответствующими операторами goto для переходов на разные метки.
		    * -1 начальное состояние
		    * Любое неотрицаительное значение - это цель продолжения
		    * -2 когда конченый автомат завершен

Конечный автомат устанавливается там, где необходим, а механизм ассинхронности гарантирует, что одиночная упакованная копия будет использоваться согласованным образом
Чтоыбы избежать лишних выделений памяти конченый автомат реализован как структура, однако по большей части пытается дейстовать как класс

Result устанавливается в точке, где исходный асинхронный метод имеет оператор return 
* переменная result применяется в вызове builder.SetResult(),когда достигается конец метода 
* необобщенные типы содержат методы SetResult():
	* **AsyncTaskMethodBuilder** -  сообщает о факте завершения метода задаче, которая была возвращена из каркасного метода
	* **AsyncVoidMethodBuilder** -  сигнализирует о завершении исходному объекту SynchronizationContext

#### Поток управления await
Любое выражение await  - это разветвление возможных путей управления ожидаемой асинхронной операции извлекается объект ожидания
проверяется его свойство IsCompleted. 
* true, можно получить результат немедленно и продолжить.
* false 
    * запомнить объект ожидания для более позднего применения
    * обновить состояние, чтобы указать, откуда продолжать
    * присоединить продолжение к объекту ожидания
    * осуществить возврат из MoveNext(), удостоверившись, что ни один блок finally не былmвыполнен.
    * при вызове продолжения переходим в правильную точку извлекаем объект ожидания
    * сбрасываем состяние перед продолжением

#### Отслеживание стека(stack, стековый фрейм)
Помещается в стек:
* локальные переменные, объявленных в методе. Б
* скрытые локальные переменные(итератор для foreach), 
* промежуточные выражения, которые не могут применяться до тех пор, пока не будут оценены какие-то другие выражения(бинарные операции вроде сложения и вызовы методов)
		```var х = у * await z;```

#### Ассинхронный шаблон основанный на задачах
##### набор соглашений для ассинхронного программирования
* асинхронные методы заканчиваются на asynс
* задача должна быть горячей(не требовать явного запуска)
##### рекомендации	
* асинхронные операции должны выполнять проверки на предмет ошибочного применения (обычно ситуации с недопустимыми аргументами) синхронным образом. 
* операции, основанные на вводе-выводе, когда работа передается либо диску, либо другому компьютеру - кандидаты для асинхронности 
* задачи, интенсивно загружающие центральный процессор, для этого подходят меньше.
* Способы избежать применения контекста вызывающего кода
	* определенную работу легко выгрузить в пул потоков, и благодаря методу Task.Run()
		* разный вызывающий код может также иметь отличающиеся требования; 
		* если вы просто откроете доступ к синхронному методу
		тем самым предоставив вызывающему коду гибкость в плане работы наиболее подходящим для него способом. 
		    * запустить новую задачу, если это необходимо, 
		    * вызвать метод синхронно, если вполне приемлемо загрузить текущий поток выполнением метода в течение некоторого времени.
	* Task.ConfigureAwait()- метод возвращает реализацию шаблона ожидания. 
	    влияет только на часть синхронизации контекста выполнения
		Когда аргумент 
		* true, объект, поддерживающий ожидание, ведет себя в точности как нормальный объект, так что если асинхронный метод вызывается в потоке пользовательского интерфейса, (например, если асинхронный метод вызывается в потоке пользовательского интерфейса, то продолжение после выражения await будет выполняться в потоке пользовательского интерфейса. удобно, если вам необходим доступ к элементам пользовательского интерфейса)
		* false - если специальные требования отсутствуют, операция не имеет никакой привязки к потоку тогда продолжение будет выполняться обычно в том же контексте, что и завершенная первоначальная операция

#### Объединение ассинхронных операций
объединение связано с последовательностью вызовов, использованием результатов других выховов
это способ, которым можно создавать нейтральные к операциям строительные блоки для управления тем, как обрабатываются задачи.
сбор нескольких результатов в одном массиве **task.WhenAll**
сбор первого успешного запроса **task.WhenAny**
**TaskComplectionSource** озволяет создавать Task с пока отсутствующим результатом
	
#### Контексты
**synchronisationContext** это контекст синхронизации, который позволяет вызовам маршализироваться в подходящий поток, будь он специфичным потоком из пула, одиночным потоком пользовательского интерфейса или любым другим необходимым потоком
Есть еще контексты **SecurityContext LogicCallContext**
Общим является **ExcecutionContext** - контейнер для всех других контекстов
* заполняет точки с await;
* не нужно возвращаться в асинхронный метод, когда задача завершена
* для заполнения контекста он должен быть захвачен во время присоединения продолжения и восстановлен при выполнении продолжения. 
* достигается посредством методов ExecutionContext.Capture() и ExecutionContext.Run().
* Две порции кода, которые могут выполнять такую пару действий “захват/восстановление”: 
    * объект ожидания 
    * класс AsyncTaskMethodBuilder<T> 

#### дополнительные средства c#
```
	string[] values = { "х", "у", "z" };
	var actions = new List<Action>();
	foreach (string value in values)
	{
		actions.Add(() => Console.WriteLine(value));
	}
	foreach (Action action in actions)
	{
		action();
	}
```	
В версиях C# 3 и C# 4 этот код  выводит на консоль z три раза
переменная цикла (value) захватывается лямбда-выражением, и существует лишь один “экземпляр” переменной, который изменяет значение на каждой итерации цикла. 
три делегата ссылаются на одну и ту же переменную, и когда выполнятся, значением этой переменной окажется z. 

5.0 	
каждая итерация цикла вводит отдельную переменную. 
каждый делегат будет ссылаться на отличающуюся переменную, которая получает значение из данной итерации цикла

##Справочник
### Cписки
```
													IEnumerable
														|
													IEnumerable<T>
														|
													Icollection<T> - добавляет свойство count, ReadOnly, методы Add\remove, CopyTo, Contains 
														|
	_____________________________________________________________________________________________________________
	IList<T>                                      | ISet<T>                                    | IDictionary<TKEY, TVALUE>
	индексатор										множество значений  						отображение между ключом и значенем можно извлекать через индексатор или trygetValue(key)
	методы insertat, removeat						hashSet<T>
												SortedSet<T>
```												
#### Indexof											
* Проходит и возвращает элемент по индесу 
* Доступ по индексу
* описывает размер списка 
* поддерживает массивы 
		
#### List<T> 
* хранит массив 
* отслеживает логический размер списка 
* поддерживает массивы. 
* добавление элемента  = добавление содержимого в массив
* удаление элемента требует копирование расположенных за ним элементов на позицию назад => сложность o(n-k), где k-индекс удаленного элемента 
* удаление хвоста менее затратная операция чем голова
* удаление элемента по значению, а не по индексу требуют сложности о(n), так как необходимо проверить весь список на * эквивантность
    * convertall. findAll фильтрует исходный список в нвоый список 
    * Sort() выдает упорядоченную копию
    * orderby устойчив не переупарядочивает эквивалентные элементы
    * bynarySearch - двоичный поиск сложность о(log(n)) он эффективнее чем indexof(cложность o(n))

#### Массивы
* самый низкий уровень коллекций наследуются от Array и единственные коллекции я прямой поддержкой CLR
* размером массива можно управлять через capacity
* если точно изветстен размер можно избежать копирования
* вставка
    * если масиив заполнен - копируется содержимое в новый массив большего размера и устновка нового значения слоджность o(n)
    * если нет - сложность o(1)	
* одномерные массивые реализуют IList<T>
* прямоугольные поддерживают необобщенные интерфейсы
* изменяемы в терминах элементов, но фиксированы в терминах размера
* массивы ссылочных типов всегда ковариантны
* вектор  - одномерный массив с нижней границей 0 
* массив T[][] вектор с элементов T[]

#### LinkedList<T>
* не реализует интернейс IList, потому что не подчиняетсся общему принциипу доступа по индексу
* двухсвязный список определяет головной и хвостовой узел, а каждый узел имеет ссылки на предыдущий и последющий элемент
* связынй список поддреживает размер и доступ к count 
* если имеется ссылка на узел в нужной точке список быстр привставке и удалении. 
	* сложность o(1), т.к необходимо откорректировать следующий и предыдущий элементы

#### Collection<T>
* чаще всего используется как базовый класс, напрмер для bindingList или ObservableCollection. 
* доступно только чтение, все модификаторы скрыты 
* можно использовать insertItem removeItem, переопределив или перехватив методы

### Словарь
#### Dictionary<Tkey, Tvalue>
* для эффективного поиска реализованы хеш-таблицы, т.е эффективность словаря зависит от "хорошести функции хеширования"
* 	можно применить либо стандарные функции Equals GetHashCode внутри объектов  ключей, либо передать реализация IequalityComparer в аргументе конструктора
* ключи должны быть одинаковые, но не хеш коды
* не нужно делать изменяемые ключи, словарь не должен изменяться, если без этого не както действует правило не меняться после вставки в словарь
* словарь никогда не упорядоченн
* словарь хранит элементы в массиве и расширяетс приводя к сложности О(1)
* доступ по ключу о(1)предполагая рациолнальный хеш

#### SordedLisy SortedDictionary<Tkey, TValue>
* это словари 
* не реализуют IList
* производительность o(log n)
* для сравнения используют Icomparer<Tkey>
* отличия SortedList - отсортированный массив
* sortedDictionary красно черное дерево
* заполнение
    * если добавить в конец списка эффективно о(1) 
    * если в произвольное место сложность о(N) вовлекает копирование существующих элементов
    * если добавлять к сбалансированному дереву характеризуется небольшими затратами o(log n), но требует в куче узел   * дерева для каждого элемента , что приводит к накладным расходам

### Множества
* ISet<t> содержит операции для манипуляции множествами (union except intersept with)
* Необходимо для взаимодействия множеств с Linq
* hashSet это dictionary <,> без значений
	* обладает теми же характеристиками производительности 
	* есть removeWhere

### Queue и stack
* базовая идея в коллекцию сначала добавляются элементы а потом удаляются(список действий к выполнению)
* queue реализован с помошью кольцевого буфера 
* поддерживает массив с индексам, запоминающим следующую позицию, куда будет добавлен элемент и индекс в который будет храниться следующая позиция, откуда будет удаляться элемент
* если индекс добавления достигает индекса удаления, ссодержимое копируется в новый объект
* проход по очереди выдает значения по добавлению в очередь
* stack при добавлении элемента они добавляются в конец списка проход дает значения в порядке обратном помещению 

### Параллельные коллекции
ConcurentQueue ConcurentBag ConcurentStack
* все три класса реализуются IEnumerable безопасным к потокам образовм
* итератор, возвращаемый через GetEnumerator будет проходить по списку коллекции
* во время прохода коллекцию можно модифицировать, но изменения не будут видны в итераторе

### ConcurentDictionary<Tkey, Tvalue>
* реализует IDictionary<Tkey, Tvalue> 
* никто из параллельных коллекций не реализует IList
* безопасный словарь в отношении потоков, основанный на хеш-таблице
* поддерживает множество потоков на чтение и запись и позволяет безопасный проход по отношению к потоками
* вносимые изменения могуть быть, а могут не быть отражены в итераторе
* коллекия расширяет возможнсти словаря обновления значения по ключу на основе предыдущего знаечния 
* полученное знаечние на основе ключа должно обновить значение если было ожидаемым
* на каждый элемент дополнительный объем в куче для блокировки

### Потокобезопасные операции
* использование детальной блокировки для обеспечения безопасности потоков кроме чтения
* делегаты для этих методов вызываются за пределами блокировок, чтобы избежать проблем которые могут возникнут при выполнении неизвестного кода при блокировке
* код делегатов не зависит от атоматности(либо целиком выполняется операция, либо не выполняется совсем) операции
* нужно если запись вернутся из нескольких потоков
* для обеспечения потокобезопасности используется Interlocked

## Итоговый
### 2.0
* Обобщения
* типы допускающие null
* итераторные блоки
* частичные типы
* статические классы
* медификаторы доступа внутри свойств
* пмевдонимы пространства имен
* директивы pragma
* буферы фиксированных данных
* дружественные сборки
### 3.0
* LINQ
* Автосвойства
* неявная типизация
* лямбда-выражения
* деревья выражений
* делегаты
* расширяющие методы
* частичные типы, методы
### 4.0
* Динамическая типизация
* именованные аргументы
* обобщенная вариативность
* необязательные параметры
### 5.0
* Ассинхронность
* решение проблем с захватом foreach
